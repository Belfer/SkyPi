// Written by GAmphetamine.js

#pragma once

/////
// scalar          [1]
// vector          [e1,e2,e3,e0]
// bivector        [e23,e31,e12,e01,e02,e03]
// trivector       [e032,e013,e021,e123]
// quadvector      [e0123]
// horizon         [1 e0]
// origin          [1 e123]
// point           [e032,e013,e021,1 e123]
// direction       [e032,e013,e021]
// ebivector       [e23,e31,e12]
// ibivector       [e01,e02,e03]
// evector         [e1,e2,e3]
// dpoint          [e1,e2,e3,1 e0]
// rotation        [1,e23,e31,e12]
// translation     [e01,e02,e03,1 1]
// even            [1,e23,e31,e12,e01,e02,e03,e0123]
// odd             [e1,e2,e3,e0,e032,e013,e021,e123]
/////

#include <initializer_list> // For std::initializer_list
#include <cstddef>          // For size_t
#include <iostream>         // for printing
#include <cmath>            // for fabs
#include <string>           // used in printing

// Constexpr if available
#if __cplusplus >= 201703L
    // C++17 or later
#define CONSTEXPR constexpr
#else
    // older standard (e.g., C++11 or C++14)
#define CONSTEXPR
#endif

// Type definition section

using scalar_t = float;

// VECTOR : {e1, e2, e3, e0}

struct vector_t {

    // Coefficient storage
    float d[4] = { 0.0f };

    // Constructors, default, from array, from initializer list.
    CONSTEXPR vector_t() = default;
    CONSTEXPR vector_t(const float(&arr)[4]) {
        for (size_t i = 0; i < 4; ++i) d[i] = arr[i];
    }
    CONSTEXPR vector_t(std::initializer_list<float> init) {
        size_t i = 0;
        for (auto it = init.begin(); it != init.end() && i < 4; ++it, ++i) d[i] = *it;
    }

    // Indexed coefficient access.
    CONSTEXPR float& operator[](size_t i) { return d[i]; }
    CONSTEXPR const float operator[](size_t i) const { return d[i]; }

    // Named coefficient access.
    CONSTEXPR const float e1() const { return d[0]; }
    CONSTEXPR const float e2() const { return d[1]; }
    CONSTEXPR const float e3() const { return d[2]; }
    CONSTEXPR const float e0() const { return d[3]; }
    CONSTEXPR float& e1() { return d[0]; }
    CONSTEXPR float& e2() { return d[1]; }
    CONSTEXPR float& e3() { return d[2]; }
    CONSTEXPR float& e0() { return d[3]; }

    // Nice printing.
    friend std::ostream& operator<<(std::ostream& os, const vector_t& v) {
        os << "vector_t {";

        static const std::string blade_names[4] = { "e1","e2","e3","e0" };
        static const float fixed[4] = { 0.0f,0.0f,0.0f,0.0f };
        for (size_t i = 0; i < 4; ++i) {
            float vv = fixed[i];
            if (i < 4) vv += v.d[i];
            if (vv != 0.0f) {
                if (vv < 0.0f) os << " - "; else if (i > 0) os << " + ";
                os << std::fabs(vv);
                if (blade_names[i] != "1") os << blade_names[i];
            }
        }

        os << "}";
        return os;
    }
};

// BIVECTOR : {e23, e31, e12, e01, e02, e03}

struct bivector_t {

    // Coefficient storage
    float d[6] = { 0.0f };

    // Constructors, default, from array, from initializer list.
    CONSTEXPR bivector_t() = default;
    CONSTEXPR bivector_t(const float(&arr)[6]) {
        for (size_t i = 0; i < 6; ++i) d[i] = arr[i];
    }
    CONSTEXPR bivector_t(std::initializer_list<float> init) {
        size_t i = 0;
        for (auto it = init.begin(); it != init.end() && i < 6; ++it, ++i) d[i] = *it;
    }

    // Indexed coefficient access.
    CONSTEXPR float& operator[](size_t i) { return d[i]; }
    CONSTEXPR const float operator[](size_t i) const { return d[i]; }

    // Named coefficient access.
    CONSTEXPR const float e23() const { return d[0]; }
    CONSTEXPR const float e31() const { return d[1]; }
    CONSTEXPR const float e12() const { return d[2]; }
    CONSTEXPR const float e01() const { return d[3]; }
    CONSTEXPR const float e02() const { return d[4]; }
    CONSTEXPR const float e03() const { return d[5]; }
    CONSTEXPR float& e23() { return d[0]; }
    CONSTEXPR float& e31() { return d[1]; }
    CONSTEXPR float& e12() { return d[2]; }
    CONSTEXPR float& e01() { return d[3]; }
    CONSTEXPR float& e02() { return d[4]; }
    CONSTEXPR float& e03() { return d[5]; }

    // Nice printing.
    friend std::ostream& operator<<(std::ostream& os, const bivector_t& v) {
        os << "bivector_t {";

        static const std::string blade_names[6] = { "e23","e31","e12","e01","e02","e03" };
        static const float fixed[6] = { 0.0f,0.0f,0.0f,0.0f,0.0f,0.0f };
        for (size_t i = 0; i < 6; ++i) {
            float vv = fixed[i];
            if (i < 6) vv += v.d[i];
            if (vv != 0.0f) {
                if (vv < 0.0f) os << " - "; else if (i > 0) os << " + ";
                os << std::fabs(vv);
                if (blade_names[i] != "1") os << blade_names[i];
            }
        }

        os << "}";
        return os;
    }
};

// TRIVECTOR : {e032, e013, e021, e123}

struct trivector_t {

    // Coefficient storage
    float d[4] = { 0.0f };

    // Constructors, default, from array, from initializer list.
    CONSTEXPR trivector_t() = default;
    CONSTEXPR trivector_t(const float(&arr)[4]) {
        for (size_t i = 0; i < 4; ++i) d[i] = arr[i];
    }
    CONSTEXPR trivector_t(std::initializer_list<float> init) {
        size_t i = 0;
        for (auto it = init.begin(); it != init.end() && i < 4; ++it, ++i) d[i] = *it;
    }

    // Indexed coefficient access.
    CONSTEXPR float& operator[](size_t i) { return d[i]; }
    CONSTEXPR const float operator[](size_t i) const { return d[i]; }

    // Named coefficient access.
    CONSTEXPR const float e032() const { return d[0]; }
    CONSTEXPR const float e013() const { return d[1]; }
    CONSTEXPR const float e021() const { return d[2]; }
    CONSTEXPR const float e123() const { return d[3]; }
    CONSTEXPR float& e032() { return d[0]; }
    CONSTEXPR float& e013() { return d[1]; }
    CONSTEXPR float& e021() { return d[2]; }
    CONSTEXPR float& e123() { return d[3]; }

    // Nice printing.
    friend std::ostream& operator<<(std::ostream& os, const trivector_t& v) {
        os << "trivector_t {";

        static const std::string blade_names[4] = { "e032","e013","e021","e123" };
        static const float fixed[4] = { 0.0f,0.0f,0.0f,0.0f };
        for (size_t i = 0; i < 4; ++i) {
            float vv = fixed[i];
            if (i < 4) vv += v.d[i];
            if (vv != 0.0f) {
                if (vv < 0.0f) os << " - "; else if (i > 0) os << " + ";
                os << std::fabs(vv);
                if (blade_names[i] != "1") os << blade_names[i];
            }
        }

        os << "}";
        return os;
    }
};

// QUADVECTOR : {e0123}

struct quadvector_t {

    // Coefficient storage
    float d[1] = { 0.0f };

    // Constructors, default, from array, from initializer list.
    CONSTEXPR quadvector_t() = default;
    CONSTEXPR quadvector_t(const float(&arr)[1]) {
        for (size_t i = 0; i < 1; ++i) d[i] = arr[i];
    }
    CONSTEXPR quadvector_t(std::initializer_list<float> init) {
        size_t i = 0;
        for (auto it = init.begin(); it != init.end() && i < 1; ++it, ++i) d[i] = *it;
    }

    // Indexed coefficient access.
    CONSTEXPR float& operator[](size_t i) { return d[i]; }
    CONSTEXPR const float operator[](size_t i) const { return d[i]; }

    // Named coefficient access.
    CONSTEXPR const float e0123() const { return d[0]; }
    CONSTEXPR float& e0123() { return d[0]; }

    // Nice printing.
    friend std::ostream& operator<<(std::ostream& os, const quadvector_t& v) {
        os << "quadvector_t {";

        static const std::string blade_names[1] = { "e0123" };
        static const float fixed[1] = { 0.0f };
        for (size_t i = 0; i < 1; ++i) {
            float vv = fixed[i];
            if (i < 1) vv += v.d[i];
            if (vv != 0.0f) {
                if (vv < 0.0f) os << " - "; else if (i > 0) os << " + ";
                os << std::fabs(vv);
                if (blade_names[i] != "1") os << blade_names[i];
            }
        }

        os << "}";
        return os;
    }
};

// HORIZON : {e0}

struct horizon_t {

    // Named coefficient access.
    CONSTEXPR const float e0() const { return 1.0f; }


    // Nice printing.
    friend std::ostream& operator<<(std::ostream& os, const horizon_t& v) {
        os << "horizon_t {";

        os << "}";
        return os;
    }
};

// ORIGIN : {e123}

struct origin_t {

    // Named coefficient access.
    CONSTEXPR const float e123() const { return 1.0f; }


    // Nice printing.
    friend std::ostream& operator<<(std::ostream& os, const origin_t& v) {
        os << "origin_t {";

        os << "}";
        return os;
    }
};

// POINT : {e032, e013, e021, e123}

struct point_t {

    // Coefficient storage
    float d[3] = { 0.0f };

    // Constructors, default, from array, from initializer list.
    CONSTEXPR point_t() = default;
    CONSTEXPR point_t(const float(&arr)[4]) {
        for (size_t i = 0; i < 4; ++i) d[i] = arr[i];
    }
    CONSTEXPR point_t(std::initializer_list<float> init) {
        size_t i = 0;
        for (auto it = init.begin(); it != init.end() && i < 4; ++it, ++i) d[i] = *it;
    }

    // Indexed coefficient access.
    CONSTEXPR float& operator[](size_t i) { return d[i]; }
    CONSTEXPR const float operator[](size_t i) const { return d[i]; }

    // Named coefficient access.
    CONSTEXPR const float e032() const { return d[0]; }
    CONSTEXPR const float e013() const { return d[1]; }
    CONSTEXPR const float e021() const { return d[2]; }
    CONSTEXPR const float e123() const { return 1.0f; }
    CONSTEXPR float& e032() { return d[0]; }
    CONSTEXPR float& e013() { return d[1]; }
    CONSTEXPR float& e021() { return d[2]; }

    // Nice printing.
    friend std::ostream& operator<<(std::ostream& os, const point_t& v) {
        os << "point_t {";

        static const std::string blade_names[4] = { "e032","e013","e021","e123" };
        static const float fixed[4] = { 0.0f,0.0f,0.0f,1.0f };
        for (size_t i = 0; i < 4; ++i) {
            float vv = fixed[i];
            if (i < 3) vv += v.d[i];
            if (vv != 0.0f) {
                if (vv < 0.0f) os << " - "; else if (i > 0) os << " + ";
                os << std::fabs(vv);
                if (blade_names[i] != "1") os << blade_names[i];
            }
        }

        os << "}";
        return os;
    }
};

// DIRECTION : {e032, e013, e021}

struct direction_t {

    // Coefficient storage
    float d[3] = { 0.0f };

    // Constructors, default, from array, from initializer list.
    CONSTEXPR direction_t() = default;
    CONSTEXPR direction_t(const float(&arr)[3]) {
        for (size_t i = 0; i < 3; ++i) d[i] = arr[i];
    }
    CONSTEXPR direction_t(std::initializer_list<float> init) {
        size_t i = 0;
        for (auto it = init.begin(); it != init.end() && i < 3; ++it, ++i) d[i] = *it;
    }

    // Indexed coefficient access.
    CONSTEXPR float& operator[](size_t i) { return d[i]; }
    CONSTEXPR const float operator[](size_t i) const { return d[i]; }

    // Named coefficient access.
    CONSTEXPR const float e032() const { return d[0]; }
    CONSTEXPR const float e013() const { return d[1]; }
    CONSTEXPR const float e021() const { return d[2]; }
    CONSTEXPR float& e032() { return d[0]; }
    CONSTEXPR float& e013() { return d[1]; }
    CONSTEXPR float& e021() { return d[2]; }

    // Nice printing.
    friend std::ostream& operator<<(std::ostream& os, const direction_t& v) {
        os << "direction_t {";

        static const std::string blade_names[3] = { "e032","e013","e021" };
        static const float fixed[3] = { 0.0f,0.0f,0.0f };
        for (size_t i = 0; i < 3; ++i) {
            float vv = fixed[i];
            if (i < 3) vv += v.d[i];
            if (vv != 0.0f) {
                if (vv < 0.0f) os << " - "; else if (i > 0) os << " + ";
                os << std::fabs(vv);
                if (blade_names[i] != "1") os << blade_names[i];
            }
        }

        os << "}";
        return os;
    }
};

// EBIVECTOR : {e23, e31, e12}

struct ebivector_t {

    // Coefficient storage
    float d[3] = { 0.0f };

    // Constructors, default, from array, from initializer list.
    CONSTEXPR ebivector_t() = default;
    CONSTEXPR ebivector_t(const float(&arr)[3]) {
        for (size_t i = 0; i < 3; ++i) d[i] = arr[i];
    }
    CONSTEXPR ebivector_t(std::initializer_list<float> init) {
        size_t i = 0;
        for (auto it = init.begin(); it != init.end() && i < 3; ++it, ++i) d[i] = *it;
    }

    // Indexed coefficient access.
    CONSTEXPR float& operator[](size_t i) { return d[i]; }
    CONSTEXPR const float operator[](size_t i) const { return d[i]; }

    // Named coefficient access.
    CONSTEXPR const float e23() const { return d[0]; }
    CONSTEXPR const float e31() const { return d[1]; }
    CONSTEXPR const float e12() const { return d[2]; }
    CONSTEXPR float& e23() { return d[0]; }
    CONSTEXPR float& e31() { return d[1]; }
    CONSTEXPR float& e12() { return d[2]; }

    // Nice printing.
    friend std::ostream& operator<<(std::ostream& os, const ebivector_t& v) {
        os << "ebivector_t {";

        static const std::string blade_names[3] = { "e23","e31","e12" };
        static const float fixed[3] = { 0.0f,0.0f,0.0f };
        for (size_t i = 0; i < 3; ++i) {
            float vv = fixed[i];
            if (i < 3) vv += v.d[i];
            if (vv != 0.0f) {
                if (vv < 0.0f) os << " - "; else if (i > 0) os << " + ";
                os << std::fabs(vv);
                if (blade_names[i] != "1") os << blade_names[i];
            }
        }

        os << "}";
        return os;
    }
};

// IBIVECTOR : {e01, e02, e03}

struct ibivector_t {

    // Coefficient storage
    float d[3] = { 0.0f };

    // Constructors, default, from array, from initializer list.
    CONSTEXPR ibivector_t() = default;
    CONSTEXPR ibivector_t(const float(&arr)[3]) {
        for (size_t i = 0; i < 3; ++i) d[i] = arr[i];
    }
    CONSTEXPR ibivector_t(std::initializer_list<float> init) {
        size_t i = 0;
        for (auto it = init.begin(); it != init.end() && i < 3; ++it, ++i) d[i] = *it;
    }

    // Indexed coefficient access.
    CONSTEXPR float& operator[](size_t i) { return d[i]; }
    CONSTEXPR const float operator[](size_t i) const { return d[i]; }

    // Named coefficient access.
    CONSTEXPR const float e01() const { return d[0]; }
    CONSTEXPR const float e02() const { return d[1]; }
    CONSTEXPR const float e03() const { return d[2]; }
    CONSTEXPR float& e01() { return d[0]; }
    CONSTEXPR float& e02() { return d[1]; }
    CONSTEXPR float& e03() { return d[2]; }

    // Nice printing.
    friend std::ostream& operator<<(std::ostream& os, const ibivector_t& v) {
        os << "ibivector_t {";

        static const std::string blade_names[3] = { "e01","e02","e03" };
        static const float fixed[3] = { 0.0f,0.0f,0.0f };
        for (size_t i = 0; i < 3; ++i) {
            float vv = fixed[i];
            if (i < 3) vv += v.d[i];
            if (vv != 0.0f) {
                if (vv < 0.0f) os << " - "; else if (i > 0) os << " + ";
                os << std::fabs(vv);
                if (blade_names[i] != "1") os << blade_names[i];
            }
        }

        os << "}";
        return os;
    }
};

// EVECTOR : {e1, e2, e3}

struct evector_t {

    // Coefficient storage
    float d[3] = { 0.0f };

    // Constructors, default, from array, from initializer list.
    CONSTEXPR evector_t() = default;
    CONSTEXPR evector_t(const float(&arr)[3]) {
        for (size_t i = 0; i < 3; ++i) d[i] = arr[i];
    }
    CONSTEXPR evector_t(std::initializer_list<float> init) {
        size_t i = 0;
        for (auto it = init.begin(); it != init.end() && i < 3; ++it, ++i) d[i] = *it;
    }

    // Indexed coefficient access.
    CONSTEXPR float& operator[](size_t i) { return d[i]; }
    CONSTEXPR const float operator[](size_t i) const { return d[i]; }

    // Named coefficient access.
    CONSTEXPR const float e1() const { return d[0]; }
    CONSTEXPR const float e2() const { return d[1]; }
    CONSTEXPR const float e3() const { return d[2]; }
    CONSTEXPR float& e1() { return d[0]; }
    CONSTEXPR float& e2() { return d[1]; }
    CONSTEXPR float& e3() { return d[2]; }

    // Nice printing.
    friend std::ostream& operator<<(std::ostream& os, const evector_t& v) {
        os << "evector_t {";

        static const std::string blade_names[3] = { "e1","e2","e3" };
        static const float fixed[3] = { 0.0f,0.0f,0.0f };
        for (size_t i = 0; i < 3; ++i) {
            float vv = fixed[i];
            if (i < 3) vv += v.d[i];
            if (vv != 0.0f) {
                if (vv < 0.0f) os << " - "; else if (i > 0) os << " + ";
                os << std::fabs(vv);
                if (blade_names[i] != "1") os << blade_names[i];
            }
        }

        os << "}";
        return os;
    }
};

// DPOINT : {e1, e2, e3, e0}

struct dpoint_t {

    // Coefficient storage
    float d[3] = { 0.0f };

    // Constructors, default, from array, from initializer list.
    CONSTEXPR dpoint_t() = default;
    CONSTEXPR dpoint_t(const float(&arr)[4]) {
        for (size_t i = 0; i < 4; ++i) d[i] = arr[i];
    }
    CONSTEXPR dpoint_t(std::initializer_list<float> init) {
        size_t i = 0;
        for (auto it = init.begin(); it != init.end() && i < 4; ++it, ++i) d[i] = *it;
    }

    // Indexed coefficient access.
    CONSTEXPR float& operator[](size_t i) { return d[i]; }
    CONSTEXPR const float operator[](size_t i) const { return d[i]; }

    // Named coefficient access.
    CONSTEXPR const float e1() const { return d[0]; }
    CONSTEXPR const float e2() const { return d[1]; }
    CONSTEXPR const float e3() const { return d[2]; }
    CONSTEXPR const float e0() const { return 1.0f; }
    CONSTEXPR float& e1() { return d[0]; }
    CONSTEXPR float& e2() { return d[1]; }
    CONSTEXPR float& e3() { return d[2]; }

    // Nice printing.
    friend std::ostream& operator<<(std::ostream& os, const dpoint_t& v) {
        os << "dpoint_t {";

        static const std::string blade_names[4] = { "e1","e2","e3","e0" };
        static const float fixed[4] = { 0.0f,0.0f,0.0f,1.0f };
        for (size_t i = 0; i < 4; ++i) {
            float vv = fixed[i];
            if (i < 3) vv += v.d[i];
            if (vv != 0.0f) {
                if (vv < 0.0f) os << " - "; else if (i > 0) os << " + ";
                os << std::fabs(vv);
                if (blade_names[i] != "1") os << blade_names[i];
            }
        }

        os << "}";
        return os;
    }
};

// ROTATION : {1, e23, e31, e12}

struct rotation_t {

    // Coefficient storage
    float d[4] = { 0.0f };

    // Constructors, default, from array, from initializer list.
    CONSTEXPR rotation_t() = default;
    CONSTEXPR rotation_t(const float(&arr)[4]) {
        for (size_t i = 0; i < 4; ++i) d[i] = arr[i];
    }
    CONSTEXPR rotation_t(std::initializer_list<float> init) {
        size_t i = 0;
        for (auto it = init.begin(); it != init.end() && i < 4; ++it, ++i) d[i] = *it;
    }

    // Indexed coefficient access.
    CONSTEXPR float& operator[](size_t i) { return d[i]; }
    CONSTEXPR const float operator[](size_t i) const { return d[i]; }

    // Named coefficient access.
    CONSTEXPR const float s() const { return d[0]; }
    CONSTEXPR const float e23() const { return d[1]; }
    CONSTEXPR const float e31() const { return d[2]; }
    CONSTEXPR const float e12() const { return d[3]; }
    CONSTEXPR float& s() { return d[0]; }
    CONSTEXPR float& e23() { return d[1]; }
    CONSTEXPR float& e31() { return d[2]; }
    CONSTEXPR float& e12() { return d[3]; }

    // Nice printing.
    friend std::ostream& operator<<(std::ostream& os, const rotation_t& v) {
        os << "rotation_t {";

        static const std::string blade_names[4] = { "1","e23","e31","e12" };
        static const float fixed[4] = { 0.0f,0.0f,0.0f,0.0f };
        for (size_t i = 0; i < 4; ++i) {
            float vv = fixed[i];
            if (i < 4) vv += v.d[i];
            if (vv != 0.0f) {
                if (vv < 0.0f) os << " - "; else if (i > 0) os << " + ";
                os << std::fabs(vv);
                if (blade_names[i] != "1") os << blade_names[i];
            }
        }

        os << "}";
        return os;
    }
};

// TRANSLATION : {e01, e02, e03, 1}

struct translation_t {

    // Coefficient storage
    float d[3] = { 0.0f };

    // Constructors, default, from array, from initializer list.
    CONSTEXPR translation_t() = default;
    CONSTEXPR translation_t(const float(&arr)[4]) {
        for (size_t i = 0; i < 4; ++i) d[i] = arr[i];
    }
    CONSTEXPR translation_t(std::initializer_list<float> init) {
        size_t i = 0;
        for (auto it = init.begin(); it != init.end() && i < 4; ++it, ++i) d[i] = *it;
    }

    // Indexed coefficient access.
    CONSTEXPR float& operator[](size_t i) { return d[i]; }
    CONSTEXPR const float operator[](size_t i) const { return d[i]; }

    // Named coefficient access.
    CONSTEXPR const float e01() const { return d[0]; }
    CONSTEXPR const float e02() const { return d[1]; }
    CONSTEXPR const float e03() const { return d[2]; }
    CONSTEXPR const float s() const { return 1.0f; }
    CONSTEXPR float& e01() { return d[0]; }
    CONSTEXPR float& e02() { return d[1]; }
    CONSTEXPR float& e03() { return d[2]; }

    // Nice printing.
    friend std::ostream& operator<<(std::ostream& os, const translation_t& v) {
        os << "translation_t {";

        static const std::string blade_names[4] = { "e01","e02","e03","1" };
        static const float fixed[4] = { 0.0f,0.0f,0.0f,1.0f };
        for (size_t i = 0; i < 4; ++i) {
            float vv = fixed[i];
            if (i < 3) vv += v.d[i];
            if (vv != 0.0f) {
                if (vv < 0.0f) os << " - "; else if (i > 0) os << " + ";
                os << std::fabs(vv);
                if (blade_names[i] != "1") os << blade_names[i];
            }
        }

        os << "}";
        return os;
    }
};

// EVEN : {1, e23, e31, e12, e01, e02, e03, e0123}

struct even_t {

    // Coefficient storage
    float d[8] = { 0.0f };

    // Constructors, default, from array, from initializer list.
    CONSTEXPR even_t() = default;
    CONSTEXPR even_t(const float(&arr)[8]) {
        for (size_t i = 0; i < 8; ++i) d[i] = arr[i];
    }
    CONSTEXPR even_t(std::initializer_list<float> init) {
        size_t i = 0;
        for (auto it = init.begin(); it != init.end() && i < 8; ++it, ++i) d[i] = *it;
    }

    // Indexed coefficient access.
    CONSTEXPR float& operator[](size_t i) { return d[i]; }
    CONSTEXPR const float operator[](size_t i) const { return d[i]; }

    // Named coefficient access.
    CONSTEXPR const float s() const { return d[0]; }
    CONSTEXPR const float e23() const { return d[1]; }
    CONSTEXPR const float e31() const { return d[2]; }
    CONSTEXPR const float e12() const { return d[3]; }
    CONSTEXPR const float e01() const { return d[4]; }
    CONSTEXPR const float e02() const { return d[5]; }
    CONSTEXPR const float e03() const { return d[6]; }
    CONSTEXPR const float e0123() const { return d[7]; }
    CONSTEXPR float& s() { return d[0]; }
    CONSTEXPR float& e23() { return d[1]; }
    CONSTEXPR float& e31() { return d[2]; }
    CONSTEXPR float& e12() { return d[3]; }
    CONSTEXPR float& e01() { return d[4]; }
    CONSTEXPR float& e02() { return d[5]; }
    CONSTEXPR float& e03() { return d[6]; }
    CONSTEXPR float& e0123() { return d[7]; }

    // Nice printing.
    friend std::ostream& operator<<(std::ostream& os, const even_t& v) {
        os << "even_t {";

        static const std::string blade_names[8] = { "1","e23","e31","e12","e01","e02","e03","e0123" };
        static const float fixed[8] = { 0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f };
        for (size_t i = 0; i < 8; ++i) {
            float vv = fixed[i];
            if (i < 8) vv += v.d[i];
            if (vv != 0.0f) {
                if (vv < 0.0f) os << " - "; else if (i > 0) os << " + ";
                os << std::fabs(vv);
                if (blade_names[i] != "1") os << blade_names[i];
            }
        }

        os << "}";
        return os;
    }
};

// ODD : {e1, e2, e3, e0, e032, e013, e021, e123}

struct odd_t {

    // Coefficient storage
    float d[8] = { 0.0f };

    // Constructors, default, from array, from initializer list.
    CONSTEXPR odd_t() = default;
    CONSTEXPR odd_t(const float(&arr)[8]) {
        for (size_t i = 0; i < 8; ++i) d[i] = arr[i];
    }
    CONSTEXPR odd_t(std::initializer_list<float> init) {
        size_t i = 0;
        for (auto it = init.begin(); it != init.end() && i < 8; ++it, ++i) d[i] = *it;
    }

    // Indexed coefficient access.
    CONSTEXPR float& operator[](size_t i) { return d[i]; }
    CONSTEXPR const float operator[](size_t i) const { return d[i]; }

    // Named coefficient access.
    CONSTEXPR const float e1() const { return d[0]; }
    CONSTEXPR const float e2() const { return d[1]; }
    CONSTEXPR const float e3() const { return d[2]; }
    CONSTEXPR const float e0() const { return d[3]; }
    CONSTEXPR const float e032() const { return d[4]; }
    CONSTEXPR const float e013() const { return d[5]; }
    CONSTEXPR const float e021() const { return d[6]; }
    CONSTEXPR const float e123() const { return d[7]; }
    CONSTEXPR float& e1() { return d[0]; }
    CONSTEXPR float& e2() { return d[1]; }
    CONSTEXPR float& e3() { return d[2]; }
    CONSTEXPR float& e0() { return d[3]; }
    CONSTEXPR float& e032() { return d[4]; }
    CONSTEXPR float& e013() { return d[5]; }
    CONSTEXPR float& e021() { return d[6]; }
    CONSTEXPR float& e123() { return d[7]; }

    // Nice printing.
    friend std::ostream& operator<<(std::ostream& os, const odd_t& v) {
        os << "odd_t {";

        static const std::string blade_names[8] = { "e1","e2","e3","e0","e032","e013","e021","e123" };
        static const float fixed[8] = { 0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f,0.0f };
        for (size_t i = 0; i < 8; ++i) {
            float vv = fixed[i];
            if (i < 8) vv += v.d[i];
            if (vv != 0.0f) {
                if (vv < 0.0f) os << " - "; else if (i > 0) os << " + ";
                os << std::fabs(vv);
                if (blade_names[i] != "1") os << blade_names[i];
            }
        }

        os << "}";
        return os;
    }
};

CONSTEXPR static const evector_t e1 = { 1.0f, 0.0f, 0.0f };
CONSTEXPR static const evector_t e2 = { 0.0f, 1.0f, 0.0f };
CONSTEXPR static const evector_t e3 = { 0.0f, 0.0f, 1.0f };
CONSTEXPR static const horizon_t e0;
CONSTEXPR static const ebivector_t e23 = { 1.0f, 0.0f, 0.0f };
CONSTEXPR static const ebivector_t e31 = { 0.0f, 1.0f, 0.0f };
CONSTEXPR static const ebivector_t e12 = { 0.0f, 0.0f, 1.0f };
CONSTEXPR static const ibivector_t e01 = { 1.0f, 0.0f, 0.0f };
CONSTEXPR static const ibivector_t e02 = { 0.0f, 1.0f, 0.0f };
CONSTEXPR static const ibivector_t e03 = { 0.0f, 0.0f, 1.0f };
CONSTEXPR static const direction_t e032 = { 1.0f, 0.0f, 0.0f };
CONSTEXPR static const direction_t e013 = { 0.0f, 1.0f, 0.0f };
CONSTEXPR static const direction_t e021 = { 0.0f, 0.0f, 1.0f };
CONSTEXPR static const origin_t e123;
CONSTEXPR static const quadvector_t e0123 = { 1.0f };

////////////////////////////////////////////////////////////////////////////////  
// add between scalar and bivector  
// a
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const scalar_t& a, const bivector_t& b) {
    even_t res;
    res.d[0] = a;
    res.d[1] = b.d[0];
    res.d[2] = b.d[1];
    res.d[3] = b.d[2];
    res.d[4] = b.d[3];
    res.d[5] = b.d[4];
    res.d[6] = b.d[5];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between scalar and quadvector  
// a
// b0 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const scalar_t& a, const quadvector_t& b) {
    even_t res;
    res.d[0] = a;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = b.d[0];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between scalar and ebivector  
// a
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator+(const scalar_t& a, const ebivector_t& b) {
    rotation_t res;
    res.d[0] = a;
    res.d[1] = b.d[0];
    res.d[2] = b.d[1];
    res.d[3] = b.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between scalar and ibivector  
// a
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const scalar_t& a, const ibivector_t& b) {
    even_t res;
    res.d[0] = a;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = b.d[0];
    res.d[5] = b.d[1];
    res.d[6] = b.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between scalar and rotation  
// a
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator+(const scalar_t& a, const rotation_t& b) {
    rotation_t res;
    res.d[0] = a + b.d[0];
    res.d[1] = b.d[1];
    res.d[2] = b.d[2];
    res.d[3] = b.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between scalar and translation  
// a
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const scalar_t& a, const translation_t& b) {
    even_t res;
    res.d[0] = 1 + a;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = b.d[0];
    res.d[5] = b.d[1];
    res.d[6] = b.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between scalar and even  
// a
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const scalar_t& a, const even_t& b) {
    even_t res;
    res.d[0] = a + b.d[0];
    res.d[1] = b.d[1];
    res.d[2] = b.d[2];
    res.d[3] = b.d[3];
    res.d[4] = b.d[4];
    res.d[5] = b.d[5];
    res.d[6] = b.d[6];
    res.d[7] = b.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between vector and vector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator+(const vector_t& a, const vector_t& b) {
    vector_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    res.d[3] = a.d[3] + b.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between vector and trivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const vector_t& a, const trivector_t& b) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    res.d[4] = b.d[0];
    res.d[5] = b.d[1];
    res.d[6] = b.d[2];
    res.d[7] = b.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between vector and horizon  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator+(const vector_t& a, const horizon_t& b) {
    vector_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = 1 + a.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between vector and origin  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const vector_t& a, const origin_t& b) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between vector and point  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const vector_t& a, const point_t& b) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    res.d[4] = b.d[0];
    res.d[5] = b.d[1];
    res.d[6] = b.d[2];
    res.d[7] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between vector and direction  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const vector_t& a, const direction_t& b) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    res.d[4] = b.d[0];
    res.d[5] = b.d[1];
    res.d[6] = b.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between vector and evector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator+(const vector_t& a, const evector_t& b) {
    vector_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    res.d[3] = a.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between vector and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator+(const vector_t& a, const dpoint_t& b) {
    vector_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    res.d[3] = 1 + a.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between vector and odd  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const vector_t& a, const odd_t& b) {
    odd_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    res.d[3] = a.d[3] + b.d[3];
    res.d[4] = b.d[4];
    res.d[5] = b.d[5];
    res.d[6] = b.d[6];
    res.d[7] = b.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between bivector and scalar  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const bivector_t& a, const scalar_t& b) {
    even_t res;
    res.d[0] = b;
    res.d[1] = a.d[0];
    res.d[2] = a.d[1];
    res.d[3] = a.d[2];
    res.d[4] = a.d[3];
    res.d[5] = a.d[4];
    res.d[6] = a.d[5];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between bivector and bivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 0 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator+(const bivector_t& a, const bivector_t& b) {
    bivector_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    res.d[3] = a.d[3] + b.d[3];
    res.d[4] = a.d[4] + b.d[4];
    res.d[5] = a.d[5] + b.d[5];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between bivector and quadvector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const bivector_t& a, const quadvector_t& b) {
    even_t res;
    res.d[0] = 0.0;
    res.d[1] = a.d[0];
    res.d[2] = a.d[1];
    res.d[3] = a.d[2];
    res.d[4] = a.d[3];
    res.d[5] = a.d[4];
    res.d[6] = a.d[5];
    res.d[7] = b.d[0];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between bivector and ebivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator+(const bivector_t& a, const ebivector_t& b) {
    bivector_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    res.d[3] = a.d[3];
    res.d[4] = a.d[4];
    res.d[5] = a.d[5];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between bivector and ibivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator+(const bivector_t& a, const ibivector_t& b) {
    bivector_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3] + b.d[0];
    res.d[4] = a.d[4] + b.d[1];
    res.d[5] = a.d[5] + b.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between bivector and rotation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const bivector_t& a, const rotation_t& b) {
    even_t res;
    res.d[0] = b.d[0];
    res.d[1] = a.d[0] + b.d[1];
    res.d[2] = a.d[1] + b.d[2];
    res.d[3] = a.d[2] + b.d[3];
    res.d[4] = a.d[3];
    res.d[5] = a.d[4];
    res.d[6] = a.d[5];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between bivector and translation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const bivector_t& a, const translation_t& b) {
    even_t res;
    res.d[0] = 1.0;
    res.d[1] = a.d[0];
    res.d[2] = a.d[1];
    res.d[3] = a.d[2];
    res.d[4] = a.d[3] + b.d[0];
    res.d[5] = a.d[4] + b.d[1];
    res.d[6] = a.d[5] + b.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between bivector and even  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const bivector_t& a, const even_t& b) {
    even_t res;
    res.d[0] = b.d[0];
    res.d[1] = a.d[0] + b.d[1];
    res.d[2] = a.d[1] + b.d[2];
    res.d[3] = a.d[2] + b.d[3];
    res.d[4] = a.d[3] + b.d[4];
    res.d[5] = a.d[4] + b.d[5];
    res.d[6] = a.d[5] + b.d[6];
    res.d[7] = b.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between trivector and vector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const trivector_t& a, const vector_t& b) {
    odd_t res;
    res.d[0] = b.d[0];
    res.d[1] = b.d[1];
    res.d[2] = b.d[2];
    res.d[3] = b.d[3];
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = a.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between trivector and trivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator+(const trivector_t& a, const trivector_t& b) {
    trivector_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    res.d[3] = a.d[3] + b.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between trivector and horizon  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const trivector_t& a, const horizon_t& b) {
    odd_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 1.0;
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = a.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between trivector and origin  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator+(const trivector_t& a, const origin_t& b) {
    trivector_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = 1 + a.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between trivector and point  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator+(const trivector_t& a, const point_t& b) {
    trivector_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    res.d[3] = 1 + a.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between trivector and direction  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator+(const trivector_t& a, const direction_t& b) {
    trivector_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    res.d[3] = a.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between trivector and evector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const trivector_t& a, const evector_t& b) {
    odd_t res;
    res.d[0] = b.d[0];
    res.d[1] = b.d[1];
    res.d[2] = b.d[2];
    res.d[3] = 0.0;
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = a.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between trivector and dpoint  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const trivector_t& a, const dpoint_t& b) {
    odd_t res;
    res.d[0] = b.d[0];
    res.d[1] = b.d[1];
    res.d[2] = b.d[2];
    res.d[3] = 1.0;
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = a.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between trivector and odd  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const trivector_t& a, const odd_t& b) {
    odd_t res;
    res.d[0] = b.d[0];
    res.d[1] = b.d[1];
    res.d[2] = b.d[2];
    res.d[3] = b.d[3];
    res.d[4] = a.d[0] + b.d[4];
    res.d[5] = a.d[1] + b.d[5];
    res.d[6] = a.d[2] + b.d[6];
    res.d[7] = a.d[3] + b.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between quadvector and scalar  
// a0 e₀₁₂₃
// b
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const quadvector_t& a, const scalar_t& b) {
    even_t res;
    res.d[0] = b;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = a.d[0];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between quadvector and bivector  
// a0 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const quadvector_t& a, const bivector_t& b) {
    even_t res;
    res.d[0] = 0.0;
    res.d[1] = b.d[0];
    res.d[2] = b.d[1];
    res.d[3] = b.d[2];
    res.d[4] = b.d[3];
    res.d[5] = b.d[4];
    res.d[6] = b.d[5];
    res.d[7] = a.d[0];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between quadvector and quadvector  
// a0 e₀₁₂₃
// b0 e₀₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator+(const quadvector_t& a, const quadvector_t& b) {
    quadvector_t res;
    res.d[0] = a.d[0] + b.d[0];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between quadvector and ebivector  
// a0 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const quadvector_t& a, const ebivector_t& b) {
    even_t res;
    res.d[0] = 0.0;
    res.d[1] = b.d[0];
    res.d[2] = b.d[1];
    res.d[3] = b.d[2];
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = a.d[0];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between quadvector and ibivector  
// a0 e₀₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const quadvector_t& a, const ibivector_t& b) {
    even_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = b.d[0];
    res.d[5] = b.d[1];
    res.d[6] = b.d[2];
    res.d[7] = a.d[0];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between quadvector and rotation  
// a0 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const quadvector_t& a, const rotation_t& b) {
    even_t res;
    res.d[0] = b.d[0];
    res.d[1] = b.d[1];
    res.d[2] = b.d[2];
    res.d[3] = b.d[3];
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = a.d[0];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between quadvector and translation  
// a0 e₀₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const quadvector_t& a, const translation_t& b) {
    even_t res;
    res.d[0] = 1.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = b.d[0];
    res.d[5] = b.d[1];
    res.d[6] = b.d[2];
    res.d[7] = a.d[0];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between quadvector and even  
// a0 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const quadvector_t& a, const even_t& b) {
    even_t res;
    res.d[0] = b.d[0];
    res.d[1] = b.d[1];
    res.d[2] = b.d[2];
    res.d[3] = b.d[3];
    res.d[4] = b.d[4];
    res.d[5] = b.d[5];
    res.d[6] = b.d[6];
    res.d[7] = a.d[0] + b.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between horizon and vector  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator+(const horizon_t& a, const vector_t& b) {
    vector_t res;
    res.d[0] = b.d[0];
    res.d[1] = b.d[1];
    res.d[2] = b.d[2];
    res.d[3] = 1 + b.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between horizon and trivector  
// 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const horizon_t& a, const trivector_t& b) {
    odd_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 1.0;
    res.d[4] = b.d[0];
    res.d[5] = b.d[1];
    res.d[6] = b.d[2];
    res.d[7] = b.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between horizon and horizon  
// 1 e₀
// 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator+(const horizon_t& a, const horizon_t& b) {
    vector_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 2.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between horizon and origin  
// 1 e₀
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const horizon_t& a, const origin_t& b) {
    odd_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 1.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between horizon and point  
// 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const horizon_t& a, const point_t& b) {
    odd_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 1.0;
    res.d[4] = b.d[0];
    res.d[5] = b.d[1];
    res.d[6] = b.d[2];
    res.d[7] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between horizon and direction  
// 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const horizon_t& a, const direction_t& b) {
    odd_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 1.0;
    res.d[4] = b.d[0];
    res.d[5] = b.d[1];
    res.d[6] = b.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between horizon and evector  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + 1 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline dpoint_t operator+(const horizon_t& a, const evector_t& b) {
    dpoint_t res;
    res.d[0] = b.d[0];
    res.d[1] = b.d[1];
    res.d[2] = b.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between horizon and dpoint  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator+(const horizon_t& a, const dpoint_t& b) {
    vector_t res;
    res.d[0] = b.d[0];
    res.d[1] = b.d[1];
    res.d[2] = b.d[2];
    res.d[3] = 2.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between horizon and odd  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const horizon_t& a, const odd_t& b) {
    odd_t res;
    res.d[0] = b.d[0];
    res.d[1] = b.d[1];
    res.d[2] = b.d[2];
    res.d[3] = 1 + b.d[3];
    res.d[4] = b.d[4];
    res.d[5] = b.d[5];
    res.d[6] = b.d[6];
    res.d[7] = b.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between origin and vector  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const origin_t& a, const vector_t& b) {
    odd_t res;
    res.d[0] = b.d[0];
    res.d[1] = b.d[1];
    res.d[2] = b.d[2];
    res.d[3] = b.d[3];
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between origin and trivector  
// 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator+(const origin_t& a, const trivector_t& b) {
    trivector_t res;
    res.d[0] = b.d[0];
    res.d[1] = b.d[1];
    res.d[2] = b.d[2];
    res.d[3] = 1 + b.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between origin and horizon  
// 1 e₁₂₃
// 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const origin_t& a, const horizon_t& b) {
    odd_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 1.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between origin and origin  
// 1 e₁₂₃
// 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator+(const origin_t& a, const origin_t& b) {
    trivector_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 2.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between origin and point  
// 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator+(const origin_t& a, const point_t& b) {
    trivector_t res;
    res.d[0] = b.d[0];
    res.d[1] = b.d[1];
    res.d[2] = b.d[2];
    res.d[3] = 2.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between origin and direction  
// 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t operator+(const origin_t& a, const direction_t& b) {
    point_t res;
    res.d[0] = b.d[0];
    res.d[1] = b.d[1];
    res.d[2] = b.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between origin and evector  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const origin_t& a, const evector_t& b) {
    odd_t res;
    res.d[0] = b.d[0];
    res.d[1] = b.d[1];
    res.d[2] = b.d[2];
    res.d[3] = 0.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between origin and dpoint  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const origin_t& a, const dpoint_t& b) {
    odd_t res;
    res.d[0] = b.d[0];
    res.d[1] = b.d[1];
    res.d[2] = b.d[2];
    res.d[3] = 1.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between origin and odd  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const origin_t& a, const odd_t& b) {
    odd_t res;
    res.d[0] = b.d[0];
    res.d[1] = b.d[1];
    res.d[2] = b.d[2];
    res.d[3] = b.d[3];
    res.d[4] = b.d[4];
    res.d[5] = b.d[5];
    res.d[6] = b.d[6];
    res.d[7] = 1 + b.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between point and vector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const point_t& a, const vector_t& b) {
    odd_t res;
    res.d[0] = b.d[0];
    res.d[1] = b.d[1];
    res.d[2] = b.d[2];
    res.d[3] = b.d[3];
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between point and trivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator+(const point_t& a, const trivector_t& b) {
    trivector_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    res.d[3] = 1 + b.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between point and horizon  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const point_t& a, const horizon_t& b) {
    odd_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 1.0;
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between point and origin  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator+(const point_t& a, const origin_t& b) {
    trivector_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = 2.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between point and point  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator+(const point_t& a, const point_t& b) {
    trivector_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    res.d[3] = 2.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between point and direction  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t operator+(const point_t& a, const direction_t& b) {
    point_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between point and evector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const point_t& a, const evector_t& b) {
    odd_t res;
    res.d[0] = b.d[0];
    res.d[1] = b.d[1];
    res.d[2] = b.d[2];
    res.d[3] = 0.0;
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between point and dpoint  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const point_t& a, const dpoint_t& b) {
    odd_t res;
    res.d[0] = b.d[0];
    res.d[1] = b.d[1];
    res.d[2] = b.d[2];
    res.d[3] = 1.0;
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between point and odd  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const point_t& a, const odd_t& b) {
    odd_t res;
    res.d[0] = b.d[0];
    res.d[1] = b.d[1];
    res.d[2] = b.d[2];
    res.d[3] = b.d[3];
    res.d[4] = a.d[0] + b.d[4];
    res.d[5] = a.d[1] + b.d[5];
    res.d[6] = a.d[2] + b.d[6];
    res.d[7] = 1 + b.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between direction and vector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const direction_t& a, const vector_t& b) {
    odd_t res;
    res.d[0] = b.d[0];
    res.d[1] = b.d[1];
    res.d[2] = b.d[2];
    res.d[3] = b.d[3];
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between direction and trivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator+(const direction_t& a, const trivector_t& b) {
    trivector_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    res.d[3] = b.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between direction and horizon  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const direction_t& a, const horizon_t& b) {
    odd_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 1.0;
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between direction and origin  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t operator+(const direction_t& a, const origin_t& b) {
    point_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between direction and point  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t operator+(const direction_t& a, const point_t& b) {
    point_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between direction and direction  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator+(const direction_t& a, const direction_t& b) {
    direction_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between direction and evector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const direction_t& a, const evector_t& b) {
    odd_t res;
    res.d[0] = b.d[0];
    res.d[1] = b.d[1];
    res.d[2] = b.d[2];
    res.d[3] = 0.0;
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between direction and dpoint  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const direction_t& a, const dpoint_t& b) {
    odd_t res;
    res.d[0] = b.d[0];
    res.d[1] = b.d[1];
    res.d[2] = b.d[2];
    res.d[3] = 1.0;
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between direction and odd  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const direction_t& a, const odd_t& b) {
    odd_t res;
    res.d[0] = b.d[0];
    res.d[1] = b.d[1];
    res.d[2] = b.d[2];
    res.d[3] = b.d[3];
    res.d[4] = a.d[0] + b.d[4];
    res.d[5] = a.d[1] + b.d[5];
    res.d[6] = a.d[2] + b.d[6];
    res.d[7] = b.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between ebivector and scalar  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator+(const ebivector_t& a, const scalar_t& b) {
    rotation_t res;
    res.d[0] = b;
    res.d[1] = a.d[0];
    res.d[2] = a.d[1];
    res.d[3] = a.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between ebivector and bivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator+(const ebivector_t& a, const bivector_t& b) {
    bivector_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    res.d[3] = b.d[3];
    res.d[4] = b.d[4];
    res.d[5] = b.d[5];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between ebivector and quadvector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const ebivector_t& a, const quadvector_t& b) {
    even_t res;
    res.d[0] = 0.0;
    res.d[1] = a.d[0];
    res.d[2] = a.d[1];
    res.d[3] = a.d[2];
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = b.d[0];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between ebivector and ebivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator+(const ebivector_t& a, const ebivector_t& b) {
    ebivector_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between ebivector and ibivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator+(const ebivector_t& a, const ibivector_t& b) {
    bivector_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = b.d[0];
    res.d[4] = b.d[1];
    res.d[5] = b.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between ebivector and rotation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator+(const ebivector_t& a, const rotation_t& b) {
    rotation_t res;
    res.d[0] = b.d[0];
    res.d[1] = a.d[0] + b.d[1];
    res.d[2] = a.d[1] + b.d[2];
    res.d[3] = a.d[2] + b.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between ebivector and translation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const ebivector_t& a, const translation_t& b) {
    even_t res;
    res.d[0] = 1.0;
    res.d[1] = a.d[0];
    res.d[2] = a.d[1];
    res.d[3] = a.d[2];
    res.d[4] = b.d[0];
    res.d[5] = b.d[1];
    res.d[6] = b.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between ebivector and even  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const ebivector_t& a, const even_t& b) {
    even_t res;
    res.d[0] = b.d[0];
    res.d[1] = a.d[0] + b.d[1];
    res.d[2] = a.d[1] + b.d[2];
    res.d[3] = a.d[2] + b.d[3];
    res.d[4] = b.d[4];
    res.d[5] = b.d[5];
    res.d[6] = b.d[6];
    res.d[7] = b.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between ibivector and scalar  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const ibivector_t& a, const scalar_t& b) {
    even_t res;
    res.d[0] = b;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between ibivector and bivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator+(const ibivector_t& a, const bivector_t& b) {
    bivector_t res;
    res.d[0] = b.d[0];
    res.d[1] = b.d[1];
    res.d[2] = b.d[2];
    res.d[3] = a.d[0] + b.d[3];
    res.d[4] = a.d[1] + b.d[4];
    res.d[5] = a.d[2] + b.d[5];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between ibivector and quadvector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const ibivector_t& a, const quadvector_t& b) {
    even_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = b.d[0];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between ibivector and ebivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator+(const ibivector_t& a, const ebivector_t& b) {
    bivector_t res;
    res.d[0] = b.d[0];
    res.d[1] = b.d[1];
    res.d[2] = b.d[2];
    res.d[3] = a.d[0];
    res.d[4] = a.d[1];
    res.d[5] = a.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between ibivector and ibivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator+(const ibivector_t& a, const ibivector_t& b) {
    ibivector_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between ibivector and rotation  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const ibivector_t& a, const rotation_t& b) {
    even_t res;
    res.d[0] = b.d[0];
    res.d[1] = b.d[1];
    res.d[2] = b.d[2];
    res.d[3] = b.d[3];
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between ibivector and translation  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline translation_t operator+(const ibivector_t& a, const translation_t& b) {
    translation_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between ibivector and even  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const ibivector_t& a, const even_t& b) {
    even_t res;
    res.d[0] = b.d[0];
    res.d[1] = b.d[1];
    res.d[2] = b.d[2];
    res.d[3] = b.d[3];
    res.d[4] = a.d[0] + b.d[4];
    res.d[5] = a.d[1] + b.d[5];
    res.d[6] = a.d[2] + b.d[6];
    res.d[7] = b.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between evector and vector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator+(const evector_t& a, const vector_t& b) {
    vector_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    res.d[3] = b.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between evector and trivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const evector_t& a, const trivector_t& b) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = 0.0;
    res.d[4] = b.d[0];
    res.d[5] = b.d[1];
    res.d[6] = b.d[2];
    res.d[7] = b.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between evector and horizon  
// a0 e₁ + a1 e₂ + a2 e₃
// 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + 1 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline dpoint_t operator+(const evector_t& a, const horizon_t& b) {
    dpoint_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between evector and origin  
// a0 e₁ + a1 e₂ + a2 e₃
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const evector_t& a, const origin_t& b) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = 0.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between evector and point  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const evector_t& a, const point_t& b) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = 0.0;
    res.d[4] = b.d[0];
    res.d[5] = b.d[1];
    res.d[6] = b.d[2];
    res.d[7] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between evector and direction  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const evector_t& a, const direction_t& b) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = 0.0;
    res.d[4] = b.d[0];
    res.d[5] = b.d[1];
    res.d[6] = b.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between evector and evector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator+(const evector_t& a, const evector_t& b) {
    evector_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between evector and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + 1 e₀
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline dpoint_t operator+(const evector_t& a, const dpoint_t& b) {
    dpoint_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between evector and odd  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const evector_t& a, const odd_t& b) {
    odd_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    res.d[3] = b.d[3];
    res.d[4] = b.d[4];
    res.d[5] = b.d[5];
    res.d[6] = b.d[6];
    res.d[7] = b.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between dpoint and vector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator+(const dpoint_t& a, const vector_t& b) {
    vector_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    res.d[3] = 1 + b.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between dpoint and trivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const dpoint_t& a, const trivector_t& b) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = 1.0;
    res.d[4] = b.d[0];
    res.d[5] = b.d[1];
    res.d[6] = b.d[2];
    res.d[7] = b.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between dpoint and horizon  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator+(const dpoint_t& a, const horizon_t& b) {
    vector_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = 2.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between dpoint and origin  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const dpoint_t& a, const origin_t& b) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = 1.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between dpoint and point  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const dpoint_t& a, const point_t& b) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = 1.0;
    res.d[4] = b.d[0];
    res.d[5] = b.d[1];
    res.d[6] = b.d[2];
    res.d[7] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between dpoint and direction  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const dpoint_t& a, const direction_t& b) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = 1.0;
    res.d[4] = b.d[0];
    res.d[5] = b.d[1];
    res.d[6] = b.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between dpoint and evector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + 1 e₀
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline dpoint_t operator+(const dpoint_t& a, const evector_t& b) {
    dpoint_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between dpoint and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator+(const dpoint_t& a, const dpoint_t& b) {
    vector_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    res.d[3] = 2.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between dpoint and odd  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const dpoint_t& a, const odd_t& b) {
    odd_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    res.d[3] = 1 + b.d[3];
    res.d[4] = b.d[4];
    res.d[5] = b.d[5];
    res.d[6] = b.d[6];
    res.d[7] = b.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between rotation and scalar  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator+(const rotation_t& a, const scalar_t& b) {
    rotation_t res;
    res.d[0] = a.d[0] + b;
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between rotation and bivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const rotation_t& a, const bivector_t& b) {
    even_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1] + b.d[0];
    res.d[2] = a.d[2] + b.d[1];
    res.d[3] = a.d[3] + b.d[2];
    res.d[4] = b.d[3];
    res.d[5] = b.d[4];
    res.d[6] = b.d[5];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between rotation and quadvector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const rotation_t& a, const quadvector_t& b) {
    even_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = b.d[0];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between rotation and ebivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator+(const rotation_t& a, const ebivector_t& b) {
    rotation_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1] + b.d[0];
    res.d[2] = a.d[2] + b.d[1];
    res.d[3] = a.d[3] + b.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between rotation and ibivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const rotation_t& a, const ibivector_t& b) {
    even_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    res.d[4] = b.d[0];
    res.d[5] = b.d[1];
    res.d[6] = b.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between rotation and rotation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator+(const rotation_t& a, const rotation_t& b) {
    rotation_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    res.d[3] = a.d[3] + b.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between rotation and translation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const rotation_t& a, const translation_t& b) {
    even_t res;
    res.d[0] = 1 + a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    res.d[4] = b.d[0];
    res.d[5] = b.d[1];
    res.d[6] = b.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between rotation and even  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const rotation_t& a, const even_t& b) {
    even_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    res.d[3] = a.d[3] + b.d[3];
    res.d[4] = b.d[4];
    res.d[5] = b.d[5];
    res.d[6] = b.d[6];
    res.d[7] = b.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between translation and scalar  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const translation_t& a, const scalar_t& b) {
    even_t res;
    res.d[0] = 1 + b;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between translation and bivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const translation_t& a, const bivector_t& b) {
    even_t res;
    res.d[0] = 1.0;
    res.d[1] = b.d[0];
    res.d[2] = b.d[1];
    res.d[3] = b.d[2];
    res.d[4] = a.d[0] + b.d[3];
    res.d[5] = a.d[1] + b.d[4];
    res.d[6] = a.d[2] + b.d[5];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between translation and quadvector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const translation_t& a, const quadvector_t& b) {
    even_t res;
    res.d[0] = 1.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = b.d[0];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between translation and ebivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const translation_t& a, const ebivector_t& b) {
    even_t res;
    res.d[0] = 1.0;
    res.d[1] = b.d[0];
    res.d[2] = b.d[1];
    res.d[3] = b.d[2];
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between translation and ibivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline translation_t operator+(const translation_t& a, const ibivector_t& b) {
    translation_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between translation and rotation  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const translation_t& a, const rotation_t& b) {
    even_t res;
    res.d[0] = 1 + b.d[0];
    res.d[1] = b.d[1];
    res.d[2] = b.d[2];
    res.d[3] = b.d[3];
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between translation and translation  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const translation_t& a, const translation_t& b) {
    even_t res;
    res.d[0] = 2.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a.d[0] + b.d[0];
    res.d[5] = a.d[1] + b.d[1];
    res.d[6] = a.d[2] + b.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between translation and even  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const translation_t& a, const even_t& b) {
    even_t res;
    res.d[0] = 1 + b.d[0];
    res.d[1] = b.d[1];
    res.d[2] = b.d[2];
    res.d[3] = b.d[3];
    res.d[4] = a.d[0] + b.d[4];
    res.d[5] = a.d[1] + b.d[5];
    res.d[6] = a.d[2] + b.d[6];
    res.d[7] = b.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between even and scalar  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const even_t& a, const scalar_t& b) {
    even_t res;
    res.d[0] = a.d[0] + b;
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    res.d[4] = a.d[4];
    res.d[5] = a.d[5];
    res.d[6] = a.d[6];
    res.d[7] = a.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between even and bivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const even_t& a, const bivector_t& b) {
    even_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1] + b.d[0];
    res.d[2] = a.d[2] + b.d[1];
    res.d[3] = a.d[3] + b.d[2];
    res.d[4] = a.d[4] + b.d[3];
    res.d[5] = a.d[5] + b.d[4];
    res.d[6] = a.d[6] + b.d[5];
    res.d[7] = a.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between even and quadvector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const even_t& a, const quadvector_t& b) {
    even_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    res.d[4] = a.d[4];
    res.d[5] = a.d[5];
    res.d[6] = a.d[6];
    res.d[7] = a.d[7] + b.d[0];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between even and ebivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const even_t& a, const ebivector_t& b) {
    even_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1] + b.d[0];
    res.d[2] = a.d[2] + b.d[1];
    res.d[3] = a.d[3] + b.d[2];
    res.d[4] = a.d[4];
    res.d[5] = a.d[5];
    res.d[6] = a.d[6];
    res.d[7] = a.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between even and ibivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const even_t& a, const ibivector_t& b) {
    even_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    res.d[4] = a.d[4] + b.d[0];
    res.d[5] = a.d[5] + b.d[1];
    res.d[6] = a.d[6] + b.d[2];
    res.d[7] = a.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between even and rotation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const even_t& a, const rotation_t& b) {
    even_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    res.d[3] = a.d[3] + b.d[3];
    res.d[4] = a.d[4];
    res.d[5] = a.d[5];
    res.d[6] = a.d[6];
    res.d[7] = a.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between even and translation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const even_t& a, const translation_t& b) {
    even_t res;
    res.d[0] = 1 + a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    res.d[4] = a.d[4] + b.d[0];
    res.d[5] = a.d[5] + b.d[1];
    res.d[6] = a.d[6] + b.d[2];
    res.d[7] = a.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between even and even  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator+(const even_t& a, const even_t& b) {
    even_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    res.d[3] = a.d[3] + b.d[3];
    res.d[4] = a.d[4] + b.d[4];
    res.d[5] = a.d[5] + b.d[5];
    res.d[6] = a.d[6] + b.d[6];
    res.d[7] = a.d[7] + b.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between odd and vector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const odd_t& a, const vector_t& b) {
    odd_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    res.d[3] = a.d[3] + b.d[3];
    res.d[4] = a.d[4];
    res.d[5] = a.d[5];
    res.d[6] = a.d[6];
    res.d[7] = a.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between odd and trivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const odd_t& a, const trivector_t& b) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    res.d[4] = a.d[4] + b.d[0];
    res.d[5] = a.d[5] + b.d[1];
    res.d[6] = a.d[6] + b.d[2];
    res.d[7] = a.d[7] + b.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between odd and horizon  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const odd_t& a, const horizon_t& b) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = 1 + a.d[3];
    res.d[4] = a.d[4];
    res.d[5] = a.d[5];
    res.d[6] = a.d[6];
    res.d[7] = a.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between odd and origin  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const odd_t& a, const origin_t& b) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    res.d[4] = a.d[4];
    res.d[5] = a.d[5];
    res.d[6] = a.d[6];
    res.d[7] = 1 + a.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between odd and point  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const odd_t& a, const point_t& b) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    res.d[4] = a.d[4] + b.d[0];
    res.d[5] = a.d[5] + b.d[1];
    res.d[6] = a.d[6] + b.d[2];
    res.d[7] = 1 + a.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between odd and direction  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const odd_t& a, const direction_t& b) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    res.d[4] = a.d[4] + b.d[0];
    res.d[5] = a.d[5] + b.d[1];
    res.d[6] = a.d[6] + b.d[2];
    res.d[7] = a.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between odd and evector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const odd_t& a, const evector_t& b) {
    odd_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    res.d[3] = a.d[3];
    res.d[4] = a.d[4];
    res.d[5] = a.d[5];
    res.d[6] = a.d[6];
    res.d[7] = a.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between odd and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const odd_t& a, const dpoint_t& b) {
    odd_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    res.d[3] = 1 + a.d[3];
    res.d[4] = a.d[4];
    res.d[5] = a.d[5];
    res.d[6] = a.d[6];
    res.d[7] = a.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// add between odd and odd  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator+(const odd_t& a, const odd_t& b) {
    odd_t res;
    res.d[0] = a.d[0] + b.d[0];
    res.d[1] = a.d[1] + b.d[1];
    res.d[2] = a.d[2] + b.d[2];
    res.d[3] = a.d[3] + b.d[3];
    res.d[4] = a.d[4] + b.d[4];
    res.d[5] = a.d[5] + b.d[5];
    res.d[6] = a.d[6] + b.d[6];
    res.d[7] = a.d[7] + b.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between scalar and bivector  
// a
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const scalar_t& a, const bivector_t& b) {
    even_t res;
    res.d[0] = a;
    res.d[1] = -b.d[0];
    res.d[2] = -b.d[1];
    res.d[3] = -b.d[2];
    res.d[4] = -b.d[3];
    res.d[5] = -b.d[4];
    res.d[6] = -b.d[5];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between scalar and quadvector  
// a
// b0 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const scalar_t& a, const quadvector_t& b) {
    even_t res;
    res.d[0] = a;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = -b.d[0];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between scalar and ebivector  
// a
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator-(const scalar_t& a, const ebivector_t& b) {
    rotation_t res;
    res.d[0] = a;
    res.d[1] = -b.d[0];
    res.d[2] = -b.d[1];
    res.d[3] = -b.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between scalar and ibivector  
// a
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const scalar_t& a, const ibivector_t& b) {
    even_t res;
    res.d[0] = a;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = -b.d[0];
    res.d[5] = -b.d[1];
    res.d[6] = -b.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between scalar and rotation  
// a
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator-(const scalar_t& a, const rotation_t& b) {
    rotation_t res;
    res.d[0] = a - b.d[0];
    res.d[1] = -b.d[1];
    res.d[2] = -b.d[2];
    res.d[3] = -b.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between scalar and translation  
// a
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const scalar_t& a, const translation_t& b) {
    even_t res;
    res.d[0] = -1 + a;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = -b.d[0];
    res.d[5] = -b.d[1];
    res.d[6] = -b.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between scalar and even  
// a
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const scalar_t& a, const even_t& b) {
    even_t res;
    res.d[0] = a - b.d[0];
    res.d[1] = -b.d[1];
    res.d[2] = -b.d[2];
    res.d[3] = -b.d[3];
    res.d[4] = -b.d[4];
    res.d[5] = -b.d[5];
    res.d[6] = -b.d[6];
    res.d[7] = -b.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between vector and vector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator-(const vector_t& a, const vector_t& b) {
    vector_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    res.d[3] = a.d[3] - b.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between vector and trivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const vector_t& a, const trivector_t& b) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    res.d[4] = -b.d[0];
    res.d[5] = -b.d[1];
    res.d[6] = -b.d[2];
    res.d[7] = -b.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between vector and horizon  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator-(const vector_t& a, const horizon_t& b) {
    vector_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = -1 + a.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between vector and origin  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const vector_t& a, const origin_t& b) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between vector and point  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const vector_t& a, const point_t& b) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    res.d[4] = -b.d[0];
    res.d[5] = -b.d[1];
    res.d[6] = -b.d[2];
    res.d[7] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between vector and direction  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const vector_t& a, const direction_t& b) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    res.d[4] = -b.d[0];
    res.d[5] = -b.d[1];
    res.d[6] = -b.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between vector and evector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator-(const vector_t& a, const evector_t& b) {
    vector_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    res.d[3] = a.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between vector and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator-(const vector_t& a, const dpoint_t& b) {
    vector_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    res.d[3] = -1 + a.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between vector and odd  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const vector_t& a, const odd_t& b) {
    odd_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    res.d[3] = a.d[3] - b.d[3];
    res.d[4] = -b.d[4];
    res.d[5] = -b.d[5];
    res.d[6] = -b.d[6];
    res.d[7] = -b.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between bivector and scalar  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const bivector_t& a, const scalar_t& b) {
    even_t res;
    res.d[0] = -b;
    res.d[1] = a.d[0];
    res.d[2] = a.d[1];
    res.d[3] = a.d[2];
    res.d[4] = a.d[3];
    res.d[5] = a.d[4];
    res.d[6] = a.d[5];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between bivector and bivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 0 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator-(const bivector_t& a, const bivector_t& b) {
    bivector_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    res.d[3] = a.d[3] - b.d[3];
    res.d[4] = a.d[4] - b.d[4];
    res.d[5] = a.d[5] - b.d[5];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between bivector and quadvector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const bivector_t& a, const quadvector_t& b) {
    even_t res;
    res.d[0] = 0.0;
    res.d[1] = a.d[0];
    res.d[2] = a.d[1];
    res.d[3] = a.d[2];
    res.d[4] = a.d[3];
    res.d[5] = a.d[4];
    res.d[6] = a.d[5];
    res.d[7] = -b.d[0];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between bivector and ebivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator-(const bivector_t& a, const ebivector_t& b) {
    bivector_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    res.d[3] = a.d[3];
    res.d[4] = a.d[4];
    res.d[5] = a.d[5];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between bivector and ibivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator-(const bivector_t& a, const ibivector_t& b) {
    bivector_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3] - b.d[0];
    res.d[4] = a.d[4] - b.d[1];
    res.d[5] = a.d[5] - b.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between bivector and rotation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const bivector_t& a, const rotation_t& b) {
    even_t res;
    res.d[0] = -b.d[0];
    res.d[1] = a.d[0] - b.d[1];
    res.d[2] = a.d[1] - b.d[2];
    res.d[3] = a.d[2] - b.d[3];
    res.d[4] = a.d[3];
    res.d[5] = a.d[4];
    res.d[6] = a.d[5];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between bivector and translation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const bivector_t& a, const translation_t& b) {
    even_t res;
    res.d[0] = -1;
    res.d[1] = a.d[0];
    res.d[2] = a.d[1];
    res.d[3] = a.d[2];
    res.d[4] = a.d[3] - b.d[0];
    res.d[5] = a.d[4] - b.d[1];
    res.d[6] = a.d[5] - b.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between bivector and even  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const bivector_t& a, const even_t& b) {
    even_t res;
    res.d[0] = -b.d[0];
    res.d[1] = a.d[0] - b.d[1];
    res.d[2] = a.d[1] - b.d[2];
    res.d[3] = a.d[2] - b.d[3];
    res.d[4] = a.d[3] - b.d[4];
    res.d[5] = a.d[4] - b.d[5];
    res.d[6] = a.d[5] - b.d[6];
    res.d[7] = -b.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between trivector and vector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const trivector_t& a, const vector_t& b) {
    odd_t res;
    res.d[0] = -b.d[0];
    res.d[1] = -b.d[1];
    res.d[2] = -b.d[2];
    res.d[3] = -b.d[3];
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = a.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between trivector and trivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator-(const trivector_t& a, const trivector_t& b) {
    trivector_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    res.d[3] = a.d[3] - b.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between trivector and horizon  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const trivector_t& a, const horizon_t& b) {
    odd_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -1;
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = a.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between trivector and origin  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator-(const trivector_t& a, const origin_t& b) {
    trivector_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = -1 + a.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between trivector and point  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator-(const trivector_t& a, const point_t& b) {
    trivector_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    res.d[3] = -1 + a.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between trivector and direction  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator-(const trivector_t& a, const direction_t& b) {
    trivector_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    res.d[3] = a.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between trivector and evector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const trivector_t& a, const evector_t& b) {
    odd_t res;
    res.d[0] = -b.d[0];
    res.d[1] = -b.d[1];
    res.d[2] = -b.d[2];
    res.d[3] = 0.0;
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = a.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between trivector and dpoint  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const trivector_t& a, const dpoint_t& b) {
    odd_t res;
    res.d[0] = -b.d[0];
    res.d[1] = -b.d[1];
    res.d[2] = -b.d[2];
    res.d[3] = -1;
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = a.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between trivector and odd  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const trivector_t& a, const odd_t& b) {
    odd_t res;
    res.d[0] = -b.d[0];
    res.d[1] = -b.d[1];
    res.d[2] = -b.d[2];
    res.d[3] = -b.d[3];
    res.d[4] = a.d[0] - b.d[4];
    res.d[5] = a.d[1] - b.d[5];
    res.d[6] = a.d[2] - b.d[6];
    res.d[7] = a.d[3] - b.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between quadvector and scalar  
// a0 e₀₁₂₃
// b
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const quadvector_t& a, const scalar_t& b) {
    even_t res;
    res.d[0] = -b;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = a.d[0];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between quadvector and bivector  
// a0 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const quadvector_t& a, const bivector_t& b) {
    even_t res;
    res.d[0] = 0.0;
    res.d[1] = -b.d[0];
    res.d[2] = -b.d[1];
    res.d[3] = -b.d[2];
    res.d[4] = -b.d[3];
    res.d[5] = -b.d[4];
    res.d[6] = -b.d[5];
    res.d[7] = a.d[0];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between quadvector and quadvector  
// a0 e₀₁₂₃
// b0 e₀₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator-(const quadvector_t& a, const quadvector_t& b) {
    quadvector_t res;
    res.d[0] = a.d[0] - b.d[0];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between quadvector and ebivector  
// a0 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const quadvector_t& a, const ebivector_t& b) {
    even_t res;
    res.d[0] = 0.0;
    res.d[1] = -b.d[0];
    res.d[2] = -b.d[1];
    res.d[3] = -b.d[2];
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = a.d[0];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between quadvector and ibivector  
// a0 e₀₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const quadvector_t& a, const ibivector_t& b) {
    even_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = -b.d[0];
    res.d[5] = -b.d[1];
    res.d[6] = -b.d[2];
    res.d[7] = a.d[0];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between quadvector and rotation  
// a0 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const quadvector_t& a, const rotation_t& b) {
    even_t res;
    res.d[0] = -b.d[0];
    res.d[1] = -b.d[1];
    res.d[2] = -b.d[2];
    res.d[3] = -b.d[3];
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = a.d[0];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between quadvector and translation  
// a0 e₀₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const quadvector_t& a, const translation_t& b) {
    even_t res;
    res.d[0] = -1;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = -b.d[0];
    res.d[5] = -b.d[1];
    res.d[6] = -b.d[2];
    res.d[7] = a.d[0];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between quadvector and even  
// a0 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const quadvector_t& a, const even_t& b) {
    even_t res;
    res.d[0] = -b.d[0];
    res.d[1] = -b.d[1];
    res.d[2] = -b.d[2];
    res.d[3] = -b.d[3];
    res.d[4] = -b.d[4];
    res.d[5] = -b.d[5];
    res.d[6] = -b.d[6];
    res.d[7] = a.d[0] - b.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between horizon and vector  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator-(const horizon_t& a, const vector_t& b) {
    vector_t res;
    res.d[0] = -b.d[0];
    res.d[1] = -b.d[1];
    res.d[2] = -b.d[2];
    res.d[3] = 1 - b.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between horizon and trivector  
// 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const horizon_t& a, const trivector_t& b) {
    odd_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 1.0;
    res.d[4] = -b.d[0];
    res.d[5] = -b.d[1];
    res.d[6] = -b.d[2];
    res.d[7] = -b.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between horizon and horizon  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator-(const horizon_t& a, const horizon_t& b) {

    return 0.0f;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between horizon and origin  
// 1 e₀
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const horizon_t& a, const origin_t& b) {
    odd_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 1.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between horizon and point  
// 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const horizon_t& a, const point_t& b) {
    odd_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 1.0;
    res.d[4] = -b.d[0];
    res.d[5] = -b.d[1];
    res.d[6] = -b.d[2];
    res.d[7] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between horizon and direction  
// 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const horizon_t& a, const direction_t& b) {
    odd_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 1.0;
    res.d[4] = -b.d[0];
    res.d[5] = -b.d[1];
    res.d[6] = -b.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between horizon and evector  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + 1 e₀
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline dpoint_t operator-(const horizon_t& a, const evector_t& b) {
    dpoint_t res;
    res.d[0] = -b.d[0];
    res.d[1] = -b.d[1];
    res.d[2] = -b.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between horizon and dpoint  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator-(const horizon_t& a, const dpoint_t& b) {
    evector_t res;
    res.d[0] = -b.d[0];
    res.d[1] = -b.d[1];
    res.d[2] = -b.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between horizon and odd  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const horizon_t& a, const odd_t& b) {
    odd_t res;
    res.d[0] = -b.d[0];
    res.d[1] = -b.d[1];
    res.d[2] = -b.d[2];
    res.d[3] = 1 - b.d[3];
    res.d[4] = -b.d[4];
    res.d[5] = -b.d[5];
    res.d[6] = -b.d[6];
    res.d[7] = -b.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between origin and vector  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const origin_t& a, const vector_t& b) {
    odd_t res;
    res.d[0] = -b.d[0];
    res.d[1] = -b.d[1];
    res.d[2] = -b.d[2];
    res.d[3] = -b.d[3];
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between origin and trivector  
// 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator-(const origin_t& a, const trivector_t& b) {
    trivector_t res;
    res.d[0] = -b.d[0];
    res.d[1] = -b.d[1];
    res.d[2] = -b.d[2];
    res.d[3] = 1 - b.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between origin and horizon  
// 1 e₁₂₃
// 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const origin_t& a, const horizon_t& b) {
    odd_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -1;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between origin and origin  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator-(const origin_t& a, const origin_t& b) {

    return 0.0f;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between origin and point  
// 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator-(const origin_t& a, const point_t& b) {
    direction_t res;
    res.d[0] = -b.d[0];
    res.d[1] = -b.d[1];
    res.d[2] = -b.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between origin and direction  
// 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t operator-(const origin_t& a, const direction_t& b) {
    point_t res;
    res.d[0] = -b.d[0];
    res.d[1] = -b.d[1];
    res.d[2] = -b.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between origin and evector  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const origin_t& a, const evector_t& b) {
    odd_t res;
    res.d[0] = -b.d[0];
    res.d[1] = -b.d[1];
    res.d[2] = -b.d[2];
    res.d[3] = 0.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between origin and dpoint  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const origin_t& a, const dpoint_t& b) {
    odd_t res;
    res.d[0] = -b.d[0];
    res.d[1] = -b.d[1];
    res.d[2] = -b.d[2];
    res.d[3] = -1;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between origin and odd  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const origin_t& a, const odd_t& b) {
    odd_t res;
    res.d[0] = -b.d[0];
    res.d[1] = -b.d[1];
    res.d[2] = -b.d[2];
    res.d[3] = -b.d[3];
    res.d[4] = -b.d[4];
    res.d[5] = -b.d[5];
    res.d[6] = -b.d[6];
    res.d[7] = 1 - b.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between point and vector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const point_t& a, const vector_t& b) {
    odd_t res;
    res.d[0] = -b.d[0];
    res.d[1] = -b.d[1];
    res.d[2] = -b.d[2];
    res.d[3] = -b.d[3];
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between point and trivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator-(const point_t& a, const trivector_t& b) {
    trivector_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    res.d[3] = 1 - b.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between point and horizon  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const point_t& a, const horizon_t& b) {
    odd_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -1;
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between point and origin  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator-(const point_t& a, const origin_t& b) {
    direction_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between point and point  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator-(const point_t& a, const point_t& b) {
    direction_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between point and direction  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t operator-(const point_t& a, const direction_t& b) {
    point_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between point and evector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const point_t& a, const evector_t& b) {
    odd_t res;
    res.d[0] = -b.d[0];
    res.d[1] = -b.d[1];
    res.d[2] = -b.d[2];
    res.d[3] = 0.0;
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between point and dpoint  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const point_t& a, const dpoint_t& b) {
    odd_t res;
    res.d[0] = -b.d[0];
    res.d[1] = -b.d[1];
    res.d[2] = -b.d[2];
    res.d[3] = -1;
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between point and odd  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const point_t& a, const odd_t& b) {
    odd_t res;
    res.d[0] = -b.d[0];
    res.d[1] = -b.d[1];
    res.d[2] = -b.d[2];
    res.d[3] = -b.d[3];
    res.d[4] = a.d[0] - b.d[4];
    res.d[5] = a.d[1] - b.d[5];
    res.d[6] = a.d[2] - b.d[6];
    res.d[7] = 1 - b.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between direction and vector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const direction_t& a, const vector_t& b) {
    odd_t res;
    res.d[0] = -b.d[0];
    res.d[1] = -b.d[1];
    res.d[2] = -b.d[2];
    res.d[3] = -b.d[3];
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between direction and trivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator-(const direction_t& a, const trivector_t& b) {
    trivector_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    res.d[3] = -b.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between direction and horizon  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const direction_t& a, const horizon_t& b) {
    odd_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -1;
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between direction and origin  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator-(const direction_t& a, const origin_t& b) {
    trivector_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between direction and point  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator-(const direction_t& a, const point_t& b) {
    trivector_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    res.d[3] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between direction and direction  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator-(const direction_t& a, const direction_t& b) {
    direction_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between direction and evector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const direction_t& a, const evector_t& b) {
    odd_t res;
    res.d[0] = -b.d[0];
    res.d[1] = -b.d[1];
    res.d[2] = -b.d[2];
    res.d[3] = 0.0;
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between direction and dpoint  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const direction_t& a, const dpoint_t& b) {
    odd_t res;
    res.d[0] = -b.d[0];
    res.d[1] = -b.d[1];
    res.d[2] = -b.d[2];
    res.d[3] = -1;
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between direction and odd  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const direction_t& a, const odd_t& b) {
    odd_t res;
    res.d[0] = -b.d[0];
    res.d[1] = -b.d[1];
    res.d[2] = -b.d[2];
    res.d[3] = -b.d[3];
    res.d[4] = a.d[0] - b.d[4];
    res.d[5] = a.d[1] - b.d[5];
    res.d[6] = a.d[2] - b.d[6];
    res.d[7] = -b.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between ebivector and scalar  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator-(const ebivector_t& a, const scalar_t& b) {
    rotation_t res;
    res.d[0] = -b;
    res.d[1] = a.d[0];
    res.d[2] = a.d[1];
    res.d[3] = a.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between ebivector and bivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 0 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator-(const ebivector_t& a, const bivector_t& b) {
    bivector_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    res.d[3] = -b.d[3];
    res.d[4] = -b.d[4];
    res.d[5] = -b.d[5];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between ebivector and quadvector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const ebivector_t& a, const quadvector_t& b) {
    even_t res;
    res.d[0] = 0.0;
    res.d[1] = a.d[0];
    res.d[2] = a.d[1];
    res.d[3] = a.d[2];
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = -b.d[0];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between ebivector and ebivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator-(const ebivector_t& a, const ebivector_t& b) {
    ebivector_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between ebivector and ibivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator-(const ebivector_t& a, const ibivector_t& b) {
    bivector_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = -b.d[0];
    res.d[4] = -b.d[1];
    res.d[5] = -b.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between ebivector and rotation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator-(const ebivector_t& a, const rotation_t& b) {
    rotation_t res;
    res.d[0] = -b.d[0];
    res.d[1] = a.d[0] - b.d[1];
    res.d[2] = a.d[1] - b.d[2];
    res.d[3] = a.d[2] - b.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between ebivector and translation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const ebivector_t& a, const translation_t& b) {
    even_t res;
    res.d[0] = -1;
    res.d[1] = a.d[0];
    res.d[2] = a.d[1];
    res.d[3] = a.d[2];
    res.d[4] = -b.d[0];
    res.d[5] = -b.d[1];
    res.d[6] = -b.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between ebivector and even  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const ebivector_t& a, const even_t& b) {
    even_t res;
    res.d[0] = -b.d[0];
    res.d[1] = a.d[0] - b.d[1];
    res.d[2] = a.d[1] - b.d[2];
    res.d[3] = a.d[2] - b.d[3];
    res.d[4] = -b.d[4];
    res.d[5] = -b.d[5];
    res.d[6] = -b.d[6];
    res.d[7] = -b.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between ibivector and scalar  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const ibivector_t& a, const scalar_t& b) {
    even_t res;
    res.d[0] = -b;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between ibivector and bivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 0 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator-(const ibivector_t& a, const bivector_t& b) {
    bivector_t res;
    res.d[0] = -b.d[0];
    res.d[1] = -b.d[1];
    res.d[2] = -b.d[2];
    res.d[3] = a.d[0] - b.d[3];
    res.d[4] = a.d[1] - b.d[4];
    res.d[5] = a.d[2] - b.d[5];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between ibivector and quadvector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const ibivector_t& a, const quadvector_t& b) {
    even_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = -b.d[0];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between ibivector and ebivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator-(const ibivector_t& a, const ebivector_t& b) {
    bivector_t res;
    res.d[0] = -b.d[0];
    res.d[1] = -b.d[1];
    res.d[2] = -b.d[2];
    res.d[3] = a.d[0];
    res.d[4] = a.d[1];
    res.d[5] = a.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between ibivector and ibivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator-(const ibivector_t& a, const ibivector_t& b) {
    ibivector_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between ibivector and rotation  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const ibivector_t& a, const rotation_t& b) {
    even_t res;
    res.d[0] = -b.d[0];
    res.d[1] = -b.d[1];
    res.d[2] = -b.d[2];
    res.d[3] = -b.d[3];
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between ibivector and translation  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const ibivector_t& a, const translation_t& b) {
    even_t res;
    res.d[0] = -1;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a.d[0] - b.d[0];
    res.d[5] = a.d[1] - b.d[1];
    res.d[6] = a.d[2] - b.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between ibivector and even  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const ibivector_t& a, const even_t& b) {
    even_t res;
    res.d[0] = -b.d[0];
    res.d[1] = -b.d[1];
    res.d[2] = -b.d[2];
    res.d[3] = -b.d[3];
    res.d[4] = a.d[0] - b.d[4];
    res.d[5] = a.d[1] - b.d[5];
    res.d[6] = a.d[2] - b.d[6];
    res.d[7] = -b.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between evector and vector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator-(const evector_t& a, const vector_t& b) {
    vector_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    res.d[3] = -b.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between evector and trivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const evector_t& a, const trivector_t& b) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = 0.0;
    res.d[4] = -b.d[0];
    res.d[5] = -b.d[1];
    res.d[6] = -b.d[2];
    res.d[7] = -b.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between evector and horizon  
// a0 e₁ + a1 e₂ + a2 e₃
// 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator-(const evector_t& a, const horizon_t& b) {
    vector_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between evector and origin  
// a0 e₁ + a1 e₂ + a2 e₃
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const evector_t& a, const origin_t& b) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = 0.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between evector and point  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const evector_t& a, const point_t& b) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = 0.0;
    res.d[4] = -b.d[0];
    res.d[5] = -b.d[1];
    res.d[6] = -b.d[2];
    res.d[7] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between evector and direction  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const evector_t& a, const direction_t& b) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = 0.0;
    res.d[4] = -b.d[0];
    res.d[5] = -b.d[1];
    res.d[6] = -b.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between evector and evector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator-(const evector_t& a, const evector_t& b) {
    evector_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between evector and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator-(const evector_t& a, const dpoint_t& b) {
    vector_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    res.d[3] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between evector and odd  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const evector_t& a, const odd_t& b) {
    odd_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    res.d[3] = -b.d[3];
    res.d[4] = -b.d[4];
    res.d[5] = -b.d[5];
    res.d[6] = -b.d[6];
    res.d[7] = -b.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between dpoint and vector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator-(const dpoint_t& a, const vector_t& b) {
    vector_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    res.d[3] = 1 - b.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between dpoint and trivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const dpoint_t& a, const trivector_t& b) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = 1.0;
    res.d[4] = -b.d[0];
    res.d[5] = -b.d[1];
    res.d[6] = -b.d[2];
    res.d[7] = -b.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between dpoint and horizon  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator-(const dpoint_t& a, const horizon_t& b) {
    evector_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between dpoint and origin  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const dpoint_t& a, const origin_t& b) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = 1.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between dpoint and point  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const dpoint_t& a, const point_t& b) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = 1.0;
    res.d[4] = -b.d[0];
    res.d[5] = -b.d[1];
    res.d[6] = -b.d[2];
    res.d[7] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between dpoint and direction  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const dpoint_t& a, const direction_t& b) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = 1.0;
    res.d[4] = -b.d[0];
    res.d[5] = -b.d[1];
    res.d[6] = -b.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between dpoint and evector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + 1 e₀
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline dpoint_t operator-(const dpoint_t& a, const evector_t& b) {
    dpoint_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between dpoint and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator-(const dpoint_t& a, const dpoint_t& b) {
    evector_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between dpoint and odd  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const dpoint_t& a, const odd_t& b) {
    odd_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    res.d[3] = 1 - b.d[3];
    res.d[4] = -b.d[4];
    res.d[5] = -b.d[5];
    res.d[6] = -b.d[6];
    res.d[7] = -b.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between rotation and scalar  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator-(const rotation_t& a, const scalar_t& b) {
    rotation_t res;
    res.d[0] = a.d[0] - b;
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between rotation and bivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const rotation_t& a, const bivector_t& b) {
    even_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1] - b.d[0];
    res.d[2] = a.d[2] - b.d[1];
    res.d[3] = a.d[3] - b.d[2];
    res.d[4] = -b.d[3];
    res.d[5] = -b.d[4];
    res.d[6] = -b.d[5];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between rotation and quadvector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const rotation_t& a, const quadvector_t& b) {
    even_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = -b.d[0];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between rotation and ebivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator-(const rotation_t& a, const ebivector_t& b) {
    rotation_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1] - b.d[0];
    res.d[2] = a.d[2] - b.d[1];
    res.d[3] = a.d[3] - b.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between rotation and ibivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const rotation_t& a, const ibivector_t& b) {
    even_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    res.d[4] = -b.d[0];
    res.d[5] = -b.d[1];
    res.d[6] = -b.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between rotation and rotation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator-(const rotation_t& a, const rotation_t& b) {
    rotation_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    res.d[3] = a.d[3] - b.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between rotation and translation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const rotation_t& a, const translation_t& b) {
    even_t res;
    res.d[0] = -1 + a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    res.d[4] = -b.d[0];
    res.d[5] = -b.d[1];
    res.d[6] = -b.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between rotation and even  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const rotation_t& a, const even_t& b) {
    even_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    res.d[3] = a.d[3] - b.d[3];
    res.d[4] = -b.d[4];
    res.d[5] = -b.d[5];
    res.d[6] = -b.d[6];
    res.d[7] = -b.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between translation and scalar  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const translation_t& a, const scalar_t& b) {
    even_t res;
    res.d[0] = 1 - b;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between translation and bivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const translation_t& a, const bivector_t& b) {
    even_t res;
    res.d[0] = 1.0;
    res.d[1] = -b.d[0];
    res.d[2] = -b.d[1];
    res.d[3] = -b.d[2];
    res.d[4] = a.d[0] - b.d[3];
    res.d[5] = a.d[1] - b.d[4];
    res.d[6] = a.d[2] - b.d[5];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between translation and quadvector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const translation_t& a, const quadvector_t& b) {
    even_t res;
    res.d[0] = 1.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = -b.d[0];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between translation and ebivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const translation_t& a, const ebivector_t& b) {
    even_t res;
    res.d[0] = 1.0;
    res.d[1] = -b.d[0];
    res.d[2] = -b.d[1];
    res.d[3] = -b.d[2];
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between translation and ibivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline translation_t operator-(const translation_t& a, const ibivector_t& b) {
    translation_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between translation and rotation  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const translation_t& a, const rotation_t& b) {
    even_t res;
    res.d[0] = 1 - b.d[0];
    res.d[1] = -b.d[1];
    res.d[2] = -b.d[2];
    res.d[3] = -b.d[3];
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between translation and translation  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator-(const translation_t& a, const translation_t& b) {
    ibivector_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between translation and even  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const translation_t& a, const even_t& b) {
    even_t res;
    res.d[0] = 1 - b.d[0];
    res.d[1] = -b.d[1];
    res.d[2] = -b.d[2];
    res.d[3] = -b.d[3];
    res.d[4] = a.d[0] - b.d[4];
    res.d[5] = a.d[1] - b.d[5];
    res.d[6] = a.d[2] - b.d[6];
    res.d[7] = -b.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between even and scalar  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const even_t& a, const scalar_t& b) {
    even_t res;
    res.d[0] = a.d[0] - b;
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    res.d[4] = a.d[4];
    res.d[5] = a.d[5];
    res.d[6] = a.d[6];
    res.d[7] = a.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between even and bivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const even_t& a, const bivector_t& b) {
    even_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1] - b.d[0];
    res.d[2] = a.d[2] - b.d[1];
    res.d[3] = a.d[3] - b.d[2];
    res.d[4] = a.d[4] - b.d[3];
    res.d[5] = a.d[5] - b.d[4];
    res.d[6] = a.d[6] - b.d[5];
    res.d[7] = a.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between even and quadvector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const even_t& a, const quadvector_t& b) {
    even_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    res.d[4] = a.d[4];
    res.d[5] = a.d[5];
    res.d[6] = a.d[6];
    res.d[7] = a.d[7] - b.d[0];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between even and ebivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const even_t& a, const ebivector_t& b) {
    even_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1] - b.d[0];
    res.d[2] = a.d[2] - b.d[1];
    res.d[3] = a.d[3] - b.d[2];
    res.d[4] = a.d[4];
    res.d[5] = a.d[5];
    res.d[6] = a.d[6];
    res.d[7] = a.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between even and ibivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const even_t& a, const ibivector_t& b) {
    even_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    res.d[4] = a.d[4] - b.d[0];
    res.d[5] = a.d[5] - b.d[1];
    res.d[6] = a.d[6] - b.d[2];
    res.d[7] = a.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between even and rotation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const even_t& a, const rotation_t& b) {
    even_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    res.d[3] = a.d[3] - b.d[3];
    res.d[4] = a.d[4];
    res.d[5] = a.d[5];
    res.d[6] = a.d[6];
    res.d[7] = a.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between even and translation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const even_t& a, const translation_t& b) {
    even_t res;
    res.d[0] = -1 + a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    res.d[4] = a.d[4] - b.d[0];
    res.d[5] = a.d[5] - b.d[1];
    res.d[6] = a.d[6] - b.d[2];
    res.d[7] = a.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between even and even  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator-(const even_t& a, const even_t& b) {
    even_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    res.d[3] = a.d[3] - b.d[3];
    res.d[4] = a.d[4] - b.d[4];
    res.d[5] = a.d[5] - b.d[5];
    res.d[6] = a.d[6] - b.d[6];
    res.d[7] = a.d[7] - b.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between odd and vector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const odd_t& a, const vector_t& b) {
    odd_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    res.d[3] = a.d[3] - b.d[3];
    res.d[4] = a.d[4];
    res.d[5] = a.d[5];
    res.d[6] = a.d[6];
    res.d[7] = a.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between odd and trivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const odd_t& a, const trivector_t& b) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    res.d[4] = a.d[4] - b.d[0];
    res.d[5] = a.d[5] - b.d[1];
    res.d[6] = a.d[6] - b.d[2];
    res.d[7] = a.d[7] - b.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between odd and horizon  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const odd_t& a, const horizon_t& b) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = -1 + a.d[3];
    res.d[4] = a.d[4];
    res.d[5] = a.d[5];
    res.d[6] = a.d[6];
    res.d[7] = a.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between odd and origin  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const odd_t& a, const origin_t& b) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    res.d[4] = a.d[4];
    res.d[5] = a.d[5];
    res.d[6] = a.d[6];
    res.d[7] = -1 + a.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between odd and point  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const odd_t& a, const point_t& b) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    res.d[4] = a.d[4] - b.d[0];
    res.d[5] = a.d[5] - b.d[1];
    res.d[6] = a.d[6] - b.d[2];
    res.d[7] = -1 + a.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between odd and direction  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const odd_t& a, const direction_t& b) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    res.d[4] = a.d[4] - b.d[0];
    res.d[5] = a.d[5] - b.d[1];
    res.d[6] = a.d[6] - b.d[2];
    res.d[7] = a.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between odd and evector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const odd_t& a, const evector_t& b) {
    odd_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    res.d[3] = a.d[3];
    res.d[4] = a.d[4];
    res.d[5] = a.d[5];
    res.d[6] = a.d[6];
    res.d[7] = a.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between odd and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const odd_t& a, const dpoint_t& b) {
    odd_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    res.d[3] = -1 + a.d[3];
    res.d[4] = a.d[4];
    res.d[5] = a.d[5];
    res.d[6] = a.d[6];
    res.d[7] = a.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sub between odd and odd  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator-(const odd_t& a, const odd_t& b) {
    odd_t res;
    res.d[0] = a.d[0] - b.d[0];
    res.d[1] = a.d[1] - b.d[1];
    res.d[2] = a.d[2] - b.d[2];
    res.d[3] = a.d[3] - b.d[3];
    res.d[4] = a.d[4] - b.d[4];
    res.d[5] = a.d[5] - b.d[5];
    res.d[6] = a.d[6] - b.d[6];
    res.d[7] = a.d[7] - b.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between scalar and vector  
// a
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator*(const scalar_t& a, const vector_t& b) {
    vector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    res.d[3] = a * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between scalar and bivector  
// a
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 6 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator*(const scalar_t& a, const bivector_t& b) {
    bivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    res.d[3] = a * b3;
    res.d[4] = a * b4;
    res.d[5] = a * b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between scalar and trivector  
// a
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator*(const scalar_t& a, const trivector_t& b) {
    trivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    res.d[3] = a * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between scalar and quadvector  
// a
// b0 e₀₁₂₃
// -> r0 e₀₁₂₃
// 1 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator*(const scalar_t& a, const quadvector_t& b) {
    quadvector_t res;
    const float b0 = b.d[0];
    res.d[0] = a * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between scalar and horizon  
// a
// 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator*(const scalar_t& a, const horizon_t& b) {
    vector_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between scalar and origin  
// a
// 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator*(const scalar_t& a, const origin_t& b) {
    trivector_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between scalar and point  
// a
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator*(const scalar_t& a, const point_t& b) {
    trivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    res.d[3] = a;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between scalar and direction  
// a
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator*(const scalar_t& a, const direction_t& b) {
    direction_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between scalar and ebivector  
// a
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator*(const scalar_t& a, const ebivector_t& b) {
    ebivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between scalar and ibivector  
// a
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator*(const scalar_t& a, const ibivector_t& b) {
    ibivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between scalar and evector  
// a
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator*(const scalar_t& a, const evector_t& b) {
    evector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between scalar and dpoint  
// a
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator*(const scalar_t& a, const dpoint_t& b) {
    vector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    res.d[3] = a;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between scalar and rotation  
// a
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator*(const scalar_t& a, const rotation_t& b) {
    rotation_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    res.d[3] = a * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between scalar and translation  
// a
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const scalar_t& a, const translation_t& b) {
    even_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a * b0;
    res.d[5] = a * b1;
    res.d[6] = a * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between scalar and even  
// a
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 8 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const scalar_t& a, const even_t& b) {
    even_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    res.d[3] = a * b3;
    res.d[4] = a * b4;
    res.d[5] = a * b5;
    res.d[6] = a * b6;
    res.d[7] = a * b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between scalar and odd  
// a
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 8 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const scalar_t& a, const odd_t& b) {
    odd_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    res.d[3] = a * b3;
    res.d[4] = a * b4;
    res.d[5] = a * b5;
    res.d[6] = a * b6;
    res.d[7] = a * b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between vector and scalar  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator*(const vector_t& a, const scalar_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    res.d[3] = a3 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between vector and vector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 15 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const vector_t& a, const vector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[1] = a1 * b2 - a2 * b1;
    res.d[2] = a2 * b0 - a0 * b2;
    res.d[3] = a0 * b1 - a1 * b0;
    res.d[4] = a3 * b0 - a0 * b3;
    res.d[5] = a3 * b1 - a1 * b3;
    res.d[6] = a3 * b2 - a2 * b3;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between vector and bivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 21 muls / 14 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const vector_t& a, const bivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = -a0 * b3 - a1 * b4 - a2 * b5;
    res.d[4] = a1 * b5 - a2 * b4 - a3 * b0;
    res.d[5] = a2 * b3 - a0 * b5 - a3 * b1;
    res.d[6] = a0 * b4 - a1 * b3 - a3 * b2;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between vector and trivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 13 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const vector_t& a, const trivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = a0 * b3;
    res.d[2] = a1 * b3;
    res.d[3] = a2 * b3;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between vector and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator*(const vector_t& a, const quadvector_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between vector and horizon  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// 1 e₀
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator*(const vector_t& a, const horizon_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between vector and origin  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// 1 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const vector_t& a, const origin_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = 0.0;
    res.d[1] = a0;
    res.d[2] = a1;
    res.d[3] = a2;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between vector and point  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const vector_t& a, const point_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = a0;
    res.d[2] = a1;
    res.d[3] = a2;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2 + a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between vector and direction  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const vector_t& a, const direction_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between vector and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const vector_t& a, const ebivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = 0.0;
    res.d[4] = -a3 * b0;
    res.d[5] = -a3 * b1;
    res.d[6] = -a3 * b2;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between vector and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const vector_t& a, const ibivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    res.d[4] = a1 * b2 - a2 * b1;
    res.d[5] = a2 * b0 - a0 * b2;
    res.d[6] = a0 * b1 - a1 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between vector and evector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const vector_t& a, const evector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[1] = a1 * b2 - a2 * b1;
    res.d[2] = a2 * b0 - a0 * b2;
    res.d[3] = a0 * b1 - a1 * b0;
    res.d[4] = a3 * b0;
    res.d[5] = a3 * b1;
    res.d[6] = a3 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between vector and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const vector_t& a, const dpoint_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[1] = a1 * b2 - a2 * b1;
    res.d[2] = a2 * b0 - a0 * b2;
    res.d[3] = a0 * b1 - a1 * b0;
    res.d[4] = a3 * b0 - a0;
    res.d[5] = a3 * b1 - a1;
    res.d[6] = a3 * b2 - a2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between vector and rotation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 16 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const vector_t& a, const rotation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0 + a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 + a1 * b0 - a2 * b1;
    res.d[2] = a1 * b1 + a2 * b0 - a0 * b2;
    res.d[3] = a3 * b0;
    res.d[4] = -a3 * b1;
    res.d[5] = -a3 * b2;
    res.d[6] = -a3 * b3;
    res.d[7] = a0 * b1 + a1 * b2 + a2 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between vector and translation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const vector_t& a, const translation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a3 - a0 * b0 - a1 * b1 - a2 * b2;
    res.d[4] = a1 * b2 - a2 * b1;
    res.d[5] = a2 * b0 - a0 * b2;
    res.d[6] = a0 * b1 - a1 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between vector and even  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 28 muls / 20 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const vector_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0 + a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 + a1 * b0 - a2 * b1;
    res.d[2] = a1 * b1 + a2 * b0 - a0 * b2;
    res.d[3] = a3 * b0 - a0 * b4 - a1 * b5 - a2 * b6;
    res.d[4] = a0 * b7 + a1 * b6 - a2 * b5 - a3 * b1;
    res.d[5] = a1 * b7 + a2 * b4 - a0 * b6 - a3 * b2;
    res.d[6] = a0 * b5 + a2 * b7 - a1 * b4 - a3 * b3;
    res.d[7] = a0 * b1 + a1 * b2 + a2 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between vector and odd  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 28 muls / 20 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const vector_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[1] = a0 * b7 + a1 * b2 - a2 * b1;
    res.d[2] = a1 * b7 + a2 * b0 - a0 * b2;
    res.d[3] = a0 * b1 + a2 * b7 - a1 * b0;
    res.d[4] = a2 * b5 + a3 * b0 - a0 * b3 - a1 * b6;
    res.d[5] = a0 * b6 + a3 * b1 - a1 * b3 - a2 * b4;
    res.d[6] = a1 * b4 + a3 * b2 - a0 * b5 - a2 * b3;
    res.d[7] = a0 * b4 + a1 * b5 + a2 * b6 + a3 * b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between bivector and scalar  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 6 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator*(const bivector_t& a, const scalar_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    res.d[3] = a3 * b;
    res.d[4] = a4 * b;
    res.d[5] = a5 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between bivector and vector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 21 muls / 13 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const bivector_t& a, const vector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = a3 * b0 + a4 * b1 + a5 * b2;
    res.d[4] = a5 * b1 - a0 * b3 - a4 * b2;
    res.d[5] = a3 * b2 - a1 * b3 - a5 * b0;
    res.d[6] = a4 * b0 - a2 * b3 - a3 * b1;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between bivector and bivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 27 muls / 20 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const bivector_t& a, const bivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = -a0 * b0 - a1 * b1 - a2 * b2;
    res.d[1] = a2 * b1 - a1 * b2;
    res.d[2] = a0 * b2 - a2 * b0;
    res.d[3] = a1 * b0 - a0 * b1;
    res.d[4] = a2 * b4 + a5 * b1 - a1 * b5 - a4 * b2;
    res.d[5] = a0 * b5 + a3 * b2 - a2 * b3 - a5 * b0;
    res.d[6] = a1 * b3 + a4 * b0 - a0 * b4 - a3 * b1;
    res.d[7] = a0 * b3 + a1 * b4 + a2 * b5 + a3 * b0 + a4 * b1 + a5 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between bivector and trivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 15 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const bivector_t& a, const trivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a0 * b3;
    res.d[1] = -a1 * b3;
    res.d[2] = -a2 * b3;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[4] = a2 * b1 - a1 * b2 - a3 * b3;
    res.d[5] = a0 * b2 - a2 * b0 - a4 * b3;
    res.d[6] = a1 * b0 - a0 * b1 - a5 * b3;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between bivector and quadvector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₁₂₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator*(const bivector_t& a, const quadvector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = -a0 * b0;
    res.d[1] = -a1 * b0;
    res.d[2] = -a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between bivector and horizon  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// 1 e₀
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator*(const bivector_t& a, const horizon_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between bivector and origin  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const bivector_t& a, const origin_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    res.d[3] = 0.0;
    res.d[4] = -a3;
    res.d[5] = -a4;
    res.d[6] = -a5;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between bivector and point  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 9 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const bivector_t& a, const point_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[4] = a2 * b1 - a1 * b2 - a3;
    res.d[5] = a0 * b2 - a2 * b0 - a4;
    res.d[6] = a1 * b0 - a0 * b1 - a5;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between bivector and direction  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const bivector_t& a, const direction_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between bivector and ebivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 18 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const bivector_t& a, const ebivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0 * b0 - a1 * b1 - a2 * b2;
    res.d[1] = a2 * b1 - a1 * b2;
    res.d[2] = a0 * b2 - a2 * b0;
    res.d[3] = a1 * b0 - a0 * b1;
    res.d[4] = a5 * b1 - a4 * b2;
    res.d[5] = a3 * b2 - a5 * b0;
    res.d[6] = a4 * b0 - a3 * b1;
    res.d[7] = a3 * b0 + a4 * b1 + a5 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between bivector and ibivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const bivector_t& a, const ibivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between bivector and evector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 18 muls / 10 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const bivector_t& a, const evector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = a3 * b0 + a4 * b1 + a5 * b2;
    res.d[4] = a5 * b1 - a4 * b2;
    res.d[5] = a3 * b2 - a5 * b0;
    res.d[6] = a4 * b0 - a3 * b1;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between bivector and dpoint  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 18 muls / 13 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const bivector_t& a, const dpoint_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = a3 * b0 + a4 * b1 + a5 * b2;
    res.d[4] = a5 * b1 - a0 - a4 * b2;
    res.d[5] = a3 * b2 - a1 - a5 * b0;
    res.d[6] = a4 * b0 - a2 - a3 * b1;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between bivector and rotation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 24 muls / 17 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const bivector_t& a, const rotation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a0 * b1 - a1 * b2 - a2 * b3;
    res.d[1] = a0 * b0 + a2 * b2 - a1 * b3;
    res.d[2] = a0 * b3 + a1 * b0 - a2 * b1;
    res.d[3] = a1 * b1 + a2 * b0 - a0 * b2;
    res.d[4] = a3 * b0 + a5 * b2 - a4 * b3;
    res.d[5] = a3 * b3 + a4 * b0 - a5 * b1;
    res.d[6] = a4 * b1 + a5 * b0 - a3 * b2;
    res.d[7] = a3 * b1 + a4 * b2 + a5 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between bivector and translation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const bivector_t& a, const translation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = a0;
    res.d[2] = a1;
    res.d[3] = a2;
    res.d[4] = a2 * b1 + a3 - a1 * b2;
    res.d[5] = a0 * b2 + a4 - a2 * b0;
    res.d[6] = a1 * b0 + a5 - a0 * b1;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between bivector and even  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 36 muls / 29 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const bivector_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = -a0 * b1 - a1 * b2 - a2 * b3;
    res.d[1] = a0 * b0 + a2 * b2 - a1 * b3;
    res.d[2] = a0 * b3 + a1 * b0 - a2 * b1;
    res.d[3] = a1 * b1 + a2 * b0 - a0 * b2;
    res.d[4] = a2 * b5 + a3 * b0 + a5 * b2 - a0 * b7 - a1 * b6 - a4 * b3;
    res.d[5] = a0 * b6 + a3 * b3 + a4 * b0 - a1 * b7 - a2 * b4 - a5 * b1;
    res.d[6] = a1 * b4 + a4 * b1 + a5 * b0 - a0 * b5 - a2 * b7 - a3 * b2;
    res.d[7] = a0 * b4 + a1 * b5 + a2 * b6 + a3 * b1 + a4 * b2 + a5 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between bivector and odd  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 36 muls / 28 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const bivector_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a2 * b1 - a0 * b7 - a1 * b2;
    res.d[1] = a0 * b2 - a1 * b7 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1 - a2 * b7;
    res.d[3] = a0 * b4 + a1 * b5 + a2 * b6 + a3 * b0 + a4 * b1 + a5 * b2;
    res.d[4] = a2 * b5 + a5 * b1 - a0 * b3 - a1 * b6 - a3 * b7 - a4 * b2;
    res.d[5] = a0 * b6 + a3 * b2 - a1 * b3 - a2 * b4 - a4 * b7 - a5 * b0;
    res.d[6] = a1 * b4 + a4 * b0 - a0 * b5 - a2 * b3 - a3 * b1 - a5 * b7;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between trivector and scalar  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator*(const trivector_t& a, const scalar_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    res.d[3] = a3 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between trivector and vector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 13 muls / 7 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const trivector_t& a, const vector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = a3 * b0;
    res.d[2] = a3 * b1;
    res.d[3] = a3 * b2;
    res.d[4] = a1 * b2 - a2 * b1;
    res.d[5] = a2 * b0 - a0 * b2;
    res.d[6] = a0 * b1 - a1 * b0;
    res.d[7] = -a0 * b0 - a1 * b1 - a2 * b2 - a3 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between trivector and bivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 15 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const trivector_t& a, const bivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = -a3 * b0;
    res.d[1] = -a3 * b1;
    res.d[2] = -a3 * b2;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[4] = a2 * b1 + a3 * b3 - a1 * b2;
    res.d[5] = a0 * b2 + a3 * b4 - a2 * b0;
    res.d[6] = a1 * b0 + a3 * b5 - a0 * b1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between trivector and trivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 7 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const trivector_t& a, const trivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a3 * b3;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a0 * b3 - a3 * b0;
    res.d[5] = a1 * b3 - a3 * b1;
    res.d[6] = a2 * b3 - a3 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between trivector and quadvector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 1 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator*(const trivector_t& a, const quadvector_t& b) {
    vector_t res;
    const float a3 = a.d[3], b0 = b.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a3 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between trivector and horizon  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// 1 e₀
// -> r0 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator*(const trivector_t& a, const horizon_t& b) {
    quadvector_t res;
    const float a3 = a.d[3];
    res.d[0] = -a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between trivector and origin  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// 1 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const trivector_t& a, const origin_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = -a3;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a0;
    res.d[5] = a1;
    res.d[6] = a2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between trivector and point  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 3 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const trivector_t& a, const point_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a3;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a0 - a3 * b0;
    res.d[5] = a1 - a3 * b1;
    res.d[6] = a2 - a3 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between trivector and direction  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator*(const trivector_t& a, const direction_t& b) {
    ibivector_t res;
    const float a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a3 * b0;
    res.d[1] = -a3 * b1;
    res.d[2] = -a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between trivector and ebivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const trivector_t& a, const ebivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a3 * b0;
    res.d[1] = -a3 * b1;
    res.d[2] = -a3 * b2;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between trivector and ibivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator*(const trivector_t& a, const ibivector_t& b) {
    direction_t res;
    const float a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b0;
    res.d[1] = a3 * b1;
    res.d[2] = a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between trivector and evector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const trivector_t& a, const evector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = a3 * b0;
    res.d[2] = a3 * b1;
    res.d[3] = a3 * b2;
    res.d[4] = a1 * b2 - a2 * b1;
    res.d[5] = a2 * b0 - a0 * b2;
    res.d[6] = a0 * b1 - a1 * b0;
    res.d[7] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between trivector and dpoint  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 7 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const trivector_t& a, const dpoint_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = a3 * b0;
    res.d[2] = a3 * b1;
    res.d[3] = a3 * b2;
    res.d[4] = a1 * b2 - a2 * b1;
    res.d[5] = a2 * b0 - a0 * b2;
    res.d[6] = a0 * b1 - a1 * b0;
    res.d[7] = -a0 * b0 - a1 * b1 - a2 * b2 - a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between trivector and rotation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 16 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const trivector_t& a, const rotation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a3 * b1;
    res.d[1] = -a3 * b2;
    res.d[2] = -a3 * b3;
    res.d[3] = a0 * b1 + a1 * b2 + a2 * b3;
    res.d[4] = a0 * b0 + a2 * b2 - a1 * b3;
    res.d[5] = a0 * b3 + a1 * b0 - a2 * b1;
    res.d[6] = a1 * b1 + a2 * b0 - a0 * b2;
    res.d[7] = a3 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between trivector and translation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator*(const trivector_t& a, const translation_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 + a3 * b0;
    res.d[1] = a1 + a3 * b1;
    res.d[2] = a2 + a3 * b2;
    res.d[3] = a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between trivector and even  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 20 muls / 15 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const trivector_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = -a3 * b1;
    res.d[1] = -a3 * b2;
    res.d[2] = -a3 * b3;
    res.d[3] = a0 * b1 + a1 * b2 + a2 * b3 + a3 * b7;
    res.d[4] = a0 * b0 + a2 * b2 + a3 * b4 - a1 * b3;
    res.d[5] = a0 * b3 + a1 * b0 + a3 * b5 - a2 * b1;
    res.d[6] = a1 * b1 + a2 * b0 + a3 * b6 - a0 * b2;
    res.d[7] = a3 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between trivector and odd  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 20 muls / 14 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const trivector_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = -a3 * b7;
    res.d[1] = a3 * b0;
    res.d[2] = a3 * b1;
    res.d[3] = a3 * b2;
    res.d[4] = a0 * b7 + a1 * b2 - a2 * b1 - a3 * b4;
    res.d[5] = a1 * b7 + a2 * b0 - a0 * b2 - a3 * b5;
    res.d[6] = a0 * b1 + a2 * b7 - a1 * b0 - a3 * b6;
    res.d[7] = -a0 * b0 - a1 * b1 - a2 * b2 - a3 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between quadvector and scalar  
// a0 e₀₁₂₃
// b
// -> r0 e₀₁₂₃
// 1 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator*(const quadvector_t& a, const scalar_t& b) {
    quadvector_t res;
    const float a0 = a.d[0];
    res.d[0] = a0 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between quadvector and vector  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator*(const quadvector_t& a, const vector_t& b) {
    direction_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0 * b0;
    res.d[1] = -a0 * b1;
    res.d[2] = -a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between quadvector and bivector  
// a0 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator*(const quadvector_t& a, const bivector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0 * b0;
    res.d[1] = -a0 * b1;
    res.d[2] = -a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between quadvector and trivector  
// a0 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 1 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator*(const quadvector_t& a, const trivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between quadvector and quadvector  
// a0 e₀₁₂₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator*(const quadvector_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// gp between quadvector and horizon  
// a0 e₀₁₂₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator*(const quadvector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// gp between quadvector and origin  
// a0 e₀₁₂₃
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator*(const quadvector_t& a, const origin_t& b) {
    vector_t res;
    const float a0 = a.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between quadvector and point  
// a0 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator*(const quadvector_t& a, const point_t& b) {
    vector_t res;
    const float a0 = a.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between quadvector and direction  
// a0 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator*(const quadvector_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// gp between quadvector and ebivector  
// a0 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator*(const quadvector_t& a, const ebivector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0 * b0;
    res.d[1] = -a0 * b1;
    res.d[2] = -a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between quadvector and ibivector  
// a0 e₀₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator*(const quadvector_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// gp between quadvector and evector  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator*(const quadvector_t& a, const evector_t& b) {
    direction_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0 * b0;
    res.d[1] = -a0 * b1;
    res.d[2] = -a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between quadvector and dpoint  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator*(const quadvector_t& a, const dpoint_t& b) {
    direction_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0 * b0;
    res.d[1] = -a0 * b1;
    res.d[2] = -a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between quadvector and rotation  
// a0 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 4 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const quadvector_t& a, const rotation_t& b) {
    even_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = -a0 * b1;
    res.d[5] = -a0 * b2;
    res.d[6] = -a0 * b3;
    res.d[7] = a0 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between quadvector and translation  
// a0 e₀₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator*(const quadvector_t& a, const translation_t& b) {
    quadvector_t res;
    const float a0 = a.d[0];
    res.d[0] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between quadvector and even  
// a0 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 4 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const quadvector_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = -a0 * b1;
    res.d[5] = -a0 * b2;
    res.d[6] = -a0 * b3;
    res.d[7] = a0 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between quadvector and odd  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 4 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const quadvector_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b7 = b.d[7];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b7;
    res.d[4] = -a0 * b0;
    res.d[5] = -a0 * b1;
    res.d[6] = -a0 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between horizon and scalar  
// 1 e₀
// b
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator*(const horizon_t& a, const scalar_t& b) {
    vector_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between horizon and vector  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator*(const horizon_t& a, const vector_t& b) {
    ibivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between horizon and bivector  
// 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator*(const horizon_t& a, const bivector_t& b) {
    direction_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between horizon and trivector  
// 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator*(const horizon_t& a, const trivector_t& b) {
    quadvector_t res;
    const float b3 = b.d[3];
    res.d[0] = b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between horizon and quadvector  
// 1 e₀
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator*(const horizon_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// gp between horizon and horizon  
// 1 e₀
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator*(const horizon_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// gp between horizon and origin  
// 1 e₀
// 1 e₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator*(const horizon_t& a, const origin_t& b) {
    quadvector_t res;
    res.d[0] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between horizon and point  
// 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator*(const horizon_t& a, const point_t& b) {
    quadvector_t res;
    res.d[0] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between horizon and direction  
// 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator*(const horizon_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// gp between horizon and ebivector  
// 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator*(const horizon_t& a, const ebivector_t& b) {
    direction_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between horizon and ibivector  
// 1 e₀
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator*(const horizon_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// gp between horizon and evector  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator*(const horizon_t& a, const evector_t& b) {
    ibivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between horizon and dpoint  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator*(const horizon_t& a, const dpoint_t& b) {
    ibivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between horizon and rotation  
// 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const horizon_t& a, const rotation_t& b) {
    odd_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b0;
    res.d[4] = -b1;
    res.d[5] = -b2;
    res.d[6] = -b3;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between horizon and translation  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline horizon_t operator*(const horizon_t& a, const translation_t& b) {

    return horizon_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// gp between horizon and even  
// 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const horizon_t& a, const even_t& b) {
    odd_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b0;
    res.d[4] = -b1;
    res.d[5] = -b2;
    res.d[6] = -b3;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between horizon and odd  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const horizon_t& a, const odd_t& b) {
    even_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b7 = b.d[7];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = b0;
    res.d[5] = b1;
    res.d[6] = b2;
    res.d[7] = b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between origin and scalar  
// 1 e₁₂₃
// b
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator*(const origin_t& a, const scalar_t& b) {
    trivector_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between origin and vector  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const origin_t& a, const vector_t& b) {
    even_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = b0;
    res.d[2] = b1;
    res.d[3] = b2;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = -b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between origin and bivector  
// 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const origin_t& a, const bivector_t& b) {
    odd_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    res.d[3] = 0.0;
    res.d[4] = b3;
    res.d[5] = b4;
    res.d[6] = b5;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between origin and trivector  
// 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const origin_t& a, const trivector_t& b) {
    even_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -b3;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = -b0;
    res.d[5] = -b1;
    res.d[6] = -b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between origin and quadvector  
// 1 e₁₂₃
// b0 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator*(const origin_t& a, const quadvector_t& b) {
    vector_t res;
    const float b0 = b.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between origin and horizon  
// 1 e₁₂₃
// 1 e₀
// -> r0 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator*(const origin_t& a, const horizon_t& b) {
    quadvector_t res;
    res.d[0] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between origin and origin  
// 1 e₁₂₃
// 1 e₁₂₃
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator*(const origin_t& a, const origin_t& b) {

    return -1;

}

////////////////////////////////////////////////////////////////////////////////  
// gp between origin and point  
// 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const origin_t& a, const point_t& b) {
    even_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -1;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = -b0;
    res.d[5] = -b1;
    res.d[6] = -b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between origin and direction  
// 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator*(const origin_t& a, const direction_t& b) {
    ibivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between origin and ebivector  
// 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator*(const origin_t& a, const ebivector_t& b) {
    evector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between origin and ibivector  
// 1 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator*(const origin_t& a, const ibivector_t& b) {
    direction_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between origin and evector  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator*(const origin_t& a, const evector_t& b) {
    ebivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between origin and dpoint  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const origin_t& a, const dpoint_t& b) {
    even_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = b0;
    res.d[2] = b1;
    res.d[3] = b2;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between origin and rotation  
// 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const origin_t& a, const rotation_t& b) {
    odd_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -b1;
    res.d[1] = -b2;
    res.d[2] = -b3;
    res.d[3] = 0.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between origin and translation  
// 1 e₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t operator*(const origin_t& a, const translation_t& b) {
    point_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between origin and even  
// 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const origin_t& a, const even_t& b) {
    odd_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = -b1;
    res.d[1] = -b2;
    res.d[2] = -b3;
    res.d[3] = b7;
    res.d[4] = b4;
    res.d[5] = b5;
    res.d[6] = b6;
    res.d[7] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between origin and odd  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const origin_t& a, const odd_t& b) {
    even_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = -b7;
    res.d[1] = b0;
    res.d[2] = b1;
    res.d[3] = b2;
    res.d[4] = -b4;
    res.d[5] = -b5;
    res.d[6] = -b6;
    res.d[7] = -b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between point and scalar  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator*(const point_t& a, const scalar_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    res.d[3] = b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between point and vector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 7 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const point_t& a, const vector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = b0;
    res.d[2] = b1;
    res.d[3] = b2;
    res.d[4] = a1 * b2 - a2 * b1;
    res.d[5] = a2 * b0 - a0 * b2;
    res.d[6] = a0 * b1 - a1 * b0;
    res.d[7] = -a0 * b0 - a1 * b1 - a2 * b2 - b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between point and bivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 9 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const point_t& a, const bivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[4] = a2 * b1 + b3 - a1 * b2;
    res.d[5] = a0 * b2 + b4 - a2 * b0;
    res.d[6] = a1 * b0 + b5 - a0 * b1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between point and trivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 3 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const point_t& a, const trivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -b3;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a0 * b3 - b0;
    res.d[5] = a1 * b3 - b1;
    res.d[6] = a2 * b3 - b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between point and quadvector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator*(const point_t& a, const quadvector_t& b) {
    vector_t res;
    const float b0 = b.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between point and horizon  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// 1 e₀
// -> r0 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator*(const point_t& a, const horizon_t& b) {
    quadvector_t res;
    res.d[0] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between point and origin  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// 1 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const point_t& a, const origin_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -1;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a0;
    res.d[5] = a1;
    res.d[6] = a2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between point and point  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const point_t& a, const point_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -1;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a0 - b0;
    res.d[5] = a1 - b1;
    res.d[6] = a2 - b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between point and direction  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator*(const point_t& a, const direction_t& b) {
    ibivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between point and ebivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 9 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const point_t& a, const ebivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between point and ibivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator*(const point_t& a, const ibivector_t& b) {
    direction_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between point and evector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const point_t& a, const evector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = b0;
    res.d[2] = b1;
    res.d[3] = b2;
    res.d[4] = a1 * b2 - a2 * b1;
    res.d[5] = a2 * b0 - a0 * b2;
    res.d[6] = a0 * b1 - a1 * b0;
    res.d[7] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between point and dpoint  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 7 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const point_t& a, const dpoint_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = b0;
    res.d[2] = b1;
    res.d[3] = b2;
    res.d[4] = a1 * b2 - a2 * b1;
    res.d[5] = a2 * b0 - a0 * b2;
    res.d[6] = a0 * b1 - a1 * b0;
    res.d[7] = -1 - a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between point and rotation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const point_t& a, const rotation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -b1;
    res.d[1] = -b2;
    res.d[2] = -b3;
    res.d[3] = a0 * b1 + a1 * b2 + a2 * b3;
    res.d[4] = a0 * b0 + a2 * b2 - a1 * b3;
    res.d[5] = a0 * b3 + a1 * b0 - a2 * b1;
    res.d[6] = a1 * b1 + a2 * b0 - a0 * b2;
    res.d[7] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between point and translation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t operator*(const point_t& a, const translation_t& b) {
    point_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 + b0;
    res.d[1] = a1 + b1;
    res.d[2] = a2 + b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between point and even  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 15 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const point_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = -b1;
    res.d[1] = -b2;
    res.d[2] = -b3;
    res.d[3] = a0 * b1 + a1 * b2 + a2 * b3 + b7;
    res.d[4] = a0 * b0 + a2 * b2 + b4 - a1 * b3;
    res.d[5] = a0 * b3 + a1 * b0 + b5 - a2 * b1;
    res.d[6] = a1 * b1 + a2 * b0 + b6 - a0 * b2;
    res.d[7] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between point and odd  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 14 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const point_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = -b7;
    res.d[1] = b0;
    res.d[2] = b1;
    res.d[3] = b2;
    res.d[4] = a0 * b7 + a1 * b2 - a2 * b1 - b4;
    res.d[5] = a1 * b7 + a2 * b0 - a0 * b2 - b5;
    res.d[6] = a0 * b1 + a2 * b7 - a1 * b0 - b6;
    res.d[7] = -a0 * b0 - a1 * b1 - a2 * b2 - b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between direction and scalar  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator*(const direction_t& a, const scalar_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between direction and vector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const direction_t& a, const vector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a1 * b2 - a2 * b1;
    res.d[5] = a2 * b0 - a0 * b2;
    res.d[6] = a0 * b1 - a1 * b0;
    res.d[7] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between direction and bivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const direction_t& a, const bivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between direction and trivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator*(const direction_t& a, const trivector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b3 = b.d[3];
    res.d[0] = a0 * b3;
    res.d[1] = a1 * b3;
    res.d[2] = a2 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between direction and quadvector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator*(const direction_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// gp between direction and horizon  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator*(const direction_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// gp between direction and origin  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// 1 e₁₂₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator*(const direction_t& a, const origin_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between direction and point  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator*(const direction_t& a, const point_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between direction and direction  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator*(const direction_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// gp between direction and ebivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const direction_t& a, const ebivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between direction and ibivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator*(const direction_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// gp between direction and evector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const direction_t& a, const evector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a1 * b2 - a2 * b1;
    res.d[5] = a2 * b0 - a0 * b2;
    res.d[6] = a0 * b1 - a1 * b0;
    res.d[7] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between direction and dpoint  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const direction_t& a, const dpoint_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a1 * b2 - a2 * b1;
    res.d[5] = a2 * b0 - a0 * b2;
    res.d[6] = a0 * b1 - a1 * b0;
    res.d[7] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between direction and rotation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const direction_t& a, const rotation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b1 + a1 * b2 + a2 * b3;
    res.d[4] = a0 * b0 + a2 * b2 - a1 * b3;
    res.d[5] = a0 * b3 + a1 * b0 - a2 * b1;
    res.d[6] = a1 * b1 + a2 * b0 - a0 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between direction and translation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator*(const direction_t& a, const translation_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between direction and even  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const direction_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b1 + a1 * b2 + a2 * b3;
    res.d[4] = a0 * b0 + a2 * b2 - a1 * b3;
    res.d[5] = a0 * b3 + a1 * b0 - a2 * b1;
    res.d[6] = a1 * b1 + a2 * b0 - a0 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between direction and odd  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const direction_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b7 = b.d[7];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a0 * b7 + a1 * b2 - a2 * b1;
    res.d[5] = a1 * b7 + a2 * b0 - a0 * b2;
    res.d[6] = a0 * b1 + a2 * b7 - a1 * b0;
    res.d[7] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ebivector and scalar  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator*(const ebivector_t& a, const scalar_t& b) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ebivector and vector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const ebivector_t& a, const vector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = 0.0;
    res.d[4] = -a0 * b3;
    res.d[5] = -a1 * b3;
    res.d[6] = -a2 * b3;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ebivector and bivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 18 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const ebivector_t& a, const bivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = -a0 * b0 - a1 * b1 - a2 * b2;
    res.d[1] = a2 * b1 - a1 * b2;
    res.d[2] = a0 * b2 - a2 * b0;
    res.d[3] = a1 * b0 - a0 * b1;
    res.d[4] = a2 * b4 - a1 * b5;
    res.d[5] = a0 * b5 - a2 * b3;
    res.d[6] = a1 * b3 - a0 * b4;
    res.d[7] = a0 * b3 + a1 * b4 + a2 * b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ebivector and trivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const ebivector_t& a, const trivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a0 * b3;
    res.d[1] = -a1 * b3;
    res.d[2] = -a2 * b3;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ebivector and quadvector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₁₂₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator*(const ebivector_t& a, const quadvector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = -a0 * b0;
    res.d[1] = -a1 * b0;
    res.d[2] = -a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ebivector and horizon  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// 1 e₀
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator*(const ebivector_t& a, const horizon_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ebivector and origin  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator*(const ebivector_t& a, const origin_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ebivector and point  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 9 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const ebivector_t& a, const point_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ebivector and direction  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const ebivector_t& a, const direction_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ebivector and ebivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator*(const ebivector_t& a, const ebivector_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0 * b0 - a1 * b1 - a2 * b2;
    res.d[1] = a2 * b1 - a1 * b2;
    res.d[2] = a0 * b2 - a2 * b0;
    res.d[3] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ebivector and ibivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const ebivector_t& a, const ibivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ebivector and evector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const ebivector_t& a, const evector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = 0.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ebivector and dpoint  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 9 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const ebivector_t& a, const dpoint_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = 0.0;
    res.d[4] = -a0;
    res.d[5] = -a1;
    res.d[6] = -a2;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ebivector and rotation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 12 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator*(const ebivector_t& a, const rotation_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a0 * b1 - a1 * b2 - a2 * b3;
    res.d[1] = a0 * b0 + a2 * b2 - a1 * b3;
    res.d[2] = a0 * b3 + a1 * b0 - a2 * b1;
    res.d[3] = a1 * b1 + a2 * b0 - a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ebivector and translation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const ebivector_t& a, const translation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = a0;
    res.d[2] = a1;
    res.d[3] = a2;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ebivector and even  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 24 muls / 17 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const ebivector_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = -a0 * b1 - a1 * b2 - a2 * b3;
    res.d[1] = a0 * b0 + a2 * b2 - a1 * b3;
    res.d[2] = a0 * b3 + a1 * b0 - a2 * b1;
    res.d[3] = a1 * b1 + a2 * b0 - a0 * b2;
    res.d[4] = a2 * b5 - a0 * b7 - a1 * b6;
    res.d[5] = a0 * b6 - a1 * b7 - a2 * b4;
    res.d[6] = a1 * b4 - a0 * b5 - a2 * b7;
    res.d[7] = a0 * b4 + a1 * b5 + a2 * b6;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ebivector and odd  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 24 muls / 16 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const ebivector_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a2 * b1 - a0 * b7 - a1 * b2;
    res.d[1] = a0 * b2 - a1 * b7 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1 - a2 * b7;
    res.d[3] = a0 * b4 + a1 * b5 + a2 * b6;
    res.d[4] = a2 * b5 - a0 * b3 - a1 * b6;
    res.d[5] = a0 * b6 - a1 * b3 - a2 * b4;
    res.d[6] = a1 * b4 - a0 * b5 - a2 * b3;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ibivector and scalar  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator*(const ibivector_t& a, const scalar_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ibivector and vector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const ibivector_t& a, const vector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ibivector and bivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const ibivector_t& a, const bivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ibivector and trivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator*(const ibivector_t& a, const trivector_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b3 = b.d[3];
    res.d[0] = -a0 * b3;
    res.d[1] = -a1 * b3;
    res.d[2] = -a2 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ibivector and quadvector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator*(const ibivector_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// gp between ibivector and horizon  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator*(const ibivector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// gp between ibivector and origin  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator*(const ibivector_t& a, const origin_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ibivector and point  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator*(const ibivector_t& a, const point_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ibivector and direction  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator*(const ibivector_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// gp between ibivector and ebivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const ibivector_t& a, const ebivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ibivector and ibivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator*(const ibivector_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// gp between ibivector and evector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const ibivector_t& a, const evector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ibivector and dpoint  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const ibivector_t& a, const dpoint_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ibivector and rotation  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const ibivector_t& a, const rotation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a0 * b0 + a2 * b2 - a1 * b3;
    res.d[5] = a0 * b3 + a1 * b0 - a2 * b1;
    res.d[6] = a1 * b1 + a2 * b0 - a0 * b2;
    res.d[7] = a0 * b1 + a1 * b2 + a2 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ibivector and translation  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator*(const ibivector_t& a, const translation_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ibivector and even  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const ibivector_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a0 * b0 + a2 * b2 - a1 * b3;
    res.d[5] = a0 * b3 + a1 * b0 - a2 * b1;
    res.d[6] = a1 * b1 + a2 * b0 - a0 * b2;
    res.d[7] = a0 * b1 + a1 * b2 + a2 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between ibivector and odd  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const ibivector_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b7 = b.d[7];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[4] = a2 * b1 - a0 * b7 - a1 * b2;
    res.d[5] = a0 * b2 - a1 * b7 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1 - a2 * b7;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between evector and scalar  
// a0 e₁ + a1 e₂ + a2 e₃
// b
// -> r0 e₁ + r1 e₂ + r2 e₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator*(const evector_t& a, const scalar_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between evector and vector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const evector_t& a, const vector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[1] = a1 * b2 - a2 * b1;
    res.d[2] = a2 * b0 - a0 * b2;
    res.d[3] = a0 * b1 - a1 * b0;
    res.d[4] = -a0 * b3;
    res.d[5] = -a1 * b3;
    res.d[6] = -a2 * b3;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between evector and bivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 18 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const evector_t& a, const bivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = -a0 * b3 - a1 * b4 - a2 * b5;
    res.d[4] = a1 * b5 - a2 * b4;
    res.d[5] = a2 * b3 - a0 * b5;
    res.d[6] = a0 * b4 - a1 * b3;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between evector and trivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const evector_t& a, const trivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = a0 * b3;
    res.d[2] = a1 * b3;
    res.d[3] = a2 * b3;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between evector and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator*(const evector_t& a, const quadvector_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between evector and horizon  
// a0 e₁ + a1 e₂ + a2 e₃
// 1 e₀
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator*(const evector_t& a, const horizon_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between evector and origin  
// a0 e₁ + a1 e₂ + a2 e₃
// 1 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator*(const evector_t& a, const origin_t& b) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between evector and point  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const evector_t& a, const point_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = a0;
    res.d[2] = a1;
    res.d[3] = a2;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between evector and direction  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const evector_t& a, const direction_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between evector and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const evector_t& a, const ebivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = 0.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between evector and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const evector_t& a, const ibivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    res.d[4] = a1 * b2 - a2 * b1;
    res.d[5] = a2 * b0 - a0 * b2;
    res.d[6] = a0 * b1 - a1 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between evector and evector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator*(const evector_t& a, const evector_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[1] = a1 * b2 - a2 * b1;
    res.d[2] = a2 * b0 - a0 * b2;
    res.d[3] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between evector and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const evector_t& a, const dpoint_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[1] = a1 * b2 - a2 * b1;
    res.d[2] = a2 * b0 - a0 * b2;
    res.d[3] = a0 * b1 - a1 * b0;
    res.d[4] = -a0;
    res.d[5] = -a1;
    res.d[6] = -a2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between evector and rotation  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const evector_t& a, const rotation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0 + a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 + a1 * b0 - a2 * b1;
    res.d[2] = a1 * b1 + a2 * b0 - a0 * b2;
    res.d[3] = 0.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = a0 * b1 + a1 * b2 + a2 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between evector and translation  
// a0 e₁ + a1 e₂ + a2 e₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const evector_t& a, const translation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    res.d[4] = a1 * b2 - a2 * b1;
    res.d[5] = a2 * b0 - a0 * b2;
    res.d[6] = a0 * b1 - a1 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between evector and even  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 24 muls / 17 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const evector_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0 + a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 + a1 * b0 - a2 * b1;
    res.d[2] = a1 * b1 + a2 * b0 - a0 * b2;
    res.d[3] = -a0 * b4 - a1 * b5 - a2 * b6;
    res.d[4] = a0 * b7 + a1 * b6 - a2 * b5;
    res.d[5] = a1 * b7 + a2 * b4 - a0 * b6;
    res.d[6] = a0 * b5 + a2 * b7 - a1 * b4;
    res.d[7] = a0 * b1 + a1 * b2 + a2 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between evector and odd  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 24 muls / 16 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const evector_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[1] = a0 * b7 + a1 * b2 - a2 * b1;
    res.d[2] = a1 * b7 + a2 * b0 - a0 * b2;
    res.d[3] = a0 * b1 + a2 * b7 - a1 * b0;
    res.d[4] = a2 * b5 - a0 * b3 - a1 * b6;
    res.d[5] = a0 * b6 - a1 * b3 - a2 * b4;
    res.d[6] = a1 * b4 - a0 * b5 - a2 * b3;
    res.d[7] = a0 * b4 + a1 * b5 + a2 * b6;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between dpoint and scalar  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator*(const dpoint_t& a, const scalar_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    res.d[3] = b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between dpoint and vector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const dpoint_t& a, const vector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[1] = a1 * b2 - a2 * b1;
    res.d[2] = a2 * b0 - a0 * b2;
    res.d[3] = a0 * b1 - a1 * b0;
    res.d[4] = b0 - a0 * b3;
    res.d[5] = b1 - a1 * b3;
    res.d[6] = b2 - a2 * b3;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between dpoint and bivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 18 muls / 14 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const dpoint_t& a, const bivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = -a0 * b3 - a1 * b4 - a2 * b5;
    res.d[4] = a1 * b5 - a2 * b4 - b0;
    res.d[5] = a2 * b3 - a0 * b5 - b1;
    res.d[6] = a0 * b4 - a1 * b3 - b2;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between dpoint and trivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const dpoint_t& a, const trivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = a0 * b3;
    res.d[2] = a1 * b3;
    res.d[3] = a2 * b3;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2 + b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between dpoint and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator*(const dpoint_t& a, const quadvector_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between dpoint and horizon  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// 1 e₀
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator*(const dpoint_t& a, const horizon_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between dpoint and origin  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// 1 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const dpoint_t& a, const origin_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = 0.0;
    res.d[1] = a0;
    res.d[2] = a1;
    res.d[3] = a2;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between dpoint and point  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const dpoint_t& a, const point_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = a0;
    res.d[2] = a1;
    res.d[3] = a2;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = 1 + a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between dpoint and direction  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const dpoint_t& a, const direction_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between dpoint and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 9 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const dpoint_t& a, const ebivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = 0.0;
    res.d[4] = -b0;
    res.d[5] = -b1;
    res.d[6] = -b2;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between dpoint and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const dpoint_t& a, const ibivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    res.d[4] = a1 * b2 - a2 * b1;
    res.d[5] = a2 * b0 - a0 * b2;
    res.d[6] = a0 * b1 - a1 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between dpoint and evector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const dpoint_t& a, const evector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[1] = a1 * b2 - a2 * b1;
    res.d[2] = a2 * b0 - a0 * b2;
    res.d[3] = a0 * b1 - a1 * b0;
    res.d[4] = b0;
    res.d[5] = b1;
    res.d[6] = b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between dpoint and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const dpoint_t& a, const dpoint_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[1] = a1 * b2 - a2 * b1;
    res.d[2] = a2 * b0 - a0 * b2;
    res.d[3] = a0 * b1 - a1 * b0;
    res.d[4] = b0 - a0;
    res.d[5] = b1 - a1;
    res.d[6] = b2 - a2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between dpoint and rotation  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const dpoint_t& a, const rotation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0 + a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 + a1 * b0 - a2 * b1;
    res.d[2] = a1 * b1 + a2 * b0 - a0 * b2;
    res.d[3] = b0;
    res.d[4] = -b1;
    res.d[5] = -b2;
    res.d[6] = -b3;
    res.d[7] = a0 * b1 + a1 * b2 + a2 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between dpoint and translation  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const dpoint_t& a, const translation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = 1 - a0 * b0 - a1 * b1 - a2 * b2;
    res.d[4] = a1 * b2 - a2 * b1;
    res.d[5] = a2 * b0 - a0 * b2;
    res.d[6] = a0 * b1 - a1 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between dpoint and even  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 24 muls / 20 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const dpoint_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0 + a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 + a1 * b0 - a2 * b1;
    res.d[2] = a1 * b1 + a2 * b0 - a0 * b2;
    res.d[3] = b0 - a0 * b4 - a1 * b5 - a2 * b6;
    res.d[4] = a0 * b7 + a1 * b6 - a2 * b5 - b1;
    res.d[5] = a1 * b7 + a2 * b4 - a0 * b6 - b2;
    res.d[6] = a0 * b5 + a2 * b7 - a1 * b4 - b3;
    res.d[7] = a0 * b1 + a1 * b2 + a2 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between dpoint and odd  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 24 muls / 20 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const dpoint_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[1] = a0 * b7 + a1 * b2 - a2 * b1;
    res.d[2] = a1 * b7 + a2 * b0 - a0 * b2;
    res.d[3] = a0 * b1 + a2 * b7 - a1 * b0;
    res.d[4] = a2 * b5 + b0 - a0 * b3 - a1 * b6;
    res.d[5] = a0 * b6 + b1 - a1 * b3 - a2 * b4;
    res.d[6] = a1 * b4 + b2 - a0 * b5 - a2 * b3;
    res.d[7] = a0 * b4 + a1 * b5 + a2 * b6 + b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between rotation and scalar  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator*(const rotation_t& a, const scalar_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    res.d[3] = a3 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between rotation and vector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 16 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const rotation_t& a, const vector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0 + a3 * b1 - a2 * b2;
    res.d[1] = a0 * b1 + a1 * b2 - a3 * b0;
    res.d[2] = a0 * b2 + a2 * b0 - a1 * b1;
    res.d[3] = a0 * b3;
    res.d[4] = -a1 * b3;
    res.d[5] = -a2 * b3;
    res.d[6] = -a3 * b3;
    res.d[7] = a1 * b0 + a2 * b1 + a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between rotation and bivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 24 muls / 17 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const rotation_t& a, const bivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = -a1 * b0 - a2 * b1 - a3 * b2;
    res.d[1] = a0 * b0 + a3 * b1 - a2 * b2;
    res.d[2] = a0 * b1 + a1 * b2 - a3 * b0;
    res.d[3] = a0 * b2 + a2 * b0 - a1 * b1;
    res.d[4] = a0 * b3 + a3 * b4 - a2 * b5;
    res.d[5] = a0 * b4 + a1 * b5 - a3 * b3;
    res.d[6] = a0 * b5 + a2 * b3 - a1 * b4;
    res.d[7] = a1 * b3 + a2 * b4 + a3 * b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between rotation and trivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 16 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const rotation_t& a, const trivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a1 * b3;
    res.d[1] = -a2 * b3;
    res.d[2] = -a3 * b3;
    res.d[3] = a1 * b0 + a2 * b1 + a3 * b2;
    res.d[4] = a0 * b0 + a3 * b1 - a2 * b2;
    res.d[5] = a0 * b1 + a1 * b2 - a3 * b0;
    res.d[6] = a0 * b2 + a2 * b0 - a1 * b1;
    res.d[7] = a0 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between rotation and quadvector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 4 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const rotation_t& a, const quadvector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = -a1 * b0;
    res.d[5] = -a2 * b0;
    res.d[6] = -a3 * b0;
    res.d[7] = a0 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between rotation and horizon  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const rotation_t& a, const horizon_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0;
    res.d[4] = -a1;
    res.d[5] = -a2;
    res.d[6] = -a3;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between rotation and origin  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const rotation_t& a, const origin_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = -a1;
    res.d[1] = -a2;
    res.d[2] = -a3;
    res.d[3] = 0.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between rotation and point  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const rotation_t& a, const point_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a1;
    res.d[1] = -a2;
    res.d[2] = -a3;
    res.d[3] = a1 * b0 + a2 * b1 + a3 * b2;
    res.d[4] = a0 * b0 + a3 * b1 - a2 * b2;
    res.d[5] = a0 * b1 + a1 * b2 - a3 * b0;
    res.d[6] = a0 * b2 + a2 * b0 - a1 * b1;
    res.d[7] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between rotation and direction  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const rotation_t& a, const direction_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a1 * b0 + a2 * b1 + a3 * b2;
    res.d[4] = a0 * b0 + a3 * b1 - a2 * b2;
    res.d[5] = a0 * b1 + a1 * b2 - a3 * b0;
    res.d[6] = a0 * b2 + a2 * b0 - a1 * b1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between rotation and ebivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 12 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator*(const rotation_t& a, const ebivector_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a1 * b0 - a2 * b1 - a3 * b2;
    res.d[1] = a0 * b0 + a3 * b1 - a2 * b2;
    res.d[2] = a0 * b1 + a1 * b2 - a3 * b0;
    res.d[3] = a0 * b2 + a2 * b0 - a1 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between rotation and ibivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const rotation_t& a, const ibivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a0 * b0 + a3 * b1 - a2 * b2;
    res.d[5] = a0 * b1 + a1 * b2 - a3 * b0;
    res.d[6] = a0 * b2 + a2 * b0 - a1 * b1;
    res.d[7] = a1 * b0 + a2 * b1 + a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between rotation and evector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const rotation_t& a, const evector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a3 * b1 - a2 * b2;
    res.d[1] = a0 * b1 + a1 * b2 - a3 * b0;
    res.d[2] = a0 * b2 + a2 * b0 - a1 * b1;
    res.d[3] = 0.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = a1 * b0 + a2 * b1 + a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between rotation and dpoint  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const rotation_t& a, const dpoint_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a3 * b1 - a2 * b2;
    res.d[1] = a0 * b1 + a1 * b2 - a3 * b0;
    res.d[2] = a0 * b2 + a2 * b0 - a1 * b1;
    res.d[3] = a0;
    res.d[4] = -a1;
    res.d[5] = -a2;
    res.d[6] = -a3;
    res.d[7] = a1 * b0 + a2 * b1 + a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between rotation and rotation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 16 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator*(const rotation_t& a, const rotation_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0 - a1 * b1 - a2 * b2 - a3 * b3;
    res.d[1] = a0 * b1 + a1 * b0 + a3 * b2 - a2 * b3;
    res.d[2] = a0 * b2 + a1 * b3 + a2 * b0 - a3 * b1;
    res.d[3] = a0 * b3 + a2 * b1 + a3 * b0 - a1 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between rotation and translation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const rotation_t& a, const translation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a3;
    res.d[4] = a0 * b0 + a3 * b1 - a2 * b2;
    res.d[5] = a0 * b1 + a1 * b2 - a3 * b0;
    res.d[6] = a0 * b2 + a2 * b0 - a1 * b1;
    res.d[7] = a1 * b0 + a2 * b1 + a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between rotation and even  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 32 muls / 24 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const rotation_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0 - a1 * b1 - a2 * b2 - a3 * b3;
    res.d[1] = a0 * b1 + a1 * b0 + a3 * b2 - a2 * b3;
    res.d[2] = a0 * b2 + a1 * b3 + a2 * b0 - a3 * b1;
    res.d[3] = a0 * b3 + a2 * b1 + a3 * b0 - a1 * b2;
    res.d[4] = a0 * b4 + a3 * b5 - a1 * b7 - a2 * b6;
    res.d[5] = a0 * b5 + a1 * b6 - a2 * b7 - a3 * b4;
    res.d[6] = a0 * b6 + a2 * b4 - a1 * b5 - a3 * b7;
    res.d[7] = a0 * b7 + a1 * b4 + a2 * b5 + a3 * b6;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between rotation and odd  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 32 muls / 24 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const rotation_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0 + a3 * b1 - a1 * b7 - a2 * b2;
    res.d[1] = a0 * b1 + a1 * b2 - a2 * b7 - a3 * b0;
    res.d[2] = a0 * b2 + a2 * b0 - a1 * b1 - a3 * b7;
    res.d[3] = a0 * b3 + a1 * b4 + a2 * b5 + a3 * b6;
    res.d[4] = a0 * b4 + a3 * b5 - a1 * b3 - a2 * b6;
    res.d[5] = a0 * b5 + a1 * b6 - a2 * b3 - a3 * b4;
    res.d[6] = a0 * b6 + a2 * b4 - a1 * b5 - a3 * b3;
    res.d[7] = a0 * b7 + a1 * b0 + a2 * b1 + a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between translation and scalar  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const translation_t& a, const scalar_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = b;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a0 * b;
    res.d[5] = a1 * b;
    res.d[6] = a2 * b;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between translation and vector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const translation_t& a, const vector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2 + b3;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between translation and bivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const translation_t& a, const bivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = 0.0;
    res.d[1] = b0;
    res.d[2] = b1;
    res.d[3] = b2;
    res.d[4] = a2 * b1 + b3 - a1 * b2;
    res.d[5] = a0 * b2 + b4 - a2 * b0;
    res.d[6] = a1 * b0 + b5 - a0 * b1;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between translation and trivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator*(const translation_t& a, const trivector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0 - a0 * b3;
    res.d[1] = b1 - a1 * b3;
    res.d[2] = b2 - a2 * b3;
    res.d[3] = b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between translation and quadvector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator*(const translation_t& a, const quadvector_t& b) {
    quadvector_t res;
    const float b0 = b.d[0];
    res.d[0] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between translation and horizon  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline horizon_t operator*(const translation_t& a, const horizon_t& b) {

    return horizon_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// gp between translation and origin  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t operator*(const translation_t& a, const origin_t& b) {
    point_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between translation and point  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t operator*(const translation_t& a, const point_t& b) {
    point_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0 - a0;
    res.d[1] = b1 - a1;
    res.d[2] = b2 - a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between translation and direction  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator*(const translation_t& a, const direction_t& b) {
    direction_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between translation and ebivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const translation_t& a, const ebivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = b0;
    res.d[2] = b1;
    res.d[3] = b2;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between translation and ibivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator*(const translation_t& a, const ibivector_t& b) {
    ibivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between translation and evector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const translation_t& a, const evector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between translation and dpoint  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const translation_t& a, const dpoint_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = 1 + a0 * b0 + a1 * b1 + a2 * b2;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between translation and rotation  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const translation_t& a, const rotation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    res.d[4] = a0 * b0 + a2 * b2 - a1 * b3;
    res.d[5] = a0 * b3 + a1 * b0 - a2 * b1;
    res.d[6] = a1 * b1 + a2 * b0 - a0 * b2;
    res.d[7] = a0 * b1 + a1 * b2 + a2 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between translation and translation  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline translation_t operator*(const translation_t& a, const translation_t& b) {
    translation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 + b0;
    res.d[1] = a1 + b1;
    res.d[2] = a2 + b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between translation and even  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const translation_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    res.d[4] = a0 * b0 + a2 * b2 + b4 - a1 * b3;
    res.d[5] = a0 * b3 + a1 * b0 + b5 - a2 * b1;
    res.d[6] = a1 * b1 + a2 * b0 + b6 - a0 * b2;
    res.d[7] = a0 * b1 + a1 * b2 + a2 * b3 + b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between translation and odd  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const translation_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2 + b3;
    res.d[4] = a2 * b1 + b4 - a0 * b7 - a1 * b2;
    res.d[5] = a0 * b2 + b5 - a1 * b7 - a2 * b0;
    res.d[6] = a1 * b0 + b6 - a0 * b1 - a2 * b7;
    res.d[7] = b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between even and scalar  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 8 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const even_t& a, const scalar_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    res.d[3] = a3 * b;
    res.d[4] = a4 * b;
    res.d[5] = a5 * b;
    res.d[6] = a6 * b;
    res.d[7] = a7 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between even and vector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 28 muls / 20 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const even_t& a, const vector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0 + a3 * b1 - a2 * b2;
    res.d[1] = a0 * b1 + a1 * b2 - a3 * b0;
    res.d[2] = a0 * b2 + a2 * b0 - a1 * b1;
    res.d[3] = a0 * b3 + a4 * b0 + a5 * b1 + a6 * b2;
    res.d[4] = a6 * b1 - a1 * b3 - a5 * b2 - a7 * b0;
    res.d[5] = a4 * b2 - a2 * b3 - a6 * b0 - a7 * b1;
    res.d[6] = a5 * b0 - a3 * b3 - a4 * b1 - a7 * b2;
    res.d[7] = a1 * b0 + a2 * b1 + a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between even and bivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 36 muls / 29 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const even_t& a, const bivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = -a1 * b0 - a2 * b1 - a3 * b2;
    res.d[1] = a0 * b0 + a3 * b1 - a2 * b2;
    res.d[2] = a0 * b1 + a1 * b2 - a3 * b0;
    res.d[3] = a0 * b2 + a2 * b0 - a1 * b1;
    res.d[4] = a0 * b3 + a3 * b4 + a6 * b1 - a2 * b5 - a5 * b2 - a7 * b0;
    res.d[5] = a0 * b4 + a1 * b5 + a4 * b2 - a3 * b3 - a6 * b0 - a7 * b1;
    res.d[6] = a0 * b5 + a2 * b3 + a5 * b0 - a1 * b4 - a4 * b1 - a7 * b2;
    res.d[7] = a1 * b3 + a2 * b4 + a3 * b5 + a4 * b0 + a5 * b1 + a6 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between even and trivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 20 muls / 15 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const even_t& a, const trivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a1 * b3;
    res.d[1] = -a2 * b3;
    res.d[2] = -a3 * b3;
    res.d[3] = a1 * b0 + a2 * b1 + a3 * b2 - a7 * b3;
    res.d[4] = a0 * b0 + a3 * b1 - a2 * b2 - a4 * b3;
    res.d[5] = a0 * b1 + a1 * b2 - a3 * b0 - a5 * b3;
    res.d[6] = a0 * b2 + a2 * b0 - a1 * b1 - a6 * b3;
    res.d[7] = a0 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between even and quadvector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 4 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const even_t& a, const quadvector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = -a1 * b0;
    res.d[5] = -a2 * b0;
    res.d[6] = -a3 * b0;
    res.d[7] = a0 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between even and horizon  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const even_t& a, const horizon_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0;
    res.d[4] = -a1;
    res.d[5] = -a2;
    res.d[6] = -a3;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between even and origin  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 7 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const even_t& a, const origin_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7];
    res.d[0] = -a1;
    res.d[1] = -a2;
    res.d[2] = -a3;
    res.d[3] = -a7;
    res.d[4] = -a4;
    res.d[5] = -a5;
    res.d[6] = -a6;
    res.d[7] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between even and point  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 15 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const even_t& a, const point_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a1;
    res.d[1] = -a2;
    res.d[2] = -a3;
    res.d[3] = a1 * b0 + a2 * b1 + a3 * b2 - a7;
    res.d[4] = a0 * b0 + a3 * b1 - a2 * b2 - a4;
    res.d[5] = a0 * b1 + a1 * b2 - a3 * b0 - a5;
    res.d[6] = a0 * b2 + a2 * b0 - a1 * b1 - a6;
    res.d[7] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between even and direction  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const even_t& a, const direction_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a1 * b0 + a2 * b1 + a3 * b2;
    res.d[4] = a0 * b0 + a3 * b1 - a2 * b2;
    res.d[5] = a0 * b1 + a1 * b2 - a3 * b0;
    res.d[6] = a0 * b2 + a2 * b0 - a1 * b1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between even and ebivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 24 muls / 17 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const even_t& a, const ebivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a1 * b0 - a2 * b1 - a3 * b2;
    res.d[1] = a0 * b0 + a3 * b1 - a2 * b2;
    res.d[2] = a0 * b1 + a1 * b2 - a3 * b0;
    res.d[3] = a0 * b2 + a2 * b0 - a1 * b1;
    res.d[4] = a6 * b1 - a5 * b2 - a7 * b0;
    res.d[5] = a4 * b2 - a6 * b0 - a7 * b1;
    res.d[6] = a5 * b0 - a4 * b1 - a7 * b2;
    res.d[7] = a4 * b0 + a5 * b1 + a6 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between even and ibivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const even_t& a, const ibivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a0 * b0 + a3 * b1 - a2 * b2;
    res.d[5] = a0 * b1 + a1 * b2 - a3 * b0;
    res.d[6] = a0 * b2 + a2 * b0 - a1 * b1;
    res.d[7] = a1 * b0 + a2 * b1 + a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between even and evector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 24 muls / 16 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const even_t& a, const evector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a3 * b1 - a2 * b2;
    res.d[1] = a0 * b1 + a1 * b2 - a3 * b0;
    res.d[2] = a0 * b2 + a2 * b0 - a1 * b1;
    res.d[3] = a4 * b0 + a5 * b1 + a6 * b2;
    res.d[4] = a6 * b1 - a5 * b2 - a7 * b0;
    res.d[5] = a4 * b2 - a6 * b0 - a7 * b1;
    res.d[6] = a5 * b0 - a4 * b1 - a7 * b2;
    res.d[7] = a1 * b0 + a2 * b1 + a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between even and dpoint  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 24 muls / 20 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const even_t& a, const dpoint_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a3 * b1 - a2 * b2;
    res.d[1] = a0 * b1 + a1 * b2 - a3 * b0;
    res.d[2] = a0 * b2 + a2 * b0 - a1 * b1;
    res.d[3] = a0 + a4 * b0 + a5 * b1 + a6 * b2;
    res.d[4] = a6 * b1 - a1 - a5 * b2 - a7 * b0;
    res.d[5] = a4 * b2 - a2 - a6 * b0 - a7 * b1;
    res.d[6] = a5 * b0 - a3 - a4 * b1 - a7 * b2;
    res.d[7] = a1 * b0 + a2 * b1 + a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between even and rotation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 32 muls / 24 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const even_t& a, const rotation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0 - a1 * b1 - a2 * b2 - a3 * b3;
    res.d[1] = a0 * b1 + a1 * b0 + a3 * b2 - a2 * b3;
    res.d[2] = a0 * b2 + a1 * b3 + a2 * b0 - a3 * b1;
    res.d[3] = a0 * b3 + a2 * b1 + a3 * b0 - a1 * b2;
    res.d[4] = a4 * b0 + a6 * b2 - a5 * b3 - a7 * b1;
    res.d[5] = a4 * b3 + a5 * b0 - a6 * b1 - a7 * b2;
    res.d[6] = a5 * b1 + a6 * b0 - a4 * b2 - a7 * b3;
    res.d[7] = a4 * b1 + a5 * b2 + a6 * b3 + a7 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between even and translation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const even_t& a, const translation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a3;
    res.d[4] = a0 * b0 + a3 * b1 + a4 - a2 * b2;
    res.d[5] = a0 * b1 + a1 * b2 + a5 - a3 * b0;
    res.d[6] = a0 * b2 + a2 * b0 + a6 - a1 * b1;
    res.d[7] = a1 * b0 + a2 * b1 + a3 * b2 + a7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between even and even  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 48 muls / 40 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const even_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0 - a1 * b1 - a2 * b2 - a3 * b3;
    res.d[1] = a0 * b1 + a1 * b0 + a3 * b2 - a2 * b3;
    res.d[2] = a0 * b2 + a1 * b3 + a2 * b0 - a3 * b1;
    res.d[3] = a0 * b3 + a2 * b1 + a3 * b0 - a1 * b2;
    res.d[4] = a0 * b4 + a3 * b5 + a4 * b0 + a6 * b2 - a1 * b7 - a2 * b6 - a5 * b3 - a7 * b1;
    res.d[5] = a0 * b5 + a1 * b6 + a4 * b3 + a5 * b0 - a2 * b7 - a3 * b4 - a6 * b1 - a7 * b2;
    res.d[6] = a0 * b6 + a2 * b4 + a5 * b1 + a6 * b0 - a1 * b5 - a3 * b7 - a4 * b2 - a7 * b3;
    res.d[7] = a0 * b7 + a1 * b4 + a2 * b5 + a3 * b6 + a4 * b1 + a5 * b2 + a6 * b3 + a7 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between even and odd  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 48 muls / 40 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const even_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0 + a3 * b1 - a1 * b7 - a2 * b2;
    res.d[1] = a0 * b1 + a1 * b2 - a2 * b7 - a3 * b0;
    res.d[2] = a0 * b2 + a2 * b0 - a1 * b1 - a3 * b7;
    res.d[3] = a0 * b3 + a1 * b4 + a2 * b5 + a3 * b6 + a4 * b0 + a5 * b1 + a6 * b2 - a7 * b7;
    res.d[4] = a0 * b4 + a3 * b5 + a6 * b1 - a1 * b3 - a2 * b6 - a4 * b7 - a5 * b2 - a7 * b0;
    res.d[5] = a0 * b5 + a1 * b6 + a4 * b2 - a2 * b3 - a3 * b4 - a5 * b7 - a6 * b0 - a7 * b1;
    res.d[6] = a0 * b6 + a2 * b4 + a5 * b0 - a1 * b5 - a3 * b3 - a4 * b1 - a6 * b7 - a7 * b2;
    res.d[7] = a0 * b7 + a1 * b0 + a2 * b1 + a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between odd and scalar  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 8 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const odd_t& a, const scalar_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    res.d[3] = a3 * b;
    res.d[4] = a4 * b;
    res.d[5] = a5 * b;
    res.d[6] = a6 * b;
    res.d[7] = a7 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between odd and vector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 28 muls / 21 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const odd_t& a, const vector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[1] = a1 * b2 + a7 * b0 - a2 * b1;
    res.d[2] = a2 * b0 + a7 * b1 - a0 * b2;
    res.d[3] = a0 * b1 + a7 * b2 - a1 * b0;
    res.d[4] = a3 * b0 + a5 * b2 - a0 * b3 - a6 * b1;
    res.d[5] = a3 * b1 + a6 * b0 - a1 * b3 - a4 * b2;
    res.d[6] = a3 * b2 + a4 * b1 - a2 * b3 - a5 * b0;
    res.d[7] = -a4 * b0 - a5 * b1 - a6 * b2 - a7 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between odd and bivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 36 muls / 28 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const odd_t& a, const bivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a2 * b1 - a1 * b2 - a7 * b0;
    res.d[1] = a0 * b2 - a2 * b0 - a7 * b1;
    res.d[2] = a1 * b0 - a0 * b1 - a7 * b2;
    res.d[3] = a4 * b0 + a5 * b1 + a6 * b2 - a0 * b3 - a1 * b4 - a2 * b5;
    res.d[4] = a1 * b5 + a6 * b1 + a7 * b3 - a2 * b4 - a3 * b0 - a5 * b2;
    res.d[5] = a2 * b3 + a4 * b2 + a7 * b4 - a0 * b5 - a3 * b1 - a6 * b0;
    res.d[6] = a0 * b4 + a5 * b0 + a7 * b5 - a1 * b3 - a3 * b2 - a4 * b1;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between odd and trivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 20 muls / 13 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const odd_t& a, const trivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a7 * b3;
    res.d[1] = a0 * b3;
    res.d[2] = a1 * b3;
    res.d[3] = a2 * b3;
    res.d[4] = a2 * b1 + a4 * b3 - a1 * b2 - a7 * b0;
    res.d[5] = a0 * b2 + a5 * b3 - a2 * b0 - a7 * b1;
    res.d[6] = a1 * b0 + a6 * b3 - a0 * b1 - a7 * b2;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between odd and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const odd_t& a, const quadvector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a7 = a.d[7], b0 = b.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a7 * b0;
    res.d[4] = a0 * b0;
    res.d[5] = a1 * b0;
    res.d[6] = a2 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between odd and horizon  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// 1 e₀
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const odd_t& a, const horizon_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a7 = a.d[7];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = -a0;
    res.d[5] = -a1;
    res.d[6] = -a2;
    res.d[7] = -a7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between odd and origin  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// 1 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const odd_t& a, const origin_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7];
    res.d[0] = -a7;
    res.d[1] = a0;
    res.d[2] = a1;
    res.d[3] = a2;
    res.d[4] = a4;
    res.d[5] = a5;
    res.d[6] = a6;
    res.d[7] = a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between odd and point  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 13 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const odd_t& a, const point_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a7;
    res.d[1] = a0;
    res.d[2] = a1;
    res.d[3] = a2;
    res.d[4] = a2 * b1 + a4 - a1 * b2 - a7 * b0;
    res.d[5] = a0 * b2 + a5 - a2 * b0 - a7 * b1;
    res.d[6] = a1 * b0 + a6 - a0 * b1 - a7 * b2;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2 + a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between odd and direction  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const odd_t& a, const direction_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a2 * b1 - a1 * b2 - a7 * b0;
    res.d[5] = a0 * b2 - a2 * b0 - a7 * b1;
    res.d[6] = a1 * b0 - a0 * b1 - a7 * b2;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between odd and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 24 muls / 16 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const odd_t& a, const ebivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2 - a7 * b0;
    res.d[1] = a0 * b2 - a2 * b0 - a7 * b1;
    res.d[2] = a1 * b0 - a0 * b1 - a7 * b2;
    res.d[3] = a4 * b0 + a5 * b1 + a6 * b2;
    res.d[4] = a6 * b1 - a3 * b0 - a5 * b2;
    res.d[5] = a4 * b2 - a3 * b1 - a6 * b0;
    res.d[6] = a5 * b0 - a3 * b2 - a4 * b1;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between odd and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const odd_t& a, const ibivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    res.d[4] = a1 * b2 + a7 * b0 - a2 * b1;
    res.d[5] = a2 * b0 + a7 * b1 - a0 * b2;
    res.d[6] = a0 * b1 + a7 * b2 - a1 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between odd and evector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 24 muls / 17 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const odd_t& a, const evector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[1] = a1 * b2 + a7 * b0 - a2 * b1;
    res.d[2] = a2 * b0 + a7 * b1 - a0 * b2;
    res.d[3] = a0 * b1 + a7 * b2 - a1 * b0;
    res.d[4] = a3 * b0 + a5 * b2 - a6 * b1;
    res.d[5] = a3 * b1 + a6 * b0 - a4 * b2;
    res.d[6] = a3 * b2 + a4 * b1 - a5 * b0;
    res.d[7] = -a4 * b0 - a5 * b1 - a6 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between odd and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 24 muls / 21 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const odd_t& a, const dpoint_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[1] = a1 * b2 + a7 * b0 - a2 * b1;
    res.d[2] = a2 * b0 + a7 * b1 - a0 * b2;
    res.d[3] = a0 * b1 + a7 * b2 - a1 * b0;
    res.d[4] = a3 * b0 + a5 * b2 - a0 - a6 * b1;
    res.d[5] = a3 * b1 + a6 * b0 - a1 - a4 * b2;
    res.d[6] = a3 * b2 + a4 * b1 - a2 - a5 * b0;
    res.d[7] = -a4 * b0 - a5 * b1 - a6 * b2 - a7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between odd and rotation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 32 muls / 24 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const odd_t& a, const rotation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0 + a2 * b2 - a1 * b3 - a7 * b1;
    res.d[1] = a0 * b3 + a1 * b0 - a2 * b1 - a7 * b2;
    res.d[2] = a1 * b1 + a2 * b0 - a0 * b2 - a7 * b3;
    res.d[3] = a3 * b0 + a4 * b1 + a5 * b2 + a6 * b3;
    res.d[4] = a4 * b0 + a6 * b2 - a3 * b1 - a5 * b3;
    res.d[5] = a4 * b3 + a5 * b0 - a3 * b2 - a6 * b1;
    res.d[6] = a5 * b1 + a6 * b0 - a3 * b3 - a4 * b2;
    res.d[7] = a0 * b1 + a1 * b2 + a2 * b3 + a7 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between odd and translation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const odd_t& a, const translation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a3 - a0 * b0 - a1 * b1 - a2 * b2;
    res.d[4] = a1 * b2 + a4 + a7 * b0 - a2 * b1;
    res.d[5] = a2 * b0 + a5 + a7 * b1 - a0 * b2;
    res.d[6] = a0 * b1 + a6 + a7 * b2 - a1 * b0;
    res.d[7] = a7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between odd and even  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 48 muls / 40 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator*(const odd_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0 + a2 * b2 - a1 * b3 - a7 * b1;
    res.d[1] = a0 * b3 + a1 * b0 - a2 * b1 - a7 * b2;
    res.d[2] = a1 * b1 + a2 * b0 - a0 * b2 - a7 * b3;
    res.d[3] = a3 * b0 + a4 * b1 + a5 * b2 + a6 * b3 + a7 * b7 - a0 * b4 - a1 * b5 - a2 * b6;
    res.d[4] = a0 * b7 + a1 * b6 + a4 * b0 + a6 * b2 + a7 * b4 - a2 * b5 - a3 * b1 - a5 * b3;
    res.d[5] = a1 * b7 + a2 * b4 + a4 * b3 + a5 * b0 + a7 * b5 - a0 * b6 - a3 * b2 - a6 * b1;
    res.d[6] = a0 * b5 + a2 * b7 + a5 * b1 + a6 * b0 + a7 * b6 - a1 * b4 - a3 * b3 - a4 * b2;
    res.d[7] = a0 * b1 + a1 * b2 + a2 * b3 + a7 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// gp between odd and odd  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 48 muls / 40 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator*(const odd_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2 - a7 * b7;
    res.d[1] = a0 * b7 + a1 * b2 + a7 * b0 - a2 * b1;
    res.d[2] = a1 * b7 + a2 * b0 + a7 * b1 - a0 * b2;
    res.d[3] = a0 * b1 + a2 * b7 + a7 * b2 - a1 * b0;
    res.d[4] = a2 * b5 + a3 * b0 + a4 * b7 + a5 * b2 - a0 * b3 - a1 * b6 - a6 * b1 - a7 * b4;
    res.d[5] = a0 * b6 + a3 * b1 + a5 * b7 + a6 * b0 - a1 * b3 - a2 * b4 - a4 * b2 - a7 * b5;
    res.d[6] = a1 * b4 + a3 * b2 + a4 * b1 + a6 * b7 - a0 * b5 - a2 * b3 - a5 * b0 - a7 * b6;
    res.d[7] = a0 * b4 + a1 * b5 + a2 * b6 + a3 * b7 - a4 * b0 - a5 * b1 - a6 * b2 - a7 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between scalar and vector  
// a
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator^(const scalar_t& a, const vector_t& b) {
    vector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    res.d[3] = a * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between scalar and bivector  
// a
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 6 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator^(const scalar_t& a, const bivector_t& b) {
    bivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    res.d[3] = a * b3;
    res.d[4] = a * b4;
    res.d[5] = a * b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between scalar and trivector  
// a
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const scalar_t& a, const trivector_t& b) {
    trivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    res.d[3] = a * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between scalar and quadvector  
// a
// b0 e₀₁₂₃
// -> r0 e₀₁₂₃
// 1 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const scalar_t& a, const quadvector_t& b) {
    quadvector_t res;
    const float b0 = b.d[0];
    res.d[0] = a * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between scalar and horizon  
// a
// 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator^(const scalar_t& a, const horizon_t& b) {
    vector_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between scalar and origin  
// a
// 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const scalar_t& a, const origin_t& b) {
    trivector_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between scalar and point  
// a
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const scalar_t& a, const point_t& b) {
    trivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    res.d[3] = a;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between scalar and direction  
// a
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator^(const scalar_t& a, const direction_t& b) {
    direction_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between scalar and ebivector  
// a
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator^(const scalar_t& a, const ebivector_t& b) {
    ebivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between scalar and ibivector  
// a
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator^(const scalar_t& a, const ibivector_t& b) {
    ibivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between scalar and evector  
// a
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator^(const scalar_t& a, const evector_t& b) {
    evector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between scalar and dpoint  
// a
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator^(const scalar_t& a, const dpoint_t& b) {
    vector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    res.d[3] = a;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between scalar and rotation  
// a
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator^(const scalar_t& a, const rotation_t& b) {
    rotation_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    res.d[3] = a * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between scalar and translation  
// a
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator^(const scalar_t& a, const translation_t& b) {
    even_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a * b0;
    res.d[5] = a * b1;
    res.d[6] = a * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between scalar and even  
// a
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 8 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator^(const scalar_t& a, const even_t& b) {
    even_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    res.d[3] = a * b3;
    res.d[4] = a * b4;
    res.d[5] = a * b5;
    res.d[6] = a * b6;
    res.d[7] = a * b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between scalar and odd  
// a
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 8 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator^(const scalar_t& a, const odd_t& b) {
    odd_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    res.d[3] = a * b3;
    res.d[4] = a * b4;
    res.d[5] = a * b5;
    res.d[6] = a * b6;
    res.d[7] = a * b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between vector and scalar  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator^(const vector_t& a, const scalar_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    res.d[3] = a3 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between vector and vector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 12 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator^(const vector_t& a, const vector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    res.d[3] = a3 * b0 - a0 * b3;
    res.d[4] = a3 * b1 - a1 * b3;
    res.d[5] = a3 * b2 - a2 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between vector and bivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const vector_t& a, const bivector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a1 * b5 - a2 * b4 - a3 * b0;
    res.d[1] = a2 * b3 - a0 * b5 - a3 * b1;
    res.d[2] = a0 * b4 - a1 * b3 - a3 * b2;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between vector and trivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₁₂₃
// 4 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const vector_t& a, const trivector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between vector and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const vector_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between vector and horizon  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// 1 e₀
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator^(const vector_t& a, const horizon_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between vector and origin  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// 1 e₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const vector_t& a, const origin_t& b) {
    quadvector_t res;
    const float a3 = a.d[3];
    res.d[0] = a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between vector and point  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₁₂₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const vector_t& a, const point_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2 + a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between vector and direction  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₁₂₃
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const vector_t& a, const direction_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between vector and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 6 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const vector_t& a, const ebivector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a3 * b0;
    res.d[1] = -a3 * b1;
    res.d[2] = -a3 * b2;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between vector and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator^(const vector_t& a, const ibivector_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between vector and evector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 9 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator^(const vector_t& a, const evector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    res.d[3] = a3 * b0;
    res.d[4] = a3 * b1;
    res.d[5] = a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between vector and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator^(const vector_t& a, const dpoint_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    res.d[3] = a3 * b0 - a0;
    res.d[4] = a3 * b1 - a1;
    res.d[5] = a3 * b2 - a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between vector and rotation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 10 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator^(const vector_t& a, const rotation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    res.d[3] = a3 * b0;
    res.d[4] = -a3 * b1;
    res.d[5] = -a3 * b2;
    res.d[6] = -a3 * b3;
    res.d[7] = a0 * b1 + a1 * b2 + a2 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between vector and translation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator^(const vector_t& a, const translation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a3;
    res.d[4] = a1 * b2 - a2 * b1;
    res.d[5] = a2 * b0 - a0 * b2;
    res.d[6] = a0 * b1 - a1 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between vector and even  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 16 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator^(const vector_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    res.d[3] = a3 * b0;
    res.d[4] = a1 * b6 - a2 * b5 - a3 * b1;
    res.d[5] = a2 * b4 - a0 * b6 - a3 * b2;
    res.d[6] = a0 * b5 - a1 * b4 - a3 * b3;
    res.d[7] = a0 * b1 + a1 * b2 + a2 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between vector and odd  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 16 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator^(const vector_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = 0.0;
    res.d[1] = a1 * b2 - a2 * b1;
    res.d[2] = a2 * b0 - a0 * b2;
    res.d[3] = a0 * b1 - a1 * b0;
    res.d[4] = a3 * b0 - a0 * b3;
    res.d[5] = a3 * b1 - a1 * b3;
    res.d[6] = a3 * b2 - a2 * b3;
    res.d[7] = a0 * b4 + a1 * b5 + a2 * b6 + a3 * b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between bivector and scalar  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 6 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator^(const bivector_t& a, const scalar_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    res.d[3] = a3 * b;
    res.d[4] = a4 * b;
    res.d[5] = a5 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between bivector and vector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const bivector_t& a, const vector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a5 * b1 - a0 * b3 - a4 * b2;
    res.d[1] = a3 * b2 - a1 * b3 - a5 * b0;
    res.d[2] = a4 * b0 - a2 * b3 - a3 * b1;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between bivector and bivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₀₁₂₃
// 6 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const bivector_t& a, const bivector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a0 * b3 + a1 * b4 + a2 * b5 + a3 * b0 + a4 * b1 + a5 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between bivector and trivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const bivector_t& a, const trivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between bivector and quadvector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const bivector_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between bivector and horizon  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// 1 e₀
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator^(const bivector_t& a, const horizon_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between bivector and origin  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const bivector_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between bivector and point  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const bivector_t& a, const point_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between bivector and direction  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const bivector_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between bivector and ebivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₀₁₂₃
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const bivector_t& a, const ebivector_t& b) {
    quadvector_t res;
    const float a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b0 + a4 * b1 + a5 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between bivector and ibivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁₂₃
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const bivector_t& a, const ibivector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between bivector and evector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const bivector_t& a, const evector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a5 * b1 - a4 * b2;
    res.d[1] = a3 * b2 - a5 * b0;
    res.d[2] = a4 * b0 - a3 * b1;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between bivector and dpoint  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 9 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const bivector_t& a, const dpoint_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a5 * b1 - a0 - a4 * b2;
    res.d[1] = a3 * b2 - a1 - a5 * b0;
    res.d[2] = a4 * b0 - a2 - a3 * b1;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between bivector and rotation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator^(const bivector_t& a, const rotation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = a0 * b0;
    res.d[2] = a1 * b0;
    res.d[3] = a2 * b0;
    res.d[4] = a3 * b0;
    res.d[5] = a4 * b0;
    res.d[6] = a5 * b0;
    res.d[7] = a3 * b1 + a4 * b2 + a5 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between bivector and translation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator^(const bivector_t& a, const translation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = a0;
    res.d[2] = a1;
    res.d[3] = a2;
    res.d[4] = a3;
    res.d[5] = a4;
    res.d[6] = a5;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between bivector and even  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator^(const bivector_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6];
    res.d[0] = 0.0;
    res.d[1] = a0 * b0;
    res.d[2] = a1 * b0;
    res.d[3] = a2 * b0;
    res.d[4] = a3 * b0;
    res.d[5] = a4 * b0;
    res.d[6] = a5 * b0;
    res.d[7] = a0 * b4 + a1 * b5 + a2 * b6 + a3 * b1 + a4 * b2 + a5 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between bivector and odd  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const bivector_t& a, const odd_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a5 * b1 - a0 * b3 - a4 * b2;
    res.d[1] = a3 * b2 - a1 * b3 - a5 * b0;
    res.d[2] = a4 * b0 - a2 * b3 - a3 * b1;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between trivector and scalar  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const trivector_t& a, const scalar_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    res.d[3] = a3 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between trivector and vector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₀₁₂₃
// 4 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const trivector_t& a, const vector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a0 * b0 - a1 * b1 - a2 * b2 - a3 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between trivector and bivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const trivector_t& a, const bivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between trivector and trivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const trivector_t& a, const trivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between trivector and quadvector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const trivector_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between trivector and horizon  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// 1 e₀
// -> r0 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const trivector_t& a, const horizon_t& b) {
    quadvector_t res;
    const float a3 = a.d[3];
    res.d[0] = -a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between trivector and origin  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const trivector_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between trivector and point  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const trivector_t& a, const point_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between trivector and direction  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const trivector_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between trivector and ebivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const trivector_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between trivector and ibivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const trivector_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between trivector and evector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₀₁₂₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const trivector_t& a, const evector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between trivector and dpoint  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₀₁₂₃
// 3 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const trivector_t& a, const dpoint_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0 * b0 - a1 * b1 - a2 * b2 - a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between trivector and rotation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const trivector_t& a, const rotation_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    res.d[3] = a3 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between trivector and translation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const trivector_t& a, const translation_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between trivector and even  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const trivector_t& a, const even_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    res.d[3] = a3 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between trivector and odd  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₀₁₂₃
// 4 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const trivector_t& a, const odd_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a0 * b0 - a1 * b1 - a2 * b2 - a3 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between quadvector and scalar  
// a0 e₀₁₂₃
// b
// -> r0 e₀₁₂₃
// 1 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const quadvector_t& a, const scalar_t& b) {
    quadvector_t res;
    const float a0 = a.d[0];
    res.d[0] = a0 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between quadvector and vector  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const quadvector_t& a, const vector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between quadvector and bivector  
// a0 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const quadvector_t& a, const bivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between quadvector and trivector  
// a0 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const quadvector_t& a, const trivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between quadvector and quadvector  
// a0 e₀₁₂₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const quadvector_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between quadvector and horizon  
// a0 e₀₁₂₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const quadvector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between quadvector and origin  
// a0 e₀₁₂₃
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const quadvector_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between quadvector and point  
// a0 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const quadvector_t& a, const point_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between quadvector and direction  
// a0 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const quadvector_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between quadvector and ebivector  
// a0 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const quadvector_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between quadvector and ibivector  
// a0 e₀₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const quadvector_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between quadvector and evector  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const quadvector_t& a, const evector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between quadvector and dpoint  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const quadvector_t& a, const dpoint_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between quadvector and rotation  
// a0 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₀₁₂₃
// 1 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const quadvector_t& a, const rotation_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], b0 = b.d[0];
    res.d[0] = a0 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between quadvector and translation  
// a0 e₀₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const quadvector_t& a, const translation_t& b) {
    quadvector_t res;
    const float a0 = a.d[0];
    res.d[0] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between quadvector and even  
// a0 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₀₁₂₃
// 1 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const quadvector_t& a, const even_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], b0 = b.d[0];
    res.d[0] = a0 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between quadvector and odd  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const quadvector_t& a, const odd_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between horizon and scalar  
// 1 e₀
// b
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator^(const horizon_t& a, const scalar_t& b) {
    vector_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between horizon and vector  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator^(const horizon_t& a, const vector_t& b) {
    ibivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between horizon and bivector  
// 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator^(const horizon_t& a, const bivector_t& b) {
    direction_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between horizon and trivector  
// 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const horizon_t& a, const trivector_t& b) {
    quadvector_t res;
    const float b3 = b.d[3];
    res.d[0] = b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between horizon and quadvector  
// 1 e₀
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const horizon_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between horizon and horizon  
// 1 e₀
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const horizon_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between horizon and origin  
// 1 e₀
// 1 e₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const horizon_t& a, const origin_t& b) {
    quadvector_t res;
    res.d[0] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between horizon and point  
// 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const horizon_t& a, const point_t& b) {
    quadvector_t res;
    res.d[0] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between horizon and direction  
// 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const horizon_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between horizon and ebivector  
// 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator^(const horizon_t& a, const ebivector_t& b) {
    direction_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between horizon and ibivector  
// 1 e₀
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const horizon_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between horizon and evector  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator^(const horizon_t& a, const evector_t& b) {
    ibivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between horizon and dpoint  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator^(const horizon_t& a, const dpoint_t& b) {
    ibivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between horizon and rotation  
// 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator^(const horizon_t& a, const rotation_t& b) {
    odd_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b0;
    res.d[4] = -b1;
    res.d[5] = -b2;
    res.d[6] = -b3;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between horizon and translation  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline horizon_t operator^(const horizon_t& a, const translation_t& b) {

    return horizon_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// op between horizon and even  
// 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator^(const horizon_t& a, const even_t& b) {
    odd_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b0;
    res.d[4] = -b1;
    res.d[5] = -b2;
    res.d[6] = -b3;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between horizon and odd  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator^(const horizon_t& a, const odd_t& b) {
    even_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b7 = b.d[7];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = b0;
    res.d[5] = b1;
    res.d[6] = b2;
    res.d[7] = b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between origin and scalar  
// 1 e₁₂₃
// b
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const origin_t& a, const scalar_t& b) {
    trivector_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between origin and vector  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const origin_t& a, const vector_t& b) {
    quadvector_t res;
    const float b3 = b.d[3];
    res.d[0] = -b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between origin and bivector  
// 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const origin_t& a, const bivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between origin and trivector  
// 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const origin_t& a, const trivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between origin and quadvector  
// 1 e₁₂₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const origin_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between origin and horizon  
// 1 e₁₂₃
// 1 e₀
// -> r0 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const origin_t& a, const horizon_t& b) {
    quadvector_t res;
    res.d[0] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between origin and origin  
// 1 e₁₂₃
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const origin_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between origin and point  
// 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const origin_t& a, const point_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between origin and direction  
// 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const origin_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between origin and ebivector  
// 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const origin_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between origin and ibivector  
// 1 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const origin_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between origin and evector  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const origin_t& a, const evector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between origin and dpoint  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const origin_t& a, const dpoint_t& b) {
    quadvector_t res;
    res.d[0] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between origin and rotation  
// 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const origin_t& a, const rotation_t& b) {
    trivector_t res;
    const float b0 = b.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between origin and translation  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline origin_t operator^(const origin_t& a, const translation_t& b) {

    return origin_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// op between origin and even  
// 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const origin_t& a, const even_t& b) {
    trivector_t res;
    const float b0 = b.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between origin and odd  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const origin_t& a, const odd_t& b) {
    quadvector_t res;
    const float b3 = b.d[3];
    res.d[0] = -b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between point and scalar  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const point_t& a, const scalar_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    res.d[3] = b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between point and vector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₀₁₂₃
// 3 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const point_t& a, const vector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a0 * b0 - a1 * b1 - a2 * b2 - b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between point and bivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const point_t& a, const bivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between point and trivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const point_t& a, const trivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between point and quadvector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const point_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between point and horizon  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// 1 e₀
// -> r0 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const point_t& a, const horizon_t& b) {
    quadvector_t res;
    res.d[0] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between point and origin  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const point_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between point and point  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const point_t& a, const point_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between point and direction  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const point_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between point and ebivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const point_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between point and ibivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const point_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between point and evector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₀₁₂₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const point_t& a, const evector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between point and dpoint  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₀₁₂₃
// 3 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const point_t& a, const dpoint_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -1 - a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between point and rotation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const point_t& a, const rotation_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    res.d[3] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between point and translation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t operator^(const point_t& a, const translation_t& b) {
    point_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between point and even  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const point_t& a, const even_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    res.d[3] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between point and odd  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₀₁₂₃
// 3 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const point_t& a, const odd_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a0 * b0 - a1 * b1 - a2 * b2 - b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between direction and scalar  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator^(const direction_t& a, const scalar_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between direction and vector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₀₁₂₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const direction_t& a, const vector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between direction and bivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const direction_t& a, const bivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between direction and trivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const direction_t& a, const trivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between direction and quadvector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const direction_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between direction and horizon  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const direction_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between direction and origin  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const direction_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between direction and point  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const direction_t& a, const point_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between direction and direction  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const direction_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between direction and ebivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const direction_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between direction and ibivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const direction_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between direction and evector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₀₁₂₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const direction_t& a, const evector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between direction and dpoint  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₀₁₂₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const direction_t& a, const dpoint_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between direction and rotation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator^(const direction_t& a, const rotation_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between direction and translation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator^(const direction_t& a, const translation_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between direction and even  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator^(const direction_t& a, const even_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between direction and odd  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₀₁₂₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const direction_t& a, const odd_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between ebivector and scalar  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator^(const ebivector_t& a, const scalar_t& b) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between ebivector and vector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 6 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const ebivector_t& a, const vector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a0 * b3;
    res.d[1] = -a1 * b3;
    res.d[2] = -a2 * b3;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between ebivector and bivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₀₁₂₃
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const ebivector_t& a, const bivector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a0 * b3 + a1 * b4 + a2 * b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between ebivector and trivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const ebivector_t& a, const trivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between ebivector and quadvector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const ebivector_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between ebivector and horizon  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// 1 e₀
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator^(const ebivector_t& a, const horizon_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between ebivector and origin  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const ebivector_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between ebivector and point  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const ebivector_t& a, const point_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between ebivector and direction  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const ebivector_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between ebivector and ebivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const ebivector_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between ebivector and ibivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁₂₃
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const ebivector_t& a, const ibivector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between ebivector and evector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const ebivector_t& a, const evector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between ebivector and dpoint  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 3 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const ebivector_t& a, const dpoint_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between ebivector and rotation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator^(const ebivector_t& a, const rotation_t& b) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between ebivector and translation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator^(const ebivector_t& a, const translation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = a0;
    res.d[2] = a1;
    res.d[3] = a2;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between ebivector and even  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator^(const ebivector_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6];
    res.d[0] = 0.0;
    res.d[1] = a0 * b0;
    res.d[2] = a1 * b0;
    res.d[3] = a2 * b0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = a0 * b4 + a1 * b5 + a2 * b6;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between ebivector and odd  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 6 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const ebivector_t& a, const odd_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a0 * b3;
    res.d[1] = -a1 * b3;
    res.d[2] = -a2 * b3;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between ibivector and scalar  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator^(const ibivector_t& a, const scalar_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between ibivector and vector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator^(const ibivector_t& a, const vector_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between ibivector and bivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₀₁₂₃
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const ibivector_t& a, const bivector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between ibivector and trivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const ibivector_t& a, const trivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between ibivector and quadvector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const ibivector_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between ibivector and horizon  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const ibivector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between ibivector and origin  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const ibivector_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between ibivector and point  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const ibivector_t& a, const point_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between ibivector and direction  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const ibivector_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between ibivector and ebivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₀₁₂₃
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const ibivector_t& a, const ebivector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between ibivector and ibivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const ibivector_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between ibivector and evector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator^(const ibivector_t& a, const evector_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between ibivector and dpoint  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator^(const ibivector_t& a, const dpoint_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between ibivector and rotation  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator^(const ibivector_t& a, const rotation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a0 * b0;
    res.d[5] = a1 * b0;
    res.d[6] = a2 * b0;
    res.d[7] = a0 * b1 + a1 * b2 + a2 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between ibivector and translation  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator^(const ibivector_t& a, const translation_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between ibivector and even  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator^(const ibivector_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a0 * b0;
    res.d[5] = a1 * b0;
    res.d[6] = a2 * b0;
    res.d[7] = a0 * b1 + a1 * b2 + a2 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between ibivector and odd  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator^(const ibivector_t& a, const odd_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between evector and scalar  
// a0 e₁ + a1 e₂ + a2 e₃
// b
// -> r0 e₁ + r1 e₂ + r2 e₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator^(const evector_t& a, const scalar_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between evector and vector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator^(const evector_t& a, const vector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    res.d[3] = -a0 * b3;
    res.d[4] = -a1 * b3;
    res.d[5] = -a2 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between evector and bivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const evector_t& a, const bivector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a1 * b5 - a2 * b4;
    res.d[1] = a2 * b3 - a0 * b5;
    res.d[2] = a0 * b4 - a1 * b3;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between evector and trivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₁₂₃
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const evector_t& a, const trivector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between evector and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const evector_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between evector and horizon  
// a0 e₁ + a1 e₂ + a2 e₃
// 1 e₀
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator^(const evector_t& a, const horizon_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between evector and origin  
// a0 e₁ + a1 e₂ + a2 e₃
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const evector_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between evector and point  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₁₂₃
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const evector_t& a, const point_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between evector and direction  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₁₂₃
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const evector_t& a, const direction_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between evector and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const evector_t& a, const ebivector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between evector and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator^(const evector_t& a, const ibivector_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between evector and evector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator^(const evector_t& a, const evector_t& b) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between evector and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 6 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator^(const evector_t& a, const dpoint_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    res.d[3] = -a0;
    res.d[4] = -a1;
    res.d[5] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between evector and rotation  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator^(const evector_t& a, const rotation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    res.d[3] = 0.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = a0 * b1 + a1 * b2 + a2 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between evector and translation  
// a0 e₁ + a1 e₂ + a2 e₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator^(const evector_t& a, const translation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = 0.0;
    res.d[4] = a1 * b2 - a2 * b1;
    res.d[5] = a2 * b0 - a0 * b2;
    res.d[6] = a0 * b1 - a1 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between evector and even  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator^(const evector_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    res.d[3] = 0.0;
    res.d[4] = a1 * b6 - a2 * b5;
    res.d[5] = a2 * b4 - a0 * b6;
    res.d[6] = a0 * b5 - a1 * b4;
    res.d[7] = a0 * b1 + a1 * b2 + a2 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between evector and odd  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator^(const evector_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6];
    res.d[0] = 0.0;
    res.d[1] = a1 * b2 - a2 * b1;
    res.d[2] = a2 * b0 - a0 * b2;
    res.d[3] = a0 * b1 - a1 * b0;
    res.d[4] = -a0 * b3;
    res.d[5] = -a1 * b3;
    res.d[6] = -a2 * b3;
    res.d[7] = a0 * b4 + a1 * b5 + a2 * b6;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between dpoint and scalar  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator^(const dpoint_t& a, const scalar_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    res.d[3] = b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between dpoint and vector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator^(const dpoint_t& a, const vector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    res.d[3] = b0 - a0 * b3;
    res.d[4] = b1 - a1 * b3;
    res.d[5] = b2 - a2 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between dpoint and bivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 9 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const dpoint_t& a, const bivector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a1 * b5 - a2 * b4 - b0;
    res.d[1] = a2 * b3 - a0 * b5 - b1;
    res.d[2] = a0 * b4 - a1 * b3 - b2;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between dpoint and trivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₁₂₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const dpoint_t& a, const trivector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2 + b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between dpoint and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const dpoint_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between dpoint and horizon  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// 1 e₀
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator^(const dpoint_t& a, const horizon_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between dpoint and origin  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// 1 e₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const dpoint_t& a, const origin_t& b) {
    quadvector_t res;
    res.d[0] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between dpoint and point  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₁₂₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const dpoint_t& a, const point_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 1 + a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between dpoint and direction  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₁₂₃
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const dpoint_t& a, const direction_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between dpoint and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 3 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const dpoint_t& a, const ebivector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between dpoint and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator^(const dpoint_t& a, const ibivector_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between dpoint and evector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator^(const dpoint_t& a, const evector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    res.d[3] = b0;
    res.d[4] = b1;
    res.d[5] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between dpoint and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 6 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator^(const dpoint_t& a, const dpoint_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    res.d[3] = b0 - a0;
    res.d[4] = b1 - a1;
    res.d[5] = b2 - a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between dpoint and rotation  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator^(const dpoint_t& a, const rotation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    res.d[3] = b0;
    res.d[4] = -b1;
    res.d[5] = -b2;
    res.d[6] = -b3;
    res.d[7] = a0 * b1 + a1 * b2 + a2 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between dpoint and translation  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator^(const dpoint_t& a, const translation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = 1.0;
    res.d[4] = a1 * b2 - a2 * b1;
    res.d[5] = a2 * b0 - a0 * b2;
    res.d[6] = a0 * b1 - a1 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between dpoint and even  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator^(const dpoint_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    res.d[3] = b0;
    res.d[4] = a1 * b6 - a2 * b5 - b1;
    res.d[5] = a2 * b4 - a0 * b6 - b2;
    res.d[6] = a0 * b5 - a1 * b4 - b3;
    res.d[7] = a0 * b1 + a1 * b2 + a2 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between dpoint and odd  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator^(const dpoint_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = 0.0;
    res.d[1] = a1 * b2 - a2 * b1;
    res.d[2] = a2 * b0 - a0 * b2;
    res.d[3] = a0 * b1 - a1 * b0;
    res.d[4] = b0 - a0 * b3;
    res.d[5] = b1 - a1 * b3;
    res.d[6] = b2 - a2 * b3;
    res.d[7] = a0 * b4 + a1 * b5 + a2 * b6 + b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between rotation and scalar  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator^(const rotation_t& a, const scalar_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    res.d[3] = a3 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between rotation and vector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 10 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator^(const rotation_t& a, const vector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    res.d[3] = a0 * b3;
    res.d[4] = -a1 * b3;
    res.d[5] = -a2 * b3;
    res.d[6] = -a3 * b3;
    res.d[7] = a1 * b0 + a2 * b1 + a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between rotation and bivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator^(const rotation_t& a, const bivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = 0.0;
    res.d[1] = a0 * b0;
    res.d[2] = a0 * b1;
    res.d[3] = a0 * b2;
    res.d[4] = a0 * b3;
    res.d[5] = a0 * b4;
    res.d[6] = a0 * b5;
    res.d[7] = a1 * b3 + a2 * b4 + a3 * b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between rotation and trivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const rotation_t& a, const trivector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    res.d[3] = a0 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between rotation and quadvector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₁₂₃
// -> r0 e₀₁₂₃
// 1 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const rotation_t& a, const quadvector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], b0 = b.d[0];
    res.d[0] = a0 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between rotation and horizon  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator^(const rotation_t& a, const horizon_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0;
    res.d[4] = -a1;
    res.d[5] = -a2;
    res.d[6] = -a3;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between rotation and origin  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const rotation_t& a, const origin_t& b) {
    trivector_t res;
    const float a0 = a.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between rotation and point  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const rotation_t& a, const point_t& b) {
    trivector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    res.d[3] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between rotation and direction  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator^(const rotation_t& a, const direction_t& b) {
    direction_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between rotation and ebivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator^(const rotation_t& a, const ebivector_t& b) {
    ebivector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between rotation and ibivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator^(const rotation_t& a, const ibivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a0 * b0;
    res.d[5] = a0 * b1;
    res.d[6] = a0 * b2;
    res.d[7] = a1 * b0 + a2 * b1 + a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between rotation and evector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator^(const rotation_t& a, const evector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    res.d[3] = 0.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = a1 * b0 + a2 * b1 + a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between rotation and dpoint  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator^(const rotation_t& a, const dpoint_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    res.d[3] = a0;
    res.d[4] = -a1;
    res.d[5] = -a2;
    res.d[6] = -a3;
    res.d[7] = a1 * b0 + a2 * b1 + a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between rotation and rotation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 7 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator^(const rotation_t& a, const rotation_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1 + a1 * b0;
    res.d[2] = a0 * b2 + a2 * b0;
    res.d[3] = a0 * b3 + a3 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between rotation and translation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator^(const rotation_t& a, const translation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a3;
    res.d[4] = a0 * b0;
    res.d[5] = a0 * b1;
    res.d[6] = a0 * b2;
    res.d[7] = a1 * b0 + a2 * b1 + a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between rotation and even  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 14 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator^(const rotation_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1 + a1 * b0;
    res.d[2] = a0 * b2 + a2 * b0;
    res.d[3] = a0 * b3 + a3 * b0;
    res.d[4] = a0 * b4;
    res.d[5] = a0 * b5;
    res.d[6] = a0 * b6;
    res.d[7] = a0 * b7 + a1 * b4 + a2 * b5 + a3 * b6;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between rotation and odd  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 14 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator^(const rotation_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    res.d[3] = a0 * b3;
    res.d[4] = a0 * b4 - a1 * b3;
    res.d[5] = a0 * b5 - a2 * b3;
    res.d[6] = a0 * b6 - a3 * b3;
    res.d[7] = a0 * b7 + a1 * b0 + a2 * b1 + a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between translation and scalar  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator^(const translation_t& a, const scalar_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = b;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a0 * b;
    res.d[5] = a1 * b;
    res.d[6] = a2 * b;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between translation and vector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator^(const translation_t& a, const vector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between translation and bivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator^(const translation_t& a, const bivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = 0.0;
    res.d[1] = b0;
    res.d[2] = b1;
    res.d[3] = b2;
    res.d[4] = b3;
    res.d[5] = b4;
    res.d[6] = b5;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between translation and trivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const translation_t& a, const trivector_t& b) {
    trivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between translation and quadvector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const translation_t& a, const quadvector_t& b) {
    quadvector_t res;
    const float b0 = b.d[0];
    res.d[0] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between translation and horizon  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline horizon_t operator^(const translation_t& a, const horizon_t& b) {

    return horizon_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// op between translation and origin  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline origin_t operator^(const translation_t& a, const origin_t& b) {

    return origin_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// op between translation and point  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t operator^(const translation_t& a, const point_t& b) {
    point_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between translation and direction  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator^(const translation_t& a, const direction_t& b) {
    direction_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between translation and ebivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator^(const translation_t& a, const ebivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = b0;
    res.d[2] = b1;
    res.d[3] = b2;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between translation and ibivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator^(const translation_t& a, const ibivector_t& b) {
    ibivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between translation and evector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator^(const translation_t& a, const evector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = 0.0;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between translation and dpoint  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator^(const translation_t& a, const dpoint_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = 1.0;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between translation and rotation  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator^(const translation_t& a, const rotation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    res.d[4] = a0 * b0;
    res.d[5] = a1 * b0;
    res.d[6] = a2 * b0;
    res.d[7] = a0 * b1 + a1 * b2 + a2 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between translation and translation  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline translation_t operator^(const translation_t& a, const translation_t& b) {
    translation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 + b0;
    res.d[1] = a1 + b1;
    res.d[2] = a2 + b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between translation and even  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 6 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator^(const translation_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    res.d[4] = a0 * b0 + b4;
    res.d[5] = a1 * b0 + b5;
    res.d[6] = a2 * b0 + b6;
    res.d[7] = a0 * b1 + a1 * b2 + a2 * b3 + b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between translation and odd  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator^(const translation_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    res.d[4] = a2 * b1 + b4 - a1 * b2;
    res.d[5] = a0 * b2 + b5 - a2 * b0;
    res.d[6] = a1 * b0 + b6 - a0 * b1;
    res.d[7] = b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between even and scalar  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 8 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator^(const even_t& a, const scalar_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    res.d[3] = a3 * b;
    res.d[4] = a4 * b;
    res.d[5] = a5 * b;
    res.d[6] = a6 * b;
    res.d[7] = a7 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between even and vector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 16 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator^(const even_t& a, const vector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    res.d[3] = a0 * b3;
    res.d[4] = a6 * b1 - a1 * b3 - a5 * b2;
    res.d[5] = a4 * b2 - a2 * b3 - a6 * b0;
    res.d[6] = a5 * b0 - a3 * b3 - a4 * b1;
    res.d[7] = a1 * b0 + a2 * b1 + a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between even and bivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator^(const even_t& a, const bivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = 0.0;
    res.d[1] = a0 * b0;
    res.d[2] = a0 * b1;
    res.d[3] = a0 * b2;
    res.d[4] = a0 * b3;
    res.d[5] = a0 * b4;
    res.d[6] = a0 * b5;
    res.d[7] = a1 * b3 + a2 * b4 + a3 * b5 + a4 * b0 + a5 * b1 + a6 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between even and trivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const even_t& a, const trivector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    res.d[3] = a0 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between even and quadvector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₁₂₃
// -> r0 e₀₁₂₃
// 1 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const even_t& a, const quadvector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], b0 = b.d[0];
    res.d[0] = a0 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between even and horizon  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator^(const even_t& a, const horizon_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0;
    res.d[4] = -a1;
    res.d[5] = -a2;
    res.d[6] = -a3;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between even and origin  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const even_t& a, const origin_t& b) {
    trivector_t res;
    const float a0 = a.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between even and point  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const even_t& a, const point_t& b) {
    trivector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    res.d[3] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between even and direction  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator^(const even_t& a, const direction_t& b) {
    direction_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between even and ebivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator^(const even_t& a, const ebivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = a0 * b0;
    res.d[2] = a0 * b1;
    res.d[3] = a0 * b2;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = a4 * b0 + a5 * b1 + a6 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between even and ibivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator^(const even_t& a, const ibivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a0 * b0;
    res.d[5] = a0 * b1;
    res.d[6] = a0 * b2;
    res.d[7] = a1 * b0 + a2 * b1 + a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between even and evector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator^(const even_t& a, const evector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    res.d[3] = 0.0;
    res.d[4] = a6 * b1 - a5 * b2;
    res.d[5] = a4 * b2 - a6 * b0;
    res.d[6] = a5 * b0 - a4 * b1;
    res.d[7] = a1 * b0 + a2 * b1 + a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between even and dpoint  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator^(const even_t& a, const dpoint_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    res.d[3] = a0;
    res.d[4] = a6 * b1 - a1 - a5 * b2;
    res.d[5] = a4 * b2 - a2 - a6 * b0;
    res.d[6] = a5 * b0 - a3 - a4 * b1;
    res.d[7] = a1 * b0 + a2 * b1 + a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between even and rotation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 14 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator^(const even_t& a, const rotation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1 + a1 * b0;
    res.d[2] = a0 * b2 + a2 * b0;
    res.d[3] = a0 * b3 + a3 * b0;
    res.d[4] = a4 * b0;
    res.d[5] = a5 * b0;
    res.d[6] = a6 * b0;
    res.d[7] = a4 * b1 + a5 * b2 + a6 * b3 + a7 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between even and translation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 6 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator^(const even_t& a, const translation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a3;
    res.d[4] = a0 * b0 + a4;
    res.d[5] = a0 * b1 + a5;
    res.d[6] = a0 * b2 + a6;
    res.d[7] = a1 * b0 + a2 * b1 + a3 * b2 + a7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between even and even  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 21 muls / 13 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator^(const even_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1 + a1 * b0;
    res.d[2] = a0 * b2 + a2 * b0;
    res.d[3] = a0 * b3 + a3 * b0;
    res.d[4] = a0 * b4 + a4 * b0;
    res.d[5] = a0 * b5 + a5 * b0;
    res.d[6] = a0 * b6 + a6 * b0;
    res.d[7] = a0 * b7 + a1 * b4 + a2 * b5 + a3 * b6 + a4 * b1 + a5 * b2 + a6 * b3 + a7 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between even and odd  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 20 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator^(const even_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    res.d[3] = a0 * b3;
    res.d[4] = a0 * b4 + a6 * b1 - a1 * b3 - a5 * b2;
    res.d[5] = a0 * b5 + a4 * b2 - a2 * b3 - a6 * b0;
    res.d[6] = a0 * b6 + a5 * b0 - a3 * b3 - a4 * b1;
    res.d[7] = a0 * b7 + a1 * b0 + a2 * b1 + a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between odd and scalar  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 8 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator^(const odd_t& a, const scalar_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    res.d[3] = a3 * b;
    res.d[4] = a4 * b;
    res.d[5] = a5 * b;
    res.d[6] = a6 * b;
    res.d[7] = a7 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between odd and vector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 16 muls / 10 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator^(const odd_t& a, const vector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = a1 * b2 - a2 * b1;
    res.d[2] = a2 * b0 - a0 * b2;
    res.d[3] = a0 * b1 - a1 * b0;
    res.d[4] = a3 * b0 - a0 * b3;
    res.d[5] = a3 * b1 - a1 * b3;
    res.d[6] = a3 * b2 - a2 * b3;
    res.d[7] = -a4 * b0 - a5 * b1 - a6 * b2 - a7 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between odd and bivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const odd_t& a, const bivector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a1 * b5 - a2 * b4 - a3 * b0;
    res.d[1] = a2 * b3 - a0 * b5 - a3 * b1;
    res.d[2] = a0 * b4 - a1 * b3 - a3 * b2;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between odd and trivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₁₂₃
// 4 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const odd_t& a, const trivector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between odd and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator^(const odd_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// op between odd and horizon  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// 1 e₀
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator^(const odd_t& a, const horizon_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a7 = a.d[7];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = -a0;
    res.d[5] = -a1;
    res.d[6] = -a2;
    res.d[7] = -a7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between odd and origin  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// 1 e₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const odd_t& a, const origin_t& b) {
    quadvector_t res;
    const float a3 = a.d[3];
    res.d[0] = a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between odd and point  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₁₂₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const odd_t& a, const point_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2 + a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between odd and direction  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₁₂₃
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator^(const odd_t& a, const direction_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between odd and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 6 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator^(const odd_t& a, const ebivector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a3 * b0;
    res.d[1] = -a3 * b1;
    res.d[2] = -a3 * b2;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between odd and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator^(const odd_t& a, const ibivector_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between odd and evector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator^(const odd_t& a, const evector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = a1 * b2 - a2 * b1;
    res.d[2] = a2 * b0 - a0 * b2;
    res.d[3] = a0 * b1 - a1 * b0;
    res.d[4] = a3 * b0;
    res.d[5] = a3 * b1;
    res.d[6] = a3 * b2;
    res.d[7] = -a4 * b0 - a5 * b1 - a6 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between odd and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 10 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator^(const odd_t& a, const dpoint_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = a1 * b2 - a2 * b1;
    res.d[2] = a2 * b0 - a0 * b2;
    res.d[3] = a0 * b1 - a1 * b0;
    res.d[4] = a3 * b0 - a0;
    res.d[5] = a3 * b1 - a1;
    res.d[6] = a3 * b2 - a2;
    res.d[7] = -a4 * b0 - a5 * b1 - a6 * b2 - a7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between odd and rotation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 14 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator^(const odd_t& a, const rotation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    res.d[3] = a3 * b0;
    res.d[4] = a4 * b0 - a3 * b1;
    res.d[5] = a5 * b0 - a3 * b2;
    res.d[6] = a6 * b0 - a3 * b3;
    res.d[7] = a0 * b1 + a1 * b2 + a2 * b3 + a7 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between odd and translation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator^(const odd_t& a, const translation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a3;
    res.d[4] = a1 * b2 + a4 - a2 * b1;
    res.d[5] = a2 * b0 + a5 - a0 * b2;
    res.d[6] = a0 * b1 + a6 - a1 * b0;
    res.d[7] = a7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between odd and even  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 20 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator^(const odd_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    res.d[3] = a3 * b0;
    res.d[4] = a1 * b6 + a4 * b0 - a2 * b5 - a3 * b1;
    res.d[5] = a2 * b4 + a5 * b0 - a0 * b6 - a3 * b2;
    res.d[6] = a0 * b5 + a6 * b0 - a1 * b4 - a3 * b3;
    res.d[7] = a0 * b1 + a1 * b2 + a2 * b3 + a7 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// op between odd and odd  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 20 muls / 13 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator^(const odd_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = 0.0;
    res.d[1] = a1 * b2 - a2 * b1;
    res.d[2] = a2 * b0 - a0 * b2;
    res.d[3] = a0 * b1 - a1 * b0;
    res.d[4] = a3 * b0 - a0 * b3;
    res.d[5] = a3 * b1 - a1 * b3;
    res.d[6] = a3 * b2 - a2 * b3;
    res.d[7] = a0 * b4 + a1 * b5 + a2 * b6 + a3 * b7 - a4 * b0 - a5 * b1 - a6 * b2 - a7 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between scalar and vector  
// a
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const scalar_t& a, const vector_t& b) {
    vector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    res.d[3] = a * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between scalar and bivector  
// a
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 6 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator|(const scalar_t& a, const bivector_t& b) {
    bivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    res.d[3] = a * b3;
    res.d[4] = a * b4;
    res.d[5] = a * b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between scalar and trivector  
// a
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator|(const scalar_t& a, const trivector_t& b) {
    trivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    res.d[3] = a * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between scalar and quadvector  
// a
// b0 e₀₁₂₃
// -> r0 e₀₁₂₃
// 1 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator|(const scalar_t& a, const quadvector_t& b) {
    quadvector_t res;
    const float b0 = b.d[0];
    res.d[0] = a * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between scalar and horizon  
// a
// 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const scalar_t& a, const horizon_t& b) {
    vector_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between scalar and origin  
// a
// 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator|(const scalar_t& a, const origin_t& b) {
    trivector_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between scalar and point  
// a
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator|(const scalar_t& a, const point_t& b) {
    trivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    res.d[3] = a;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between scalar and direction  
// a
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator|(const scalar_t& a, const direction_t& b) {
    direction_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between scalar and ebivector  
// a
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator|(const scalar_t& a, const ebivector_t& b) {
    ebivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between scalar and ibivector  
// a
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator|(const scalar_t& a, const ibivector_t& b) {
    ibivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between scalar and evector  
// a
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator|(const scalar_t& a, const evector_t& b) {
    evector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between scalar and dpoint  
// a
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const scalar_t& a, const dpoint_t& b) {
    vector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    res.d[3] = a;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between scalar and rotation  
// a
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator|(const scalar_t& a, const rotation_t& b) {
    rotation_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    res.d[3] = a * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between scalar and translation  
// a
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator|(const scalar_t& a, const translation_t& b) {
    even_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a * b0;
    res.d[5] = a * b1;
    res.d[6] = a * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between scalar and even  
// a
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 8 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator|(const scalar_t& a, const even_t& b) {
    even_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    res.d[3] = a * b3;
    res.d[4] = a * b4;
    res.d[5] = a * b5;
    res.d[6] = a * b6;
    res.d[7] = a * b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between scalar and odd  
// a
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 8 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator|(const scalar_t& a, const odd_t& b) {
    odd_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    res.d[3] = a * b3;
    res.d[4] = a * b4;
    res.d[5] = a * b5;
    res.d[6] = a * b6;
    res.d[7] = a * b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between vector and scalar  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const vector_t& a, const scalar_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    res.d[3] = a3 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between vector and vector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const vector_t& a, const vector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between vector and bivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const vector_t& a, const bivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = -a0 * b3 - a1 * b4 - a2 * b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between vector and trivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 9 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator|(const vector_t& a, const trivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b3;
    res.d[1] = a1 * b3;
    res.d[2] = a2 * b3;
    res.d[3] = a2 * b1 - a1 * b2;
    res.d[4] = a0 * b2 - a2 * b0;
    res.d[5] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between vector and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator|(const vector_t& a, const quadvector_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between vector and horizon  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const vector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between vector and origin  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// 1 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator|(const vector_t& a, const origin_t& b) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between vector and point  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator|(const vector_t& a, const point_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a2 * b1 - a1 * b2;
    res.d[4] = a0 * b2 - a2 * b0;
    res.d[5] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between vector and direction  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator|(const vector_t& a, const direction_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between vector and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator|(const vector_t& a, const ebivector_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between vector and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const vector_t& a, const ibivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between vector and evector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const vector_t& a, const evector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between vector and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const vector_t& a, const dpoint_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between vector and rotation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 10 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const vector_t& a, const rotation_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0 + a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 + a1 * b0 - a2 * b1;
    res.d[2] = a1 * b1 + a2 * b0 - a0 * b2;
    res.d[3] = a3 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between vector and translation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const vector_t& a, const translation_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a3 - a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between vector and even  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 16 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator|(const vector_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0 + a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 + a1 * b0 - a2 * b1;
    res.d[2] = a1 * b1 + a2 * b0 - a0 * b2;
    res.d[3] = a3 * b0 - a0 * b4 - a1 * b5 - a2 * b6;
    res.d[4] = a0 * b7;
    res.d[5] = a1 * b7;
    res.d[6] = a2 * b7;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between vector and odd  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator|(const vector_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[1] = a0 * b7;
    res.d[2] = a1 * b7;
    res.d[3] = a2 * b7;
    res.d[4] = a2 * b5 - a1 * b6;
    res.d[5] = a0 * b6 - a2 * b4;
    res.d[6] = a1 * b4 - a0 * b5;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between bivector and scalar  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 6 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator|(const bivector_t& a, const scalar_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    res.d[3] = a3 * b;
    res.d[4] = a4 * b;
    res.d[5] = a5 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between bivector and vector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const bivector_t& a, const vector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = a3 * b0 + a4 * b1 + a5 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between bivector and bivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const bivector_t& a, const bivector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return -a0 * b0 - a1 * b1 - a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between bivector and trivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 6 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const bivector_t& a, const trivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a0 * b3;
    res.d[1] = -a1 * b3;
    res.d[2] = -a2 * b3;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between bivector and quadvector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₁₂₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator|(const bivector_t& a, const quadvector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = -a0 * b0;
    res.d[1] = -a1 * b0;
    res.d[2] = -a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between bivector and horizon  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const bivector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between bivector and origin  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator|(const bivector_t& a, const origin_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between bivector and point  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const bivector_t& a, const point_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between bivector and direction  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const bivector_t& a, const direction_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between bivector and ebivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const bivector_t& a, const ebivector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return -a0 * b0 - a1 * b1 - a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between bivector and ibivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const bivector_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between bivector and evector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const bivector_t& a, const evector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = a3 * b0 + a4 * b1 + a5 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between bivector and dpoint  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const bivector_t& a, const dpoint_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = a3 * b0 + a4 * b1 + a5 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between bivector and rotation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator|(const bivector_t& a, const rotation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a0 * b1 - a1 * b2 - a2 * b3;
    res.d[1] = a0 * b0;
    res.d[2] = a1 * b0;
    res.d[3] = a2 * b0;
    res.d[4] = a3 * b0;
    res.d[5] = a4 * b0;
    res.d[6] = a5 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between bivector and translation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator|(const bivector_t& a, const translation_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a3;
    res.d[4] = a4;
    res.d[5] = a5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between bivector and even  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator|(const bivector_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b7 = b.d[7];
    res.d[0] = -a0 * b1 - a1 * b2 - a2 * b3;
    res.d[1] = a0 * b0;
    res.d[2] = a1 * b0;
    res.d[3] = a2 * b0;
    res.d[4] = a3 * b0 - a0 * b7;
    res.d[5] = a4 * b0 - a1 * b7;
    res.d[6] = a5 * b0 - a2 * b7;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between bivector and odd  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 15 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const bivector_t& a, const odd_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a2 * b1 - a0 * b7 - a1 * b2;
    res.d[1] = a0 * b2 - a1 * b7 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1 - a2 * b7;
    res.d[3] = a0 * b4 + a1 * b5 + a2 * b6 + a3 * b0 + a4 * b1 + a5 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between trivector and scalar  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator|(const trivector_t& a, const scalar_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    res.d[3] = a3 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between trivector and vector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 9 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator|(const trivector_t& a, const vector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b0;
    res.d[1] = a3 * b1;
    res.d[2] = a3 * b2;
    res.d[3] = a1 * b2 - a2 * b1;
    res.d[4] = a2 * b0 - a0 * b2;
    res.d[5] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between trivector and bivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 6 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const trivector_t& a, const bivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a3 * b0;
    res.d[1] = -a3 * b1;
    res.d[2] = -a3 * b2;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between trivector and trivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 1 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const trivector_t& a, const trivector_t& b) {

    const float a3 = a.d[3], b3 = b.d[3];
    return -a3 * b3;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between trivector and quadvector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 1 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const trivector_t& a, const quadvector_t& b) {
    vector_t res;
    const float a3 = a.d[3], b0 = b.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a3 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between trivector and horizon  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const trivector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between trivector and origin  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// 1 e₁₂₃
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const trivector_t& a, const origin_t& b) {

    const float a3 = a.d[3];
    return -a3;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between trivector and point  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const trivector_t& a, const point_t& b) {

    const float a3 = a.d[3];
    return -a3;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between trivector and direction  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const trivector_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between trivector and ebivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 6 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const trivector_t& a, const ebivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a3 * b0;
    res.d[1] = -a3 * b1;
    res.d[2] = -a3 * b2;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between trivector and ibivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const trivector_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between trivector and evector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 9 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator|(const trivector_t& a, const evector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b0;
    res.d[1] = a3 * b1;
    res.d[2] = a3 * b2;
    res.d[3] = a1 * b2 - a2 * b1;
    res.d[4] = a2 * b0 - a0 * b2;
    res.d[5] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between trivector and dpoint  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 9 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator|(const trivector_t& a, const dpoint_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b0;
    res.d[1] = a3 * b1;
    res.d[2] = a3 * b2;
    res.d[3] = a1 * b2 - a2 * b1;
    res.d[4] = a2 * b0 - a0 * b2;
    res.d[5] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between trivector and rotation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 10 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator|(const trivector_t& a, const rotation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a3 * b1;
    res.d[1] = -a3 * b2;
    res.d[2] = -a3 * b3;
    res.d[3] = a0 * b1 + a1 * b2 + a2 * b3;
    res.d[4] = a0 * b0;
    res.d[5] = a1 * b0;
    res.d[6] = a2 * b0;
    res.d[7] = a3 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between trivector and translation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator|(const trivector_t& a, const translation_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between trivector and even  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 11 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator|(const trivector_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b7 = b.d[7];
    res.d[0] = -a3 * b1;
    res.d[1] = -a3 * b2;
    res.d[2] = -a3 * b3;
    res.d[3] = a0 * b1 + a1 * b2 + a2 * b3 + a3 * b7;
    res.d[4] = a0 * b0;
    res.d[5] = a1 * b0;
    res.d[6] = a2 * b0;
    res.d[7] = a3 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between trivector and odd  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 10 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator|(const trivector_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b7 = b.d[7];
    res.d[0] = -a3 * b7;
    res.d[1] = a3 * b0;
    res.d[2] = a3 * b1;
    res.d[3] = a3 * b2;
    res.d[4] = a1 * b2 - a2 * b1;
    res.d[5] = a2 * b0 - a0 * b2;
    res.d[6] = a0 * b1 - a1 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between quadvector and scalar  
// a0 e₀₁₂₃
// b
// -> r0 e₀₁₂₃
// 1 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator|(const quadvector_t& a, const scalar_t& b) {
    quadvector_t res;
    const float a0 = a.d[0];
    res.d[0] = a0 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between quadvector and vector  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator|(const quadvector_t& a, const vector_t& b) {
    direction_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0 * b0;
    res.d[1] = -a0 * b1;
    res.d[2] = -a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between quadvector and bivector  
// a0 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator|(const quadvector_t& a, const bivector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0 * b0;
    res.d[1] = -a0 * b1;
    res.d[2] = -a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between quadvector and trivector  
// a0 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 1 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const quadvector_t& a, const trivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between quadvector and quadvector  
// a0 e₀₁₂₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const quadvector_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between quadvector and horizon  
// a0 e₀₁₂₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const quadvector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between quadvector and origin  
// a0 e₀₁₂₃
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const quadvector_t& a, const origin_t& b) {
    vector_t res;
    const float a0 = a.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between quadvector and point  
// a0 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const quadvector_t& a, const point_t& b) {
    vector_t res;
    const float a0 = a.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between quadvector and direction  
// a0 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const quadvector_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between quadvector and ebivector  
// a0 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator|(const quadvector_t& a, const ebivector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0 * b0;
    res.d[1] = -a0 * b1;
    res.d[2] = -a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between quadvector and ibivector  
// a0 e₀₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const quadvector_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between quadvector and evector  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator|(const quadvector_t& a, const evector_t& b) {
    direction_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0 * b0;
    res.d[1] = -a0 * b1;
    res.d[2] = -a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between quadvector and dpoint  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator|(const quadvector_t& a, const dpoint_t& b) {
    direction_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0 * b0;
    res.d[1] = -a0 * b1;
    res.d[2] = -a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between quadvector and rotation  
// a0 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 4 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator|(const quadvector_t& a, const rotation_t& b) {
    even_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = -a0 * b1;
    res.d[5] = -a0 * b2;
    res.d[6] = -a0 * b3;
    res.d[7] = a0 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between quadvector and translation  
// a0 e₀₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator|(const quadvector_t& a, const translation_t& b) {
    quadvector_t res;
    const float a0 = a.d[0];
    res.d[0] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between quadvector and even  
// a0 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 4 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator|(const quadvector_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = -a0 * b1;
    res.d[5] = -a0 * b2;
    res.d[6] = -a0 * b3;
    res.d[7] = a0 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between quadvector and odd  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 4 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator|(const quadvector_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b7 = b.d[7];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b7;
    res.d[4] = -a0 * b0;
    res.d[5] = -a0 * b1;
    res.d[6] = -a0 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between horizon and scalar  
// 1 e₀
// b
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const horizon_t& a, const scalar_t& b) {
    vector_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between horizon and vector  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const horizon_t& a, const vector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between horizon and bivector  
// 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const horizon_t& a, const bivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between horizon and trivector  
// 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const horizon_t& a, const trivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between horizon and quadvector  
// 1 e₀
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const horizon_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between horizon and horizon  
// 1 e₀
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const horizon_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between horizon and origin  
// 1 e₀
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const horizon_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between horizon and point  
// 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const horizon_t& a, const point_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between horizon and direction  
// 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const horizon_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between horizon and ebivector  
// 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const horizon_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between horizon and ibivector  
// 1 e₀
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const horizon_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between horizon and evector  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const horizon_t& a, const evector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between horizon and dpoint  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const horizon_t& a, const dpoint_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between horizon and rotation  
// 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const horizon_t& a, const rotation_t& b) {
    vector_t res;
    const float b0 = b.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between horizon and translation  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline horizon_t operator|(const horizon_t& a, const translation_t& b) {

    return horizon_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// ip between horizon and even  
// 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const horizon_t& a, const even_t& b) {
    vector_t res;
    const float b0 = b.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between horizon and odd  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const horizon_t& a, const odd_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between origin and scalar  
// 1 e₁₂₃
// b
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator|(const origin_t& a, const scalar_t& b) {
    trivector_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between origin and vector  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator|(const origin_t& a, const vector_t& b) {
    ebivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between origin and bivector  
// 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator|(const origin_t& a, const bivector_t& b) {
    evector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between origin and trivector  
// 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const origin_t& a, const trivector_t& b) {

    const float b3 = b.d[3];
    return -b3;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between origin and quadvector  
// 1 e₁₂₃
// b0 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const origin_t& a, const quadvector_t& b) {
    vector_t res;
    const float b0 = b.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between origin and horizon  
// 1 e₁₂₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const origin_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between origin and origin  
// 1 e₁₂₃
// 1 e₁₂₃
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const origin_t& a, const origin_t& b) {

    return -1;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between origin and point  
// 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const origin_t& a, const point_t& b) {

    return -1;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between origin and direction  
// 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const origin_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between origin and ebivector  
// 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator|(const origin_t& a, const ebivector_t& b) {
    evector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between origin and ibivector  
// 1 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const origin_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between origin and evector  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator|(const origin_t& a, const evector_t& b) {
    ebivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between origin and dpoint  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator|(const origin_t& a, const dpoint_t& b) {
    ebivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between origin and rotation  
// 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator|(const origin_t& a, const rotation_t& b) {
    odd_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -b1;
    res.d[1] = -b2;
    res.d[2] = -b3;
    res.d[3] = 0.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between origin and translation  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline origin_t operator|(const origin_t& a, const translation_t& b) {

    return origin_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// ip between origin and even  
// 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator|(const origin_t& a, const even_t& b) {
    odd_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b7 = b.d[7];
    res.d[0] = -b1;
    res.d[1] = -b2;
    res.d[2] = -b3;
    res.d[3] = b7;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between origin and odd  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator|(const origin_t& a, const odd_t& b) {
    rotation_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b7 = b.d[7];
    res.d[0] = -b7;
    res.d[1] = b0;
    res.d[2] = b1;
    res.d[3] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between point and scalar  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator|(const point_t& a, const scalar_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    res.d[3] = b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between point and vector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator|(const point_t& a, const vector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = a1 * b2 - a2 * b1;
    res.d[4] = a2 * b0 - a0 * b2;
    res.d[5] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between point and bivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const point_t& a, const bivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between point and trivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const point_t& a, const trivector_t& b) {

    const float b3 = b.d[3];
    return -b3;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between point and quadvector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const point_t& a, const quadvector_t& b) {
    vector_t res;
    const float b0 = b.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between point and horizon  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const point_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between point and origin  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// 1 e₁₂₃
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const point_t& a, const origin_t& b) {

    return -1;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between point and point  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const point_t& a, const point_t& b) {

    return -1;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between point and direction  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const point_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between point and ebivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const point_t& a, const ebivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between point and ibivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const point_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between point and evector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator|(const point_t& a, const evector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = a1 * b2 - a2 * b1;
    res.d[4] = a2 * b0 - a0 * b2;
    res.d[5] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between point and dpoint  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator|(const point_t& a, const dpoint_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = a1 * b2 - a2 * b1;
    res.d[4] = a2 * b0 - a0 * b2;
    res.d[5] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between point and rotation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator|(const point_t& a, const rotation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -b1;
    res.d[1] = -b2;
    res.d[2] = -b3;
    res.d[3] = a0 * b1 + a1 * b2 + a2 * b3;
    res.d[4] = a0 * b0;
    res.d[5] = a1 * b0;
    res.d[6] = a2 * b0;
    res.d[7] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between point and translation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t operator|(const point_t& a, const translation_t& b) {
    point_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between point and even  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator|(const point_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b7 = b.d[7];
    res.d[0] = -b1;
    res.d[1] = -b2;
    res.d[2] = -b3;
    res.d[3] = a0 * b1 + a1 * b2 + a2 * b3 + b7;
    res.d[4] = a0 * b0;
    res.d[5] = a1 * b0;
    res.d[6] = a2 * b0;
    res.d[7] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between point and odd  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 6 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator|(const point_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b7 = b.d[7];
    res.d[0] = -b7;
    res.d[1] = b0;
    res.d[2] = b1;
    res.d[3] = b2;
    res.d[4] = a1 * b2 - a2 * b1;
    res.d[5] = a2 * b0 - a0 * b2;
    res.d[6] = a0 * b1 - a1 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between direction and scalar  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator|(const direction_t& a, const scalar_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between direction and vector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator|(const direction_t& a, const vector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between direction and bivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const direction_t& a, const bivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between direction and trivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const direction_t& a, const trivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between direction and quadvector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const direction_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between direction and horizon  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const direction_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between direction and origin  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const direction_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between direction and point  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const direction_t& a, const point_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between direction and direction  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const direction_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between direction and ebivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const direction_t& a, const ebivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between direction and ibivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const direction_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between direction and evector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator|(const direction_t& a, const evector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between direction and dpoint  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator|(const direction_t& a, const dpoint_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between direction and rotation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator|(const direction_t& a, const rotation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b1 + a1 * b2 + a2 * b3;
    res.d[4] = a0 * b0;
    res.d[5] = a1 * b0;
    res.d[6] = a2 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between direction and translation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator|(const direction_t& a, const translation_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between direction and even  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator|(const direction_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b1 + a1 * b2 + a2 * b3;
    res.d[4] = a0 * b0;
    res.d[5] = a1 * b0;
    res.d[6] = a2 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between direction and odd  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator|(const direction_t& a, const odd_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ebivector and scalar  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator|(const ebivector_t& a, const scalar_t& b) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ebivector and vector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator|(const ebivector_t& a, const vector_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ebivector and bivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const ebivector_t& a, const bivector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return -a0 * b0 - a1 * b1 - a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between ebivector and trivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 6 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const ebivector_t& a, const trivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a0 * b3;
    res.d[1] = -a1 * b3;
    res.d[2] = -a2 * b3;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ebivector and quadvector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₁₂₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator|(const ebivector_t& a, const quadvector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = -a0 * b0;
    res.d[1] = -a1 * b0;
    res.d[2] = -a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ebivector and horizon  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const ebivector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between ebivector and origin  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator|(const ebivector_t& a, const origin_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ebivector and point  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const ebivector_t& a, const point_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ebivector and direction  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const ebivector_t& a, const direction_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ebivector and ebivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const ebivector_t& a, const ebivector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return -a0 * b0 - a1 * b1 - a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between ebivector and ibivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const ebivector_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between ebivector and evector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator|(const ebivector_t& a, const evector_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ebivector and dpoint  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator|(const ebivector_t& a, const dpoint_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ebivector and rotation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator|(const ebivector_t& a, const rotation_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a0 * b1 - a1 * b2 - a2 * b3;
    res.d[1] = a0 * b0;
    res.d[2] = a1 * b0;
    res.d[3] = a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ebivector and translation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator|(const ebivector_t& a, const translation_t& b) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ebivector and even  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator|(const ebivector_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b7 = b.d[7];
    res.d[0] = -a0 * b1 - a1 * b2 - a2 * b3;
    res.d[1] = a0 * b0;
    res.d[2] = a1 * b0;
    res.d[3] = a2 * b0;
    res.d[4] = -a0 * b7;
    res.d[5] = -a1 * b7;
    res.d[6] = -a2 * b7;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ebivector and odd  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const ebivector_t& a, const odd_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a2 * b1 - a0 * b7 - a1 * b2;
    res.d[1] = a0 * b2 - a1 * b7 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1 - a2 * b7;
    res.d[3] = a0 * b4 + a1 * b5 + a2 * b6;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ibivector and scalar  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator|(const ibivector_t& a, const scalar_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ibivector and vector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const ibivector_t& a, const vector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ibivector and bivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const ibivector_t& a, const bivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between ibivector and trivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const ibivector_t& a, const trivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between ibivector and quadvector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const ibivector_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between ibivector and horizon  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const ibivector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between ibivector and origin  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const ibivector_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between ibivector and point  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const ibivector_t& a, const point_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between ibivector and direction  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const ibivector_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between ibivector and ebivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const ibivector_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between ibivector and ibivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const ibivector_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between ibivector and evector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const ibivector_t& a, const evector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ibivector and dpoint  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const ibivector_t& a, const dpoint_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ibivector and rotation  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator|(const ibivector_t& a, const rotation_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ibivector and translation  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator|(const ibivector_t& a, const translation_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ibivector and even  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator|(const ibivector_t& a, const even_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between ibivector and odd  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const ibivector_t& a, const odd_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between evector and scalar  
// a0 e₁ + a1 e₂ + a2 e₃
// b
// -> r0 e₁ + r1 e₂ + r2 e₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator|(const evector_t& a, const scalar_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between evector and vector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const evector_t& a, const vector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between evector and bivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const evector_t& a, const bivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = -a0 * b3 - a1 * b4 - a2 * b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between evector and trivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 9 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator|(const evector_t& a, const trivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b3;
    res.d[1] = a1 * b3;
    res.d[2] = a2 * b3;
    res.d[3] = a2 * b1 - a1 * b2;
    res.d[4] = a0 * b2 - a2 * b0;
    res.d[5] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between evector and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator|(const evector_t& a, const quadvector_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between evector and horizon  
// a0 e₁ + a1 e₂ + a2 e₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const evector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between evector and origin  
// a0 e₁ + a1 e₂ + a2 e₃
// 1 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator|(const evector_t& a, const origin_t& b) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between evector and point  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator|(const evector_t& a, const point_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a2 * b1 - a1 * b2;
    res.d[4] = a0 * b2 - a2 * b0;
    res.d[5] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between evector and direction  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator|(const evector_t& a, const direction_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between evector and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator|(const evector_t& a, const ebivector_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between evector and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const evector_t& a, const ibivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between evector and evector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const evector_t& a, const evector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between evector and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const evector_t& a, const dpoint_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between evector and rotation  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator|(const evector_t& a, const rotation_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0 + a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 + a1 * b0 - a2 * b1;
    res.d[2] = a1 * b1 + a2 * b0 - a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between evector and translation  
// a0 e₁ + a1 e₂ + a2 e₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const evector_t& a, const translation_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between evector and even  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 15 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator|(const evector_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0 + a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 + a1 * b0 - a2 * b1;
    res.d[2] = a1 * b1 + a2 * b0 - a0 * b2;
    res.d[3] = -a0 * b4 - a1 * b5 - a2 * b6;
    res.d[4] = a0 * b7;
    res.d[5] = a1 * b7;
    res.d[6] = a2 * b7;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between evector and odd  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator|(const evector_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[1] = a0 * b7;
    res.d[2] = a1 * b7;
    res.d[3] = a2 * b7;
    res.d[4] = a2 * b5 - a1 * b6;
    res.d[5] = a0 * b6 - a2 * b4;
    res.d[6] = a1 * b4 - a0 * b5;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between dpoint and scalar  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const dpoint_t& a, const scalar_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    res.d[3] = b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between dpoint and vector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const dpoint_t& a, const vector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between dpoint and bivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const dpoint_t& a, const bivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = -a0 * b3 - a1 * b4 - a2 * b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between dpoint and trivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 9 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator|(const dpoint_t& a, const trivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b3;
    res.d[1] = a1 * b3;
    res.d[2] = a2 * b3;
    res.d[3] = a2 * b1 - a1 * b2;
    res.d[4] = a0 * b2 - a2 * b0;
    res.d[5] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between dpoint and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator|(const dpoint_t& a, const quadvector_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between dpoint and horizon  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const dpoint_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between dpoint and origin  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// 1 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator|(const dpoint_t& a, const origin_t& b) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between dpoint and point  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator|(const dpoint_t& a, const point_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a2 * b1 - a1 * b2;
    res.d[4] = a0 * b2 - a2 * b0;
    res.d[5] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between dpoint and direction  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator|(const dpoint_t& a, const direction_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between dpoint and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator|(const dpoint_t& a, const ebivector_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between dpoint and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const dpoint_t& a, const ibivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between dpoint and evector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const dpoint_t& a, const evector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between dpoint and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const dpoint_t& a, const dpoint_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between dpoint and rotation  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const dpoint_t& a, const rotation_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0 + a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 + a1 * b0 - a2 * b1;
    res.d[2] = a1 * b1 + a2 * b0 - a0 * b2;
    res.d[3] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between dpoint and translation  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const dpoint_t& a, const translation_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = 1 - a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between dpoint and even  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 15 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator|(const dpoint_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0 + a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 + a1 * b0 - a2 * b1;
    res.d[2] = a1 * b1 + a2 * b0 - a0 * b2;
    res.d[3] = b0 - a0 * b4 - a1 * b5 - a2 * b6;
    res.d[4] = a0 * b7;
    res.d[5] = a1 * b7;
    res.d[6] = a2 * b7;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between dpoint and odd  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator|(const dpoint_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[1] = a0 * b7;
    res.d[2] = a1 * b7;
    res.d[3] = a2 * b7;
    res.d[4] = a2 * b5 - a1 * b6;
    res.d[5] = a0 * b6 - a2 * b4;
    res.d[6] = a1 * b4 - a0 * b5;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between rotation and scalar  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator|(const rotation_t& a, const scalar_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    res.d[3] = a3 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between rotation and vector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 10 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const rotation_t& a, const vector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0 + a3 * b1 - a2 * b2;
    res.d[1] = a0 * b1 + a1 * b2 - a3 * b0;
    res.d[2] = a0 * b2 + a2 * b0 - a1 * b1;
    res.d[3] = a0 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between rotation and bivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator|(const rotation_t& a, const bivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = -a1 * b0 - a2 * b1 - a3 * b2;
    res.d[1] = a0 * b0;
    res.d[2] = a0 * b1;
    res.d[3] = a0 * b2;
    res.d[4] = a0 * b3;
    res.d[5] = a0 * b4;
    res.d[6] = a0 * b5;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between rotation and trivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 10 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator|(const rotation_t& a, const trivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a1 * b3;
    res.d[1] = -a2 * b3;
    res.d[2] = -a3 * b3;
    res.d[3] = a1 * b0 + a2 * b1 + a3 * b2;
    res.d[4] = a0 * b0;
    res.d[5] = a0 * b1;
    res.d[6] = a0 * b2;
    res.d[7] = a0 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between rotation and quadvector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 4 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator|(const rotation_t& a, const quadvector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = -a1 * b0;
    res.d[5] = -a2 * b0;
    res.d[6] = -a3 * b0;
    res.d[7] = a0 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between rotation and horizon  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const rotation_t& a, const horizon_t& b) {
    vector_t res;
    const float a0 = a.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between rotation and origin  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator|(const rotation_t& a, const origin_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = -a1;
    res.d[1] = -a2;
    res.d[2] = -a3;
    res.d[3] = 0.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between rotation and point  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator|(const rotation_t& a, const point_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a1;
    res.d[1] = -a2;
    res.d[2] = -a3;
    res.d[3] = a1 * b0 + a2 * b1 + a3 * b2;
    res.d[4] = a0 * b0;
    res.d[5] = a0 * b1;
    res.d[6] = a0 * b2;
    res.d[7] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between rotation and direction  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator|(const rotation_t& a, const direction_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a1 * b0 + a2 * b1 + a3 * b2;
    res.d[4] = a0 * b0;
    res.d[5] = a0 * b1;
    res.d[6] = a0 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between rotation and ebivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator|(const rotation_t& a, const ebivector_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a1 * b0 - a2 * b1 - a3 * b2;
    res.d[1] = a0 * b0;
    res.d[2] = a0 * b1;
    res.d[3] = a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between rotation and ibivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator|(const rotation_t& a, const ibivector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between rotation and evector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator|(const rotation_t& a, const evector_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a3 * b1 - a2 * b2;
    res.d[1] = a0 * b1 + a1 * b2 - a3 * b0;
    res.d[2] = a0 * b2 + a2 * b0 - a1 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between rotation and dpoint  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const rotation_t& a, const dpoint_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a3 * b1 - a2 * b2;
    res.d[1] = a0 * b1 + a1 * b2 - a3 * b0;
    res.d[2] = a0 * b2 + a2 * b0 - a1 * b1;
    res.d[3] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between rotation and rotation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 10 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator|(const rotation_t& a, const rotation_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0 - a1 * b1 - a2 * b2 - a3 * b3;
    res.d[1] = a0 * b1 + a1 * b0;
    res.d[2] = a0 * b2 + a2 * b0;
    res.d[3] = a0 * b3 + a3 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between rotation and translation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator|(const rotation_t& a, const translation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a3;
    res.d[4] = a0 * b0;
    res.d[5] = a0 * b1;
    res.d[6] = a0 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between rotation and even  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 17 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator|(const rotation_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0 - a1 * b1 - a2 * b2 - a3 * b3;
    res.d[1] = a0 * b1 + a1 * b0;
    res.d[2] = a0 * b2 + a2 * b0;
    res.d[3] = a0 * b3 + a3 * b0;
    res.d[4] = a0 * b4 - a1 * b7;
    res.d[5] = a0 * b5 - a2 * b7;
    res.d[6] = a0 * b6 - a3 * b7;
    res.d[7] = a0 * b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between rotation and odd  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 20 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator|(const rotation_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0 + a3 * b1 - a1 * b7 - a2 * b2;
    res.d[1] = a0 * b1 + a1 * b2 - a2 * b7 - a3 * b0;
    res.d[2] = a0 * b2 + a2 * b0 - a1 * b1 - a3 * b7;
    res.d[3] = a0 * b3 + a1 * b4 + a2 * b5 + a3 * b6;
    res.d[4] = a0 * b4;
    res.d[5] = a0 * b5;
    res.d[6] = a0 * b6;
    res.d[7] = a0 * b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between translation and scalar  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator|(const translation_t& a, const scalar_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = b;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a0 * b;
    res.d[5] = a1 * b;
    res.d[6] = a2 * b;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between translation and vector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const translation_t& a, const vector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2 + b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between translation and bivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator|(const translation_t& a, const bivector_t& b) {
    bivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    res.d[4] = b4;
    res.d[5] = b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between translation and trivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator|(const translation_t& a, const trivector_t& b) {
    trivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between translation and quadvector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator|(const translation_t& a, const quadvector_t& b) {
    quadvector_t res;
    const float b0 = b.d[0];
    res.d[0] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between translation and horizon  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline horizon_t operator|(const translation_t& a, const horizon_t& b) {

    return horizon_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// ip between translation and origin  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline origin_t operator|(const translation_t& a, const origin_t& b) {

    return origin_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// ip between translation and point  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t operator|(const translation_t& a, const point_t& b) {
    point_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between translation and direction  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator|(const translation_t& a, const direction_t& b) {
    direction_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between translation and ebivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator|(const translation_t& a, const ebivector_t& b) {
    ebivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between translation and ibivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator|(const translation_t& a, const ibivector_t& b) {
    ibivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between translation and evector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const translation_t& a, const evector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between translation and dpoint  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const translation_t& a, const dpoint_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = 1 + a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between translation and rotation  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator|(const translation_t& a, const rotation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    res.d[4] = a0 * b0;
    res.d[5] = a1 * b0;
    res.d[6] = a2 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between translation and translation  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline translation_t operator|(const translation_t& a, const translation_t& b) {
    translation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 + b0;
    res.d[1] = a1 + b1;
    res.d[2] = a2 + b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between translation and even  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator|(const translation_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    res.d[4] = a0 * b0 + b4;
    res.d[5] = a1 * b0 + b5;
    res.d[6] = a2 * b0 + b6;
    res.d[7] = b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between translation and odd  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator|(const translation_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2 + b3;
    res.d[4] = b4;
    res.d[5] = b5;
    res.d[6] = b6;
    res.d[7] = b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between even and scalar  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 8 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator|(const even_t& a, const scalar_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    res.d[3] = a3 * b;
    res.d[4] = a4 * b;
    res.d[5] = a5 * b;
    res.d[6] = a6 * b;
    res.d[7] = a7 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between even and vector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 16 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator|(const even_t& a, const vector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0 + a3 * b1 - a2 * b2;
    res.d[1] = a0 * b1 + a1 * b2 - a3 * b0;
    res.d[2] = a0 * b2 + a2 * b0 - a1 * b1;
    res.d[3] = a0 * b3 + a4 * b0 + a5 * b1 + a6 * b2;
    res.d[4] = -a7 * b0;
    res.d[5] = -a7 * b1;
    res.d[6] = -a7 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between even and bivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator|(const even_t& a, const bivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = -a1 * b0 - a2 * b1 - a3 * b2;
    res.d[1] = a0 * b0;
    res.d[2] = a0 * b1;
    res.d[3] = a0 * b2;
    res.d[4] = a0 * b3 - a7 * b0;
    res.d[5] = a0 * b4 - a7 * b1;
    res.d[6] = a0 * b5 - a7 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between even and trivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 11 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator|(const even_t& a, const trivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a1 * b3;
    res.d[1] = -a2 * b3;
    res.d[2] = -a3 * b3;
    res.d[3] = a1 * b0 + a2 * b1 + a3 * b2 - a7 * b3;
    res.d[4] = a0 * b0;
    res.d[5] = a0 * b1;
    res.d[6] = a0 * b2;
    res.d[7] = a0 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between even and quadvector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 4 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator|(const even_t& a, const quadvector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = -a1 * b0;
    res.d[5] = -a2 * b0;
    res.d[6] = -a3 * b0;
    res.d[7] = a0 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between even and horizon  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const even_t& a, const horizon_t& b) {
    vector_t res;
    const float a0 = a.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between even and origin  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator|(const even_t& a, const origin_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a7 = a.d[7];
    res.d[0] = -a1;
    res.d[1] = -a2;
    res.d[2] = -a3;
    res.d[3] = -a7;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between even and point  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator|(const even_t& a, const point_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a1;
    res.d[1] = -a2;
    res.d[2] = -a3;
    res.d[3] = a1 * b0 + a2 * b1 + a3 * b2 - a7;
    res.d[4] = a0 * b0;
    res.d[5] = a0 * b1;
    res.d[6] = a0 * b2;
    res.d[7] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between even and direction  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator|(const even_t& a, const direction_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a1 * b0 + a2 * b1 + a3 * b2;
    res.d[4] = a0 * b0;
    res.d[5] = a0 * b1;
    res.d[6] = a0 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between even and ebivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator|(const even_t& a, const ebivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a1 * b0 - a2 * b1 - a3 * b2;
    res.d[1] = a0 * b0;
    res.d[2] = a0 * b1;
    res.d[3] = a0 * b2;
    res.d[4] = -a7 * b0;
    res.d[5] = -a7 * b1;
    res.d[6] = -a7 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between even and ibivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator|(const even_t& a, const ibivector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between even and evector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 15 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator|(const even_t& a, const evector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a3 * b1 - a2 * b2;
    res.d[1] = a0 * b1 + a1 * b2 - a3 * b0;
    res.d[2] = a0 * b2 + a2 * b0 - a1 * b1;
    res.d[3] = a4 * b0 + a5 * b1 + a6 * b2;
    res.d[4] = -a7 * b0;
    res.d[5] = -a7 * b1;
    res.d[6] = -a7 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between even and dpoint  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 15 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator|(const even_t& a, const dpoint_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a3 * b1 - a2 * b2;
    res.d[1] = a0 * b1 + a1 * b2 - a3 * b0;
    res.d[2] = a0 * b2 + a2 * b0 - a1 * b1;
    res.d[3] = a0 + a4 * b0 + a5 * b1 + a6 * b2;
    res.d[4] = -a7 * b0;
    res.d[5] = -a7 * b1;
    res.d[6] = -a7 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between even and rotation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 17 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator|(const even_t& a, const rotation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0 - a1 * b1 - a2 * b2 - a3 * b3;
    res.d[1] = a0 * b1 + a1 * b0;
    res.d[2] = a0 * b2 + a2 * b0;
    res.d[3] = a0 * b3 + a3 * b0;
    res.d[4] = a4 * b0 - a7 * b1;
    res.d[5] = a5 * b0 - a7 * b2;
    res.d[6] = a6 * b0 - a7 * b3;
    res.d[7] = a7 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between even and translation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator|(const even_t& a, const translation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a3;
    res.d[4] = a0 * b0 + a4;
    res.d[5] = a0 * b1 + a5;
    res.d[6] = a0 * b2 + a6;
    res.d[7] = a7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between even and even  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 24 muls / 16 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator|(const even_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0 - a1 * b1 - a2 * b2 - a3 * b3;
    res.d[1] = a0 * b1 + a1 * b0;
    res.d[2] = a0 * b2 + a2 * b0;
    res.d[3] = a0 * b3 + a3 * b0;
    res.d[4] = a0 * b4 + a4 * b0 - a1 * b7 - a7 * b1;
    res.d[5] = a0 * b5 + a5 * b0 - a2 * b7 - a7 * b2;
    res.d[6] = a0 * b6 + a6 * b0 - a3 * b7 - a7 * b3;
    res.d[7] = a0 * b7 + a7 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between even and odd  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 27 muls / 19 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator|(const even_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0 + a3 * b1 - a1 * b7 - a2 * b2;
    res.d[1] = a0 * b1 + a1 * b2 - a2 * b7 - a3 * b0;
    res.d[2] = a0 * b2 + a2 * b0 - a1 * b1 - a3 * b7;
    res.d[3] = a0 * b3 + a1 * b4 + a2 * b5 + a3 * b6 + a4 * b0 + a5 * b1 + a6 * b2 - a7 * b7;
    res.d[4] = a0 * b4 - a7 * b0;
    res.d[5] = a0 * b5 - a7 * b1;
    res.d[6] = a0 * b6 - a7 * b2;
    res.d[7] = a0 * b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between odd and scalar  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 8 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator|(const odd_t& a, const scalar_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    res.d[3] = a3 * b;
    res.d[4] = a4 * b;
    res.d[5] = a5 * b;
    res.d[6] = a6 * b;
    res.d[7] = a7 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between odd and vector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator|(const odd_t& a, const vector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[1] = a7 * b0;
    res.d[2] = a7 * b1;
    res.d[3] = a7 * b2;
    res.d[4] = a5 * b2 - a6 * b1;
    res.d[5] = a6 * b0 - a4 * b2;
    res.d[6] = a4 * b1 - a5 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between odd and bivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 15 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const odd_t& a, const bivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a2 * b1 - a1 * b2 - a7 * b0;
    res.d[1] = a0 * b2 - a2 * b0 - a7 * b1;
    res.d[2] = a1 * b0 - a0 * b1 - a7 * b2;
    res.d[3] = a4 * b0 + a5 * b1 + a6 * b2 - a0 * b3 - a1 * b4 - a2 * b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between odd and trivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 10 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator|(const odd_t& a, const trivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a7 * b3;
    res.d[1] = a0 * b3;
    res.d[2] = a1 * b3;
    res.d[3] = a2 * b3;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between odd and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator|(const odd_t& a, const quadvector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a7 = a.d[7], b0 = b.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a7 * b0;
    res.d[4] = a0 * b0;
    res.d[5] = a1 * b0;
    res.d[6] = a2 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between odd and horizon  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator|(const odd_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// ip between odd and origin  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// 1 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator|(const odd_t& a, const origin_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a7 = a.d[7];
    res.d[0] = -a7;
    res.d[1] = a0;
    res.d[2] = a1;
    res.d[3] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between odd and point  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 6 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator|(const odd_t& a, const point_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a7;
    res.d[1] = a0;
    res.d[2] = a1;
    res.d[3] = a2;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between odd and direction  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator|(const odd_t& a, const direction_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between odd and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const odd_t& a, const ebivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2 - a7 * b0;
    res.d[1] = a0 * b2 - a2 * b0 - a7 * b1;
    res.d[2] = a1 * b0 - a0 * b1 - a7 * b2;
    res.d[3] = a4 * b0 + a5 * b1 + a6 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between odd and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator|(const odd_t& a, const ibivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between odd and evector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator|(const odd_t& a, const evector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[1] = a7 * b0;
    res.d[2] = a7 * b1;
    res.d[3] = a7 * b2;
    res.d[4] = a5 * b2 - a6 * b1;
    res.d[5] = a6 * b0 - a4 * b2;
    res.d[6] = a4 * b1 - a5 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between odd and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator|(const odd_t& a, const dpoint_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[1] = a7 * b0;
    res.d[2] = a7 * b1;
    res.d[3] = a7 * b2;
    res.d[4] = a5 * b2 - a6 * b1;
    res.d[5] = a6 * b0 - a4 * b2;
    res.d[6] = a4 * b1 - a5 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between odd and rotation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 20 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator|(const odd_t& a, const rotation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0 + a2 * b2 - a1 * b3 - a7 * b1;
    res.d[1] = a0 * b3 + a1 * b0 - a2 * b1 - a7 * b2;
    res.d[2] = a1 * b1 + a2 * b0 - a0 * b2 - a7 * b3;
    res.d[3] = a3 * b0 + a4 * b1 + a5 * b2 + a6 * b3;
    res.d[4] = a4 * b0;
    res.d[5] = a5 * b0;
    res.d[6] = a6 * b0;
    res.d[7] = a7 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between odd and translation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator|(const odd_t& a, const translation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a3 - a0 * b0 - a1 * b1 - a2 * b2;
    res.d[4] = a4;
    res.d[5] = a5;
    res.d[6] = a6;
    res.d[7] = a7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between odd and even  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 27 muls / 19 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator|(const odd_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0 + a2 * b2 - a1 * b3 - a7 * b1;
    res.d[1] = a0 * b3 + a1 * b0 - a2 * b1 - a7 * b2;
    res.d[2] = a1 * b1 + a2 * b0 - a0 * b2 - a7 * b3;
    res.d[3] = a3 * b0 + a4 * b1 + a5 * b2 + a6 * b3 + a7 * b7 - a0 * b4 - a1 * b5 - a2 * b6;
    res.d[4] = a0 * b7 + a4 * b0;
    res.d[5] = a1 * b7 + a5 * b0;
    res.d[6] = a2 * b7 + a6 * b0;
    res.d[7] = a7 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// ip between odd and odd  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 22 muls / 15 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator|(const odd_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2 - a7 * b7;
    res.d[1] = a0 * b7 + a7 * b0;
    res.d[2] = a1 * b7 + a7 * b1;
    res.d[3] = a2 * b7 + a7 * b2;
    res.d[4] = a2 * b5 + a5 * b2 - a1 * b6 - a6 * b1;
    res.d[5] = a0 * b6 + a6 * b0 - a2 * b4 - a4 * b2;
    res.d[6] = a1 * b4 + a4 * b1 - a0 * b5 - a5 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between scalar and scalar  
// a
// b
// -> r
// 1 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const scalar_t& a, const scalar_t& b) {

    return a * b;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between scalar and vector  
// a
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const scalar_t& a, const vector_t& b) {
    vector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    res.d[3] = a * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between scalar and bivector  
// a
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 6 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t lip(const scalar_t& a, const bivector_t& b) {
    bivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    res.d[3] = a * b3;
    res.d[4] = a * b4;
    res.d[5] = a * b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between scalar and trivector  
// a
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t lip(const scalar_t& a, const trivector_t& b) {
    trivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    res.d[3] = a * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between scalar and quadvector  
// a
// b0 e₀₁₂₃
// -> r0 e₀₁₂₃
// 1 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t lip(const scalar_t& a, const quadvector_t& b) {
    quadvector_t res;
    const float b0 = b.d[0];
    res.d[0] = a * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between scalar and horizon  
// a
// 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const scalar_t& a, const horizon_t& b) {
    vector_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between scalar and origin  
// a
// 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t lip(const scalar_t& a, const origin_t& b) {
    trivector_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between scalar and point  
// a
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t lip(const scalar_t& a, const point_t& b) {
    trivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    res.d[3] = a;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between scalar and direction  
// a
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t lip(const scalar_t& a, const direction_t& b) {
    direction_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between scalar and ebivector  
// a
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t lip(const scalar_t& a, const ebivector_t& b) {
    ebivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between scalar and ibivector  
// a
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t lip(const scalar_t& a, const ibivector_t& b) {
    ibivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between scalar and evector  
// a
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t lip(const scalar_t& a, const evector_t& b) {
    evector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between scalar and dpoint  
// a
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const scalar_t& a, const dpoint_t& b) {
    vector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    res.d[3] = a;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between scalar and rotation  
// a
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t lip(const scalar_t& a, const rotation_t& b) {
    rotation_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    res.d[3] = a * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between scalar and translation  
// a
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t lip(const scalar_t& a, const translation_t& b) {
    even_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a * b0;
    res.d[5] = a * b1;
    res.d[6] = a * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between scalar and even  
// a
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 8 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t lip(const scalar_t& a, const even_t& b) {
    even_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    res.d[3] = a * b3;
    res.d[4] = a * b4;
    res.d[5] = a * b5;
    res.d[6] = a * b6;
    res.d[7] = a * b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between scalar and odd  
// a
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 8 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t lip(const scalar_t& a, const odd_t& b) {
    odd_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a * b0;
    res.d[1] = a * b1;
    res.d[2] = a * b2;
    res.d[3] = a * b3;
    res.d[4] = a * b4;
    res.d[5] = a * b5;
    res.d[6] = a * b6;
    res.d[7] = a * b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between vector and scalar  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const vector_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between vector and vector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const vector_t& a, const vector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between vector and bivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const vector_t& a, const bivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = -a0 * b3 - a1 * b4 - a2 * b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between vector and trivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 9 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t lip(const vector_t& a, const trivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b3;
    res.d[1] = a1 * b3;
    res.d[2] = a2 * b3;
    res.d[3] = a2 * b1 - a1 * b2;
    res.d[4] = a0 * b2 - a2 * b0;
    res.d[5] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between vector and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t lip(const vector_t& a, const quadvector_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between vector and horizon  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const vector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between vector and origin  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// 1 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t lip(const vector_t& a, const origin_t& b) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between vector and point  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t lip(const vector_t& a, const point_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a2 * b1 - a1 * b2;
    res.d[4] = a0 * b2 - a2 * b0;
    res.d[5] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between vector and direction  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t lip(const vector_t& a, const direction_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between vector and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t lip(const vector_t& a, const ebivector_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between vector and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const vector_t& a, const ibivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between vector and evector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const vector_t& a, const evector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between vector and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const vector_t& a, const dpoint_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between vector and rotation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t lip(const vector_t& a, const rotation_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 - a2 * b1;
    res.d[2] = a1 * b1 - a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between vector and translation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const vector_t& a, const translation_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between vector and even  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t lip(const vector_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 - a2 * b1;
    res.d[2] = a1 * b1 - a0 * b2;
    res.d[3] = -a0 * b4 - a1 * b5 - a2 * b6;
    res.d[4] = a0 * b7;
    res.d[5] = a1 * b7;
    res.d[6] = a2 * b7;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between vector and odd  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t lip(const vector_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[1] = a0 * b7;
    res.d[2] = a1 * b7;
    res.d[3] = a2 * b7;
    res.d[4] = a2 * b5 - a1 * b6;
    res.d[5] = a0 * b6 - a2 * b4;
    res.d[6] = a1 * b4 - a0 * b5;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between bivector and scalar  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const bivector_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between bivector and vector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const bivector_t& a, const vector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between bivector and bivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const bivector_t& a, const bivector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return -a0 * b0 - a1 * b1 - a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between bivector and trivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 6 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const bivector_t& a, const trivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a0 * b3;
    res.d[1] = -a1 * b3;
    res.d[2] = -a2 * b3;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between bivector and quadvector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₁₂₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t lip(const bivector_t& a, const quadvector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = -a0 * b0;
    res.d[1] = -a1 * b0;
    res.d[2] = -a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between bivector and horizon  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const bivector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between bivector and origin  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t lip(const bivector_t& a, const origin_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between bivector and point  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const bivector_t& a, const point_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between bivector and direction  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const bivector_t& a, const direction_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between bivector and ebivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const bivector_t& a, const ebivector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return -a0 * b0 - a1 * b1 - a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between bivector and ibivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const bivector_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between bivector and evector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const bivector_t& a, const evector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between bivector and dpoint  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const bivector_t& a, const dpoint_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between bivector and rotation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const bivector_t& a, const rotation_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    return -a0 * b1 - a1 * b2 - a2 * b3;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between bivector and translation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const bivector_t& a, const translation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between bivector and even  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 6 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t lip(const bivector_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b7 = b.d[7];
    res.d[0] = -a0 * b1 - a1 * b2 - a2 * b3;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = -a0 * b7;
    res.d[5] = -a1 * b7;
    res.d[6] = -a2 * b7;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between bivector and odd  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 6 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const bivector_t& a, const odd_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = -a0 * b7;
    res.d[1] = -a1 * b7;
    res.d[2] = -a2 * b7;
    res.d[3] = a0 * b4 + a1 * b5 + a2 * b6;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between trivector and scalar  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const trivector_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between trivector and vector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const trivector_t& a, const vector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between trivector and bivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const trivector_t& a, const bivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between trivector and trivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 1 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const trivector_t& a, const trivector_t& b) {

    const float a3 = a.d[3], b3 = b.d[3];
    return -a3 * b3;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between trivector and quadvector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 1 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const trivector_t& a, const quadvector_t& b) {
    vector_t res;
    const float a3 = a.d[3], b0 = b.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a3 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between trivector and horizon  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const trivector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between trivector and origin  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// 1 e₁₂₃
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const trivector_t& a, const origin_t& b) {

    const float a3 = a.d[3];
    return -a3;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between trivector and point  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const trivector_t& a, const point_t& b) {

    const float a3 = a.d[3];
    return -a3;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between trivector and direction  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const trivector_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between trivector and ebivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const trivector_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between trivector and ibivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const trivector_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between trivector and evector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const trivector_t& a, const evector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between trivector and dpoint  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const trivector_t& a, const dpoint_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between trivector and rotation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const trivector_t& a, const rotation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between trivector and translation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const trivector_t& a, const translation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between trivector and even  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 1 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const trivector_t& a, const even_t& b) {
    vector_t res;
    const float a3 = a.d[3], b7 = b.d[7];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a3 * b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between trivector and odd  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r
// 1 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const trivector_t& a, const odd_t& b) {

    const float a3 = a.d[3], b7 = b.d[7];
    return -a3 * b7;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between quadvector and scalar  
// a0 e₀₁₂₃
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const quadvector_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between quadvector and vector  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const quadvector_t& a, const vector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between quadvector and bivector  
// a0 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const quadvector_t& a, const bivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between quadvector and trivector  
// a0 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const quadvector_t& a, const trivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between quadvector and quadvector  
// a0 e₀₁₂₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const quadvector_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between quadvector and horizon  
// a0 e₀₁₂₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const quadvector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between quadvector and origin  
// a0 e₀₁₂₃
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const quadvector_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between quadvector and point  
// a0 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const quadvector_t& a, const point_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between quadvector and direction  
// a0 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const quadvector_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between quadvector and ebivector  
// a0 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const quadvector_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between quadvector and ibivector  
// a0 e₀₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const quadvector_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between quadvector and evector  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const quadvector_t& a, const evector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between quadvector and dpoint  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const quadvector_t& a, const dpoint_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between quadvector and rotation  
// a0 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const quadvector_t& a, const rotation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between quadvector and translation  
// a0 e₀₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const quadvector_t& a, const translation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between quadvector and even  
// a0 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const quadvector_t& a, const even_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between quadvector and odd  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const quadvector_t& a, const odd_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between horizon and scalar  
// 1 e₀
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const horizon_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between horizon and vector  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const horizon_t& a, const vector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between horizon and bivector  
// 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const horizon_t& a, const bivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between horizon and trivector  
// 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const horizon_t& a, const trivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between horizon and quadvector  
// 1 e₀
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const horizon_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between horizon and horizon  
// 1 e₀
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const horizon_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between horizon and origin  
// 1 e₀
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const horizon_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between horizon and point  
// 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const horizon_t& a, const point_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between horizon and direction  
// 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const horizon_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between horizon and ebivector  
// 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const horizon_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between horizon and ibivector  
// 1 e₀
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const horizon_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between horizon and evector  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const horizon_t& a, const evector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between horizon and dpoint  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const horizon_t& a, const dpoint_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between horizon and rotation  
// 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const horizon_t& a, const rotation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between horizon and translation  
// 1 e₀
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const horizon_t& a, const translation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between horizon and even  
// 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const horizon_t& a, const even_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between horizon and odd  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const horizon_t& a, const odd_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between origin and scalar  
// 1 e₁₂₃
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const origin_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between origin and vector  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const origin_t& a, const vector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between origin and bivector  
// 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const origin_t& a, const bivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between origin and trivector  
// 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const origin_t& a, const trivector_t& b) {

    const float b3 = b.d[3];
    return -b3;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between origin and quadvector  
// 1 e₁₂₃
// b0 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const origin_t& a, const quadvector_t& b) {
    vector_t res;
    const float b0 = b.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between origin and horizon  
// 1 e₁₂₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const origin_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between origin and origin  
// 1 e₁₂₃
// 1 e₁₂₃
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const origin_t& a, const origin_t& b) {

    return -1;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between origin and point  
// 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const origin_t& a, const point_t& b) {

    return -1;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between origin and direction  
// 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const origin_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between origin and ebivector  
// 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const origin_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between origin and ibivector  
// 1 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const origin_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between origin and evector  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const origin_t& a, const evector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between origin and dpoint  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const origin_t& a, const dpoint_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between origin and rotation  
// 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const origin_t& a, const rotation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between origin and translation  
// 1 e₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const origin_t& a, const translation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between origin and even  
// 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const origin_t& a, const even_t& b) {
    vector_t res;
    const float b7 = b.d[7];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between origin and odd  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const origin_t& a, const odd_t& b) {

    const float b7 = b.d[7];
    return -b7;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between point and scalar  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const point_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between point and vector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const point_t& a, const vector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between point and bivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const point_t& a, const bivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between point and trivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const point_t& a, const trivector_t& b) {

    const float b3 = b.d[3];
    return -b3;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between point and quadvector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const point_t& a, const quadvector_t& b) {
    vector_t res;
    const float b0 = b.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between point and horizon  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const point_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between point and origin  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// 1 e₁₂₃
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const point_t& a, const origin_t& b) {

    return -1;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between point and point  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const point_t& a, const point_t& b) {

    return -1;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between point and direction  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const point_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between point and ebivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const point_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between point and ibivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const point_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between point and evector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const point_t& a, const evector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between point and dpoint  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const point_t& a, const dpoint_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between point and rotation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const point_t& a, const rotation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between point and translation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const point_t& a, const translation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between point and even  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const point_t& a, const even_t& b) {
    vector_t res;
    const float b7 = b.d[7];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between point and odd  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const point_t& a, const odd_t& b) {

    const float b7 = b.d[7];
    return -b7;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between direction and scalar  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const direction_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between direction and vector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const direction_t& a, const vector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between direction and bivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const direction_t& a, const bivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between direction and trivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const direction_t& a, const trivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between direction and quadvector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const direction_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between direction and horizon  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const direction_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between direction and origin  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const direction_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between direction and point  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const direction_t& a, const point_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between direction and direction  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const direction_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between direction and ebivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const direction_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between direction and ibivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const direction_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between direction and evector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const direction_t& a, const evector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between direction and dpoint  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const direction_t& a, const dpoint_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between direction and rotation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const direction_t& a, const rotation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between direction and translation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const direction_t& a, const translation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between direction and even  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const direction_t& a, const even_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between direction and odd  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const direction_t& a, const odd_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between ebivector and scalar  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const ebivector_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between ebivector and vector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const ebivector_t& a, const vector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between ebivector and bivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const ebivector_t& a, const bivector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return -a0 * b0 - a1 * b1 - a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between ebivector and trivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 6 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const ebivector_t& a, const trivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a0 * b3;
    res.d[1] = -a1 * b3;
    res.d[2] = -a2 * b3;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between ebivector and quadvector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₁₂₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t lip(const ebivector_t& a, const quadvector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = -a0 * b0;
    res.d[1] = -a1 * b0;
    res.d[2] = -a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between ebivector and horizon  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const ebivector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between ebivector and origin  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t lip(const ebivector_t& a, const origin_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between ebivector and point  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const ebivector_t& a, const point_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between ebivector and direction  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const ebivector_t& a, const direction_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between ebivector and ebivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const ebivector_t& a, const ebivector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return -a0 * b0 - a1 * b1 - a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between ebivector and ibivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const ebivector_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between ebivector and evector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const ebivector_t& a, const evector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between ebivector and dpoint  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const ebivector_t& a, const dpoint_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between ebivector and rotation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const ebivector_t& a, const rotation_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    return -a0 * b1 - a1 * b2 - a2 * b3;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between ebivector and translation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const ebivector_t& a, const translation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between ebivector and even  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 6 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t lip(const ebivector_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b7 = b.d[7];
    res.d[0] = -a0 * b1 - a1 * b2 - a2 * b3;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = -a0 * b7;
    res.d[5] = -a1 * b7;
    res.d[6] = -a2 * b7;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between ebivector and odd  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 6 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const ebivector_t& a, const odd_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = -a0 * b7;
    res.d[1] = -a1 * b7;
    res.d[2] = -a2 * b7;
    res.d[3] = a0 * b4 + a1 * b5 + a2 * b6;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between ibivector and scalar  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const ibivector_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between ibivector and vector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const ibivector_t& a, const vector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between ibivector and bivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const ibivector_t& a, const bivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between ibivector and trivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const ibivector_t& a, const trivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between ibivector and quadvector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const ibivector_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between ibivector and horizon  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const ibivector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between ibivector and origin  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const ibivector_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between ibivector and point  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const ibivector_t& a, const point_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between ibivector and direction  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const ibivector_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between ibivector and ebivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const ibivector_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between ibivector and ibivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const ibivector_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between ibivector and evector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const ibivector_t& a, const evector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between ibivector and dpoint  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const ibivector_t& a, const dpoint_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between ibivector and rotation  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const ibivector_t& a, const rotation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between ibivector and translation  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const ibivector_t& a, const translation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between ibivector and even  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const ibivector_t& a, const even_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between ibivector and odd  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const ibivector_t& a, const odd_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between evector and scalar  
// a0 e₁ + a1 e₂ + a2 e₃
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const evector_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between evector and vector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const evector_t& a, const vector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between evector and bivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const evector_t& a, const bivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = -a0 * b3 - a1 * b4 - a2 * b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between evector and trivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 9 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t lip(const evector_t& a, const trivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b3;
    res.d[1] = a1 * b3;
    res.d[2] = a2 * b3;
    res.d[3] = a2 * b1 - a1 * b2;
    res.d[4] = a0 * b2 - a2 * b0;
    res.d[5] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between evector and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t lip(const evector_t& a, const quadvector_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between evector and horizon  
// a0 e₁ + a1 e₂ + a2 e₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const evector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between evector and origin  
// a0 e₁ + a1 e₂ + a2 e₃
// 1 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t lip(const evector_t& a, const origin_t& b) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between evector and point  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t lip(const evector_t& a, const point_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a2 * b1 - a1 * b2;
    res.d[4] = a0 * b2 - a2 * b0;
    res.d[5] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between evector and direction  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t lip(const evector_t& a, const direction_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between evector and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t lip(const evector_t& a, const ebivector_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between evector and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const evector_t& a, const ibivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between evector and evector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const evector_t& a, const evector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between evector and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const evector_t& a, const dpoint_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between evector and rotation  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t lip(const evector_t& a, const rotation_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 - a2 * b1;
    res.d[2] = a1 * b1 - a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between evector and translation  
// a0 e₁ + a1 e₂ + a2 e₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const evector_t& a, const translation_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between evector and even  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t lip(const evector_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 - a2 * b1;
    res.d[2] = a1 * b1 - a0 * b2;
    res.d[3] = -a0 * b4 - a1 * b5 - a2 * b6;
    res.d[4] = a0 * b7;
    res.d[5] = a1 * b7;
    res.d[6] = a2 * b7;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between evector and odd  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t lip(const evector_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[1] = a0 * b7;
    res.d[2] = a1 * b7;
    res.d[3] = a2 * b7;
    res.d[4] = a2 * b5 - a1 * b6;
    res.d[5] = a0 * b6 - a2 * b4;
    res.d[6] = a1 * b4 - a0 * b5;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between dpoint and scalar  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const dpoint_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between dpoint and vector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const dpoint_t& a, const vector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between dpoint and bivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const dpoint_t& a, const bivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = -a0 * b3 - a1 * b4 - a2 * b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between dpoint and trivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 9 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t lip(const dpoint_t& a, const trivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b3;
    res.d[1] = a1 * b3;
    res.d[2] = a2 * b3;
    res.d[3] = a2 * b1 - a1 * b2;
    res.d[4] = a0 * b2 - a2 * b0;
    res.d[5] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between dpoint and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t lip(const dpoint_t& a, const quadvector_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between dpoint and horizon  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const dpoint_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between dpoint and origin  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// 1 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t lip(const dpoint_t& a, const origin_t& b) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between dpoint and point  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t lip(const dpoint_t& a, const point_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a2 * b1 - a1 * b2;
    res.d[4] = a0 * b2 - a2 * b0;
    res.d[5] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between dpoint and direction  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t lip(const dpoint_t& a, const direction_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between dpoint and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t lip(const dpoint_t& a, const ebivector_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between dpoint and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const dpoint_t& a, const ibivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between dpoint and evector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const dpoint_t& a, const evector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between dpoint and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const dpoint_t& a, const dpoint_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between dpoint and rotation  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t lip(const dpoint_t& a, const rotation_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 - a2 * b1;
    res.d[2] = a1 * b1 - a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between dpoint and translation  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const dpoint_t& a, const translation_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between dpoint and even  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t lip(const dpoint_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 - a2 * b1;
    res.d[2] = a1 * b1 - a0 * b2;
    res.d[3] = -a0 * b4 - a1 * b5 - a2 * b6;
    res.d[4] = a0 * b7;
    res.d[5] = a1 * b7;
    res.d[6] = a2 * b7;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between dpoint and odd  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t lip(const dpoint_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[1] = a0 * b7;
    res.d[2] = a1 * b7;
    res.d[3] = a2 * b7;
    res.d[4] = a2 * b5 - a1 * b6;
    res.d[5] = a0 * b6 - a2 * b4;
    res.d[6] = a1 * b4 - a0 * b5;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between rotation and scalar  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b
// -> r
// 1 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const rotation_t& a, const scalar_t& b) {

    const float a0 = a.d[0];
    return a0 * b;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between rotation and vector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const rotation_t& a, const vector_t& b) {
    vector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    res.d[3] = a0 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between rotation and bivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t lip(const rotation_t& a, const bivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = -a1 * b0 - a2 * b1 - a3 * b2;
    res.d[1] = a0 * b0;
    res.d[2] = a0 * b1;
    res.d[3] = a0 * b2;
    res.d[4] = a0 * b3;
    res.d[5] = a0 * b4;
    res.d[6] = a0 * b5;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between rotation and trivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 10 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t lip(const rotation_t& a, const trivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a1 * b3;
    res.d[1] = -a2 * b3;
    res.d[2] = -a3 * b3;
    res.d[3] = a1 * b0 + a2 * b1 + a3 * b2;
    res.d[4] = a0 * b0;
    res.d[5] = a0 * b1;
    res.d[6] = a0 * b2;
    res.d[7] = a0 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between rotation and quadvector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 4 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t lip(const rotation_t& a, const quadvector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = -a1 * b0;
    res.d[5] = -a2 * b0;
    res.d[6] = -a3 * b0;
    res.d[7] = a0 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between rotation and horizon  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const rotation_t& a, const horizon_t& b) {
    vector_t res;
    const float a0 = a.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between rotation and origin  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t lip(const rotation_t& a, const origin_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = -a1;
    res.d[1] = -a2;
    res.d[2] = -a3;
    res.d[3] = 0.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between rotation and point  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t lip(const rotation_t& a, const point_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a1;
    res.d[1] = -a2;
    res.d[2] = -a3;
    res.d[3] = a1 * b0 + a2 * b1 + a3 * b2;
    res.d[4] = a0 * b0;
    res.d[5] = a0 * b1;
    res.d[6] = a0 * b2;
    res.d[7] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between rotation and direction  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t lip(const rotation_t& a, const direction_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a1 * b0 + a2 * b1 + a3 * b2;
    res.d[4] = a0 * b0;
    res.d[5] = a0 * b1;
    res.d[6] = a0 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between rotation and ebivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t lip(const rotation_t& a, const ebivector_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a1 * b0 - a2 * b1 - a3 * b2;
    res.d[1] = a0 * b0;
    res.d[2] = a0 * b1;
    res.d[3] = a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between rotation and ibivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t lip(const rotation_t& a, const ibivector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between rotation and evector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t lip(const rotation_t& a, const evector_t& b) {
    evector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between rotation and dpoint  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const rotation_t& a, const dpoint_t& b) {
    vector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    res.d[3] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between rotation and rotation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 7 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t lip(const rotation_t& a, const rotation_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0 - a1 * b1 - a2 * b2 - a3 * b3;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    res.d[3] = a0 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between rotation and translation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t lip(const rotation_t& a, const translation_t& b) {
    even_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a0 * b0;
    res.d[5] = a0 * b1;
    res.d[6] = a0 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between rotation and even  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 14 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t lip(const rotation_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0 - a1 * b1 - a2 * b2 - a3 * b3;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    res.d[3] = a0 * b3;
    res.d[4] = a0 * b4 - a1 * b7;
    res.d[5] = a0 * b5 - a2 * b7;
    res.d[6] = a0 * b6 - a3 * b7;
    res.d[7] = a0 * b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between rotation and odd  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 14 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t lip(const rotation_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0 - a1 * b7;
    res.d[1] = a0 * b1 - a2 * b7;
    res.d[2] = a0 * b2 - a3 * b7;
    res.d[3] = a0 * b3 + a1 * b4 + a2 * b5 + a3 * b6;
    res.d[4] = a0 * b4;
    res.d[5] = a0 * b5;
    res.d[6] = a0 * b6;
    res.d[7] = a0 * b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between translation and scalar  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const translation_t& a, const scalar_t& b) {

    return b;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between translation and vector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const translation_t& a, const vector_t& b) {
    vector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between translation and bivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t lip(const translation_t& a, const bivector_t& b) {
    bivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    res.d[4] = b4;
    res.d[5] = b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between translation and trivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t lip(const translation_t& a, const trivector_t& b) {
    trivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between translation and quadvector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t lip(const translation_t& a, const quadvector_t& b) {
    quadvector_t res;
    const float b0 = b.d[0];
    res.d[0] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between translation and horizon  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline horizon_t lip(const translation_t& a, const horizon_t& b) {

    return horizon_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// lip between translation and origin  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline origin_t lip(const translation_t& a, const origin_t& b) {

    return origin_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// lip between translation and point  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t lip(const translation_t& a, const point_t& b) {
    point_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between translation and direction  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t lip(const translation_t& a, const direction_t& b) {
    direction_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between translation and ebivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t lip(const translation_t& a, const ebivector_t& b) {
    ebivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between translation and ibivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t lip(const translation_t& a, const ibivector_t& b) {
    ibivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between translation and evector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t lip(const translation_t& a, const evector_t& b) {
    evector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between translation and dpoint  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + 1 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline dpoint_t lip(const translation_t& a, const dpoint_t& b) {
    dpoint_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between translation and rotation  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t lip(const translation_t& a, const rotation_t& b) {
    rotation_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between translation and translation  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline translation_t lip(const translation_t& a, const translation_t& b) {
    translation_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between translation and even  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t lip(const translation_t& a, const even_t& b) {
    even_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    res.d[4] = b4;
    res.d[5] = b5;
    res.d[6] = b6;
    res.d[7] = b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between translation and odd  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t lip(const translation_t& a, const odd_t& b) {
    odd_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    res.d[4] = b4;
    res.d[5] = b5;
    res.d[6] = b6;
    res.d[7] = b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between even and scalar  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b
// -> r
// 1 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const even_t& a, const scalar_t& b) {

    const float a0 = a.d[0];
    return a0 * b;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between even and vector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const even_t& a, const vector_t& b) {
    vector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    res.d[3] = a0 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between even and bivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t lip(const even_t& a, const bivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = -a1 * b0 - a2 * b1 - a3 * b2;
    res.d[1] = a0 * b0;
    res.d[2] = a0 * b1;
    res.d[3] = a0 * b2;
    res.d[4] = a0 * b3;
    res.d[5] = a0 * b4;
    res.d[6] = a0 * b5;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between even and trivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 10 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t lip(const even_t& a, const trivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a1 * b3;
    res.d[1] = -a2 * b3;
    res.d[2] = -a3 * b3;
    res.d[3] = a1 * b0 + a2 * b1 + a3 * b2;
    res.d[4] = a0 * b0;
    res.d[5] = a0 * b1;
    res.d[6] = a0 * b2;
    res.d[7] = a0 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between even and quadvector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 4 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t lip(const even_t& a, const quadvector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = -a1 * b0;
    res.d[5] = -a2 * b0;
    res.d[6] = -a3 * b0;
    res.d[7] = a0 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between even and horizon  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const even_t& a, const horizon_t& b) {
    vector_t res;
    const float a0 = a.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between even and origin  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t lip(const even_t& a, const origin_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = -a1;
    res.d[1] = -a2;
    res.d[2] = -a3;
    res.d[3] = 0.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between even and point  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t lip(const even_t& a, const point_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a1;
    res.d[1] = -a2;
    res.d[2] = -a3;
    res.d[3] = a1 * b0 + a2 * b1 + a3 * b2;
    res.d[4] = a0 * b0;
    res.d[5] = a0 * b1;
    res.d[6] = a0 * b2;
    res.d[7] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between even and direction  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t lip(const even_t& a, const direction_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a1 * b0 + a2 * b1 + a3 * b2;
    res.d[4] = a0 * b0;
    res.d[5] = a0 * b1;
    res.d[6] = a0 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between even and ebivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t lip(const even_t& a, const ebivector_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a1 * b0 - a2 * b1 - a3 * b2;
    res.d[1] = a0 * b0;
    res.d[2] = a0 * b1;
    res.d[3] = a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between even and ibivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t lip(const even_t& a, const ibivector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between even and evector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t lip(const even_t& a, const evector_t& b) {
    evector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between even and dpoint  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const even_t& a, const dpoint_t& b) {
    vector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    res.d[3] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between even and rotation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 7 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t lip(const even_t& a, const rotation_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0 - a1 * b1 - a2 * b2 - a3 * b3;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    res.d[3] = a0 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between even and translation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t lip(const even_t& a, const translation_t& b) {
    even_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a0 * b0;
    res.d[5] = a0 * b1;
    res.d[6] = a0 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between even and even  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 14 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t lip(const even_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0 - a1 * b1 - a2 * b2 - a3 * b3;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    res.d[3] = a0 * b3;
    res.d[4] = a0 * b4 - a1 * b7;
    res.d[5] = a0 * b5 - a2 * b7;
    res.d[6] = a0 * b6 - a3 * b7;
    res.d[7] = a0 * b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between even and odd  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 14 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t lip(const even_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0 - a1 * b7;
    res.d[1] = a0 * b1 - a2 * b7;
    res.d[2] = a0 * b2 - a3 * b7;
    res.d[3] = a0 * b3 + a1 * b4 + a2 * b5 + a3 * b6;
    res.d[4] = a0 * b4;
    res.d[5] = a0 * b5;
    res.d[6] = a0 * b6;
    res.d[7] = a0 * b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between odd and scalar  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const odd_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between odd and vector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const odd_t& a, const vector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between odd and bivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const odd_t& a, const bivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = -a0 * b3 - a1 * b4 - a2 * b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between odd and trivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 10 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t lip(const odd_t& a, const trivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a7 * b3;
    res.d[1] = a0 * b3;
    res.d[2] = a1 * b3;
    res.d[3] = a2 * b3;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between odd and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t lip(const odd_t& a, const quadvector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a7 = a.d[7], b0 = b.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a7 * b0;
    res.d[4] = a0 * b0;
    res.d[5] = a1 * b0;
    res.d[6] = a2 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between odd and horizon  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const odd_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between odd and origin  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// 1 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t lip(const odd_t& a, const origin_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a7 = a.d[7];
    res.d[0] = -a7;
    res.d[1] = a0;
    res.d[2] = a1;
    res.d[3] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between odd and point  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 6 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t lip(const odd_t& a, const point_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a7;
    res.d[1] = a0;
    res.d[2] = a1;
    res.d[3] = a2;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between odd and direction  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t lip(const odd_t& a, const direction_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between odd and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t lip(const odd_t& a, const ebivector_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between odd and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const odd_t& a, const ibivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between odd and evector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const odd_t& a, const evector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between odd and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t lip(const odd_t& a, const dpoint_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// lip between odd and rotation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t lip(const odd_t& a, const rotation_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 - a2 * b1;
    res.d[2] = a1 * b1 - a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between odd and translation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t lip(const odd_t& a, const translation_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between odd and even  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 13 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t lip(const odd_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a7 = a.d[7], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 - a2 * b1;
    res.d[2] = a1 * b1 - a0 * b2;
    res.d[3] = a7 * b7 - a0 * b4 - a1 * b5 - a2 * b6;
    res.d[4] = a0 * b7;
    res.d[5] = a1 * b7;
    res.d[6] = a2 * b7;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// lip between odd and odd  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 13 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t lip(const odd_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2 - a7 * b7;
    res.d[1] = a0 * b7;
    res.d[2] = a1 * b7;
    res.d[3] = a2 * b7;
    res.d[4] = a2 * b5 - a1 * b6;
    res.d[5] = a0 * b6 - a2 * b4;
    res.d[6] = a1 * b4 - a0 * b5;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between scalar and scalar  
// a
// b
// -> r
// 1 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const scalar_t& a, const scalar_t& b) {

    return a * b;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between scalar and vector  
// a
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const scalar_t& a, const vector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between scalar and bivector  
// a
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const scalar_t& a, const bivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between scalar and trivector  
// a
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const scalar_t& a, const trivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between scalar and quadvector  
// a
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const scalar_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between scalar and horizon  
// a
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const scalar_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between scalar and origin  
// a
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const scalar_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between scalar and point  
// a
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const scalar_t& a, const point_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between scalar and direction  
// a
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const scalar_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between scalar and ebivector  
// a
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const scalar_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between scalar and ibivector  
// a
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const scalar_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between scalar and evector  
// a
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const scalar_t& a, const evector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between scalar and dpoint  
// a
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const scalar_t& a, const dpoint_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between scalar and rotation  
// a
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r
// 1 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const scalar_t& a, const rotation_t& b) {

    const float b0 = b.d[0];
    return a * b0;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between scalar and translation  
// a
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const scalar_t& a, const translation_t& b) {

    return a;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between scalar and even  
// a
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r
// 1 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const scalar_t& a, const even_t& b) {

    const float b0 = b.d[0];
    return a * b0;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between scalar and odd  
// a
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const scalar_t& a, const odd_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between vector and scalar  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const vector_t& a, const scalar_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    res.d[3] = a3 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between vector and vector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const vector_t& a, const vector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between vector and bivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const vector_t& a, const bivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between vector and trivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const vector_t& a, const trivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between vector and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const vector_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between vector and horizon  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const vector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between vector and origin  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const vector_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between vector and point  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const vector_t& a, const point_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between vector and direction  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const vector_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between vector and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const vector_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between vector and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const vector_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between vector and evector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const vector_t& a, const evector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between vector and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const vector_t& a, const dpoint_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between vector and rotation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const vector_t& a, const rotation_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    res.d[3] = a3 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between vector and translation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const vector_t& a, const translation_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between vector and even  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const vector_t& a, const even_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    res.d[3] = a3 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between vector and odd  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const vector_t& a, const odd_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between bivector and scalar  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 6 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t rip(const bivector_t& a, const scalar_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    res.d[3] = a3 * b;
    res.d[4] = a4 * b;
    res.d[5] = a5 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between bivector and vector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const bivector_t& a, const vector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = a3 * b0 + a4 * b1 + a5 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between bivector and bivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const bivector_t& a, const bivector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return -a0 * b0 - a1 * b1 - a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between bivector and trivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const bivector_t& a, const trivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between bivector and quadvector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const bivector_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between bivector and horizon  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const bivector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between bivector and origin  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const bivector_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between bivector and point  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const bivector_t& a, const point_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between bivector and direction  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const bivector_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between bivector and ebivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const bivector_t& a, const ebivector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return -a0 * b0 - a1 * b1 - a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between bivector and ibivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const bivector_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between bivector and evector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const bivector_t& a, const evector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = a3 * b0 + a4 * b1 + a5 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between bivector and dpoint  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const bivector_t& a, const dpoint_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = a3 * b0 + a4 * b1 + a5 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between bivector and rotation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t rip(const bivector_t& a, const rotation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a0 * b1 - a1 * b2 - a2 * b3;
    res.d[1] = a0 * b0;
    res.d[2] = a1 * b0;
    res.d[3] = a2 * b0;
    res.d[4] = a3 * b0;
    res.d[5] = a4 * b0;
    res.d[6] = a5 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between bivector and translation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t rip(const bivector_t& a, const translation_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a3;
    res.d[4] = a4;
    res.d[5] = a5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between bivector and even  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t rip(const bivector_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a0 * b1 - a1 * b2 - a2 * b3;
    res.d[1] = a0 * b0;
    res.d[2] = a1 * b0;
    res.d[3] = a2 * b0;
    res.d[4] = a3 * b0;
    res.d[5] = a4 * b0;
    res.d[6] = a5 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between bivector and odd  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const bivector_t& a, const odd_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = a3 * b0 + a4 * b1 + a5 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between trivector and scalar  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t rip(const trivector_t& a, const scalar_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    res.d[3] = a3 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between trivector and vector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 9 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t rip(const trivector_t& a, const vector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b0;
    res.d[1] = a3 * b1;
    res.d[2] = a3 * b2;
    res.d[3] = a1 * b2 - a2 * b1;
    res.d[4] = a2 * b0 - a0 * b2;
    res.d[5] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between trivector and bivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 6 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const trivector_t& a, const bivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a3 * b0;
    res.d[1] = -a3 * b1;
    res.d[2] = -a3 * b2;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between trivector and trivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 1 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const trivector_t& a, const trivector_t& b) {

    const float a3 = a.d[3], b3 = b.d[3];
    return -a3 * b3;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between trivector and quadvector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const trivector_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between trivector and horizon  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const trivector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between trivector and origin  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// 1 e₁₂₃
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const trivector_t& a, const origin_t& b) {

    const float a3 = a.d[3];
    return -a3;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between trivector and point  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const trivector_t& a, const point_t& b) {

    const float a3 = a.d[3];
    return -a3;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between trivector and direction  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const trivector_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between trivector and ebivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 6 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const trivector_t& a, const ebivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a3 * b0;
    res.d[1] = -a3 * b1;
    res.d[2] = -a3 * b2;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between trivector and ibivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const trivector_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between trivector and evector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 9 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t rip(const trivector_t& a, const evector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b0;
    res.d[1] = a3 * b1;
    res.d[2] = a3 * b2;
    res.d[3] = a1 * b2 - a2 * b1;
    res.d[4] = a2 * b0 - a0 * b2;
    res.d[5] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between trivector and dpoint  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 9 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t rip(const trivector_t& a, const dpoint_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b0;
    res.d[1] = a3 * b1;
    res.d[2] = a3 * b2;
    res.d[3] = a1 * b2 - a2 * b1;
    res.d[4] = a2 * b0 - a0 * b2;
    res.d[5] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between trivector and rotation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 10 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t rip(const trivector_t& a, const rotation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a3 * b1;
    res.d[1] = -a3 * b2;
    res.d[2] = -a3 * b3;
    res.d[3] = a0 * b1 + a1 * b2 + a2 * b3;
    res.d[4] = a0 * b0;
    res.d[5] = a1 * b0;
    res.d[6] = a2 * b0;
    res.d[7] = a3 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between trivector and translation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t rip(const trivector_t& a, const translation_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between trivector and even  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 10 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t rip(const trivector_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a3 * b1;
    res.d[1] = -a3 * b2;
    res.d[2] = -a3 * b3;
    res.d[3] = a0 * b1 + a1 * b2 + a2 * b3;
    res.d[4] = a0 * b0;
    res.d[5] = a1 * b0;
    res.d[6] = a2 * b0;
    res.d[7] = a3 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between trivector and odd  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 10 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t rip(const trivector_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b7 = b.d[7];
    res.d[0] = -a3 * b7;
    res.d[1] = a3 * b0;
    res.d[2] = a3 * b1;
    res.d[3] = a3 * b2;
    res.d[4] = a1 * b2 - a2 * b1;
    res.d[5] = a2 * b0 - a0 * b2;
    res.d[6] = a0 * b1 - a1 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between quadvector and scalar  
// a0 e₀₁₂₃
// b
// -> r0 e₀₁₂₃
// 1 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t rip(const quadvector_t& a, const scalar_t& b) {
    quadvector_t res;
    const float a0 = a.d[0];
    res.d[0] = a0 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between quadvector and vector  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t rip(const quadvector_t& a, const vector_t& b) {
    direction_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0 * b0;
    res.d[1] = -a0 * b1;
    res.d[2] = -a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between quadvector and bivector  
// a0 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t rip(const quadvector_t& a, const bivector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0 * b0;
    res.d[1] = -a0 * b1;
    res.d[2] = -a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between quadvector and trivector  
// a0 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 1 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const quadvector_t& a, const trivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between quadvector and quadvector  
// a0 e₀₁₂₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const quadvector_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between quadvector and horizon  
// a0 e₀₁₂₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const quadvector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between quadvector and origin  
// a0 e₀₁₂₃
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const quadvector_t& a, const origin_t& b) {
    vector_t res;
    const float a0 = a.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between quadvector and point  
// a0 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const quadvector_t& a, const point_t& b) {
    vector_t res;
    const float a0 = a.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between quadvector and direction  
// a0 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const quadvector_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between quadvector and ebivector  
// a0 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t rip(const quadvector_t& a, const ebivector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0 * b0;
    res.d[1] = -a0 * b1;
    res.d[2] = -a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between quadvector and ibivector  
// a0 e₀₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const quadvector_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between quadvector and evector  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t rip(const quadvector_t& a, const evector_t& b) {
    direction_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0 * b0;
    res.d[1] = -a0 * b1;
    res.d[2] = -a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between quadvector and dpoint  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t rip(const quadvector_t& a, const dpoint_t& b) {
    direction_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0 * b0;
    res.d[1] = -a0 * b1;
    res.d[2] = -a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between quadvector and rotation  
// a0 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 4 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t rip(const quadvector_t& a, const rotation_t& b) {
    even_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = -a0 * b1;
    res.d[5] = -a0 * b2;
    res.d[6] = -a0 * b3;
    res.d[7] = a0 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between quadvector and translation  
// a0 e₀₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t rip(const quadvector_t& a, const translation_t& b) {
    quadvector_t res;
    const float a0 = a.d[0];
    res.d[0] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between quadvector and even  
// a0 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 4 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t rip(const quadvector_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = -a0 * b1;
    res.d[5] = -a0 * b2;
    res.d[6] = -a0 * b3;
    res.d[7] = a0 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between quadvector and odd  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 4 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t rip(const quadvector_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b7 = b.d[7];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b7;
    res.d[4] = -a0 * b0;
    res.d[5] = -a0 * b1;
    res.d[6] = -a0 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between horizon and scalar  
// 1 e₀
// b
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const horizon_t& a, const scalar_t& b) {
    vector_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between horizon and vector  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const horizon_t& a, const vector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between horizon and bivector  
// 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const horizon_t& a, const bivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between horizon and trivector  
// 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const horizon_t& a, const trivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between horizon and quadvector  
// 1 e₀
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const horizon_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between horizon and horizon  
// 1 e₀
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const horizon_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between horizon and origin  
// 1 e₀
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const horizon_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between horizon and point  
// 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const horizon_t& a, const point_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between horizon and direction  
// 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const horizon_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between horizon and ebivector  
// 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const horizon_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between horizon and ibivector  
// 1 e₀
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const horizon_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between horizon and evector  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const horizon_t& a, const evector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between horizon and dpoint  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const horizon_t& a, const dpoint_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between horizon and rotation  
// 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const horizon_t& a, const rotation_t& b) {
    vector_t res;
    const float b0 = b.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between horizon and translation  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline horizon_t rip(const horizon_t& a, const translation_t& b) {

    return horizon_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// rip between horizon and even  
// 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const horizon_t& a, const even_t& b) {
    vector_t res;
    const float b0 = b.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between horizon and odd  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const horizon_t& a, const odd_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between origin and scalar  
// 1 e₁₂₃
// b
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t rip(const origin_t& a, const scalar_t& b) {
    trivector_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between origin and vector  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t rip(const origin_t& a, const vector_t& b) {
    ebivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between origin and bivector  
// 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t rip(const origin_t& a, const bivector_t& b) {
    evector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between origin and trivector  
// 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const origin_t& a, const trivector_t& b) {

    const float b3 = b.d[3];
    return -b3;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between origin and quadvector  
// 1 e₁₂₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const origin_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between origin and horizon  
// 1 e₁₂₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const origin_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between origin and origin  
// 1 e₁₂₃
// 1 e₁₂₃
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const origin_t& a, const origin_t& b) {

    return -1;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between origin and point  
// 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const origin_t& a, const point_t& b) {

    return -1;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between origin and direction  
// 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const origin_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between origin and ebivector  
// 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t rip(const origin_t& a, const ebivector_t& b) {
    evector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between origin and ibivector  
// 1 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const origin_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between origin and evector  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t rip(const origin_t& a, const evector_t& b) {
    ebivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between origin and dpoint  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t rip(const origin_t& a, const dpoint_t& b) {
    ebivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between origin and rotation  
// 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t rip(const origin_t& a, const rotation_t& b) {
    odd_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -b1;
    res.d[1] = -b2;
    res.d[2] = -b3;
    res.d[3] = 0.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between origin and translation  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline origin_t rip(const origin_t& a, const translation_t& b) {

    return origin_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// rip between origin and even  
// 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t rip(const origin_t& a, const even_t& b) {
    odd_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -b1;
    res.d[1] = -b2;
    res.d[2] = -b3;
    res.d[3] = 0.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between origin and odd  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t rip(const origin_t& a, const odd_t& b) {
    rotation_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b7 = b.d[7];
    res.d[0] = -b7;
    res.d[1] = b0;
    res.d[2] = b1;
    res.d[3] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between point and scalar  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t rip(const point_t& a, const scalar_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    res.d[3] = b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between point and vector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t rip(const point_t& a, const vector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = a1 * b2 - a2 * b1;
    res.d[4] = a2 * b0 - a0 * b2;
    res.d[5] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between point and bivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const point_t& a, const bivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between point and trivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const point_t& a, const trivector_t& b) {

    const float b3 = b.d[3];
    return -b3;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between point and quadvector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const point_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between point and horizon  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const point_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between point and origin  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// 1 e₁₂₃
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const point_t& a, const origin_t& b) {

    return -1;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between point and point  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const point_t& a, const point_t& b) {

    return -1;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between point and direction  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const point_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between point and ebivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const point_t& a, const ebivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between point and ibivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const point_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between point and evector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t rip(const point_t& a, const evector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = a1 * b2 - a2 * b1;
    res.d[4] = a2 * b0 - a0 * b2;
    res.d[5] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between point and dpoint  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t rip(const point_t& a, const dpoint_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = a1 * b2 - a2 * b1;
    res.d[4] = a2 * b0 - a0 * b2;
    res.d[5] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between point and rotation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t rip(const point_t& a, const rotation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -b1;
    res.d[1] = -b2;
    res.d[2] = -b3;
    res.d[3] = a0 * b1 + a1 * b2 + a2 * b3;
    res.d[4] = a0 * b0;
    res.d[5] = a1 * b0;
    res.d[6] = a2 * b0;
    res.d[7] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between point and translation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t rip(const point_t& a, const translation_t& b) {
    point_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between point and even  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t rip(const point_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -b1;
    res.d[1] = -b2;
    res.d[2] = -b3;
    res.d[3] = a0 * b1 + a1 * b2 + a2 * b3;
    res.d[4] = a0 * b0;
    res.d[5] = a1 * b0;
    res.d[6] = a2 * b0;
    res.d[7] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between point and odd  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 6 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t rip(const point_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b7 = b.d[7];
    res.d[0] = -b7;
    res.d[1] = b0;
    res.d[2] = b1;
    res.d[3] = b2;
    res.d[4] = a1 * b2 - a2 * b1;
    res.d[5] = a2 * b0 - a0 * b2;
    res.d[6] = a0 * b1 - a1 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between direction and scalar  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t rip(const direction_t& a, const scalar_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between direction and vector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t rip(const direction_t& a, const vector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between direction and bivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const direction_t& a, const bivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between direction and trivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const direction_t& a, const trivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between direction and quadvector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const direction_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between direction and horizon  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const direction_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between direction and origin  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const direction_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between direction and point  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const direction_t& a, const point_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between direction and direction  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const direction_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between direction and ebivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const direction_t& a, const ebivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between direction and ibivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const direction_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between direction and evector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t rip(const direction_t& a, const evector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between direction and dpoint  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t rip(const direction_t& a, const dpoint_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between direction and rotation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t rip(const direction_t& a, const rotation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b1 + a1 * b2 + a2 * b3;
    res.d[4] = a0 * b0;
    res.d[5] = a1 * b0;
    res.d[6] = a2 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between direction and translation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t rip(const direction_t& a, const translation_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between direction and even  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t rip(const direction_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b1 + a1 * b2 + a2 * b3;
    res.d[4] = a0 * b0;
    res.d[5] = a1 * b0;
    res.d[6] = a2 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between direction and odd  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t rip(const direction_t& a, const odd_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between ebivector and scalar  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t rip(const ebivector_t& a, const scalar_t& b) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between ebivector and vector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t rip(const ebivector_t& a, const vector_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between ebivector and bivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const ebivector_t& a, const bivector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return -a0 * b0 - a1 * b1 - a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between ebivector and trivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const ebivector_t& a, const trivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between ebivector and quadvector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const ebivector_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between ebivector and horizon  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const ebivector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between ebivector and origin  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const ebivector_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between ebivector and point  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const ebivector_t& a, const point_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between ebivector and direction  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const ebivector_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between ebivector and ebivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const ebivector_t& a, const ebivector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return -a0 * b0 - a1 * b1 - a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between ebivector and ibivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const ebivector_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between ebivector and evector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t rip(const ebivector_t& a, const evector_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between ebivector and dpoint  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t rip(const ebivector_t& a, const dpoint_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between ebivector and rotation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t rip(const ebivector_t& a, const rotation_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a0 * b1 - a1 * b2 - a2 * b3;
    res.d[1] = a0 * b0;
    res.d[2] = a1 * b0;
    res.d[3] = a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between ebivector and translation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t rip(const ebivector_t& a, const translation_t& b) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between ebivector and even  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t rip(const ebivector_t& a, const even_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a0 * b1 - a1 * b2 - a2 * b3;
    res.d[1] = a0 * b0;
    res.d[2] = a1 * b0;
    res.d[3] = a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between ebivector and odd  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t rip(const ebivector_t& a, const odd_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between ibivector and scalar  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t rip(const ibivector_t& a, const scalar_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between ibivector and vector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const ibivector_t& a, const vector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between ibivector and bivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const ibivector_t& a, const bivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between ibivector and trivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const ibivector_t& a, const trivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between ibivector and quadvector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const ibivector_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between ibivector and horizon  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const ibivector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between ibivector and origin  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const ibivector_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between ibivector and point  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const ibivector_t& a, const point_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between ibivector and direction  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const ibivector_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between ibivector and ebivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const ibivector_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between ibivector and ibivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const ibivector_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between ibivector and evector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const ibivector_t& a, const evector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between ibivector and dpoint  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const ibivector_t& a, const dpoint_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between ibivector and rotation  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t rip(const ibivector_t& a, const rotation_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between ibivector and translation  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t rip(const ibivector_t& a, const translation_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between ibivector and even  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t rip(const ibivector_t& a, const even_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between ibivector and odd  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const ibivector_t& a, const odd_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between evector and scalar  
// a0 e₁ + a1 e₂ + a2 e₃
// b
// -> r0 e₁ + r1 e₂ + r2 e₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t rip(const evector_t& a, const scalar_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between evector and vector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const evector_t& a, const vector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between evector and bivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const evector_t& a, const bivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between evector and trivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const evector_t& a, const trivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between evector and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const evector_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between evector and horizon  
// a0 e₁ + a1 e₂ + a2 e₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const evector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between evector and origin  
// a0 e₁ + a1 e₂ + a2 e₃
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const evector_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between evector and point  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const evector_t& a, const point_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between evector and direction  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const evector_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between evector and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const evector_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between evector and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const evector_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between evector and evector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const evector_t& a, const evector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between evector and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const evector_t& a, const dpoint_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between evector and rotation  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t rip(const evector_t& a, const rotation_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between evector and translation  
// a0 e₁ + a1 e₂ + a2 e₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t rip(const evector_t& a, const translation_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between evector and even  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t rip(const evector_t& a, const even_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between evector and odd  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const evector_t& a, const odd_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between dpoint and scalar  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const dpoint_t& a, const scalar_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    res.d[3] = b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between dpoint and vector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const dpoint_t& a, const vector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between dpoint and bivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const dpoint_t& a, const bivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between dpoint and trivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const dpoint_t& a, const trivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between dpoint and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const dpoint_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between dpoint and horizon  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const dpoint_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between dpoint and origin  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const dpoint_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between dpoint and point  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const dpoint_t& a, const point_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between dpoint and direction  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const dpoint_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between dpoint and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const dpoint_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between dpoint and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const dpoint_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between dpoint and evector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const dpoint_t& a, const evector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between dpoint and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const dpoint_t& a, const dpoint_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between dpoint and rotation  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const dpoint_t& a, const rotation_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    res.d[3] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between dpoint and translation  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + 1 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline dpoint_t rip(const dpoint_t& a, const translation_t& b) {
    dpoint_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between dpoint and even  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const dpoint_t& a, const even_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    res.d[3] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between dpoint and odd  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const dpoint_t& a, const odd_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between rotation and scalar  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t rip(const rotation_t& a, const scalar_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    res.d[3] = a3 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between rotation and vector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t rip(const rotation_t& a, const vector_t& b) {
    evector_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b1 - a2 * b2;
    res.d[1] = a1 * b2 - a3 * b0;
    res.d[2] = a2 * b0 - a1 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between rotation and bivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const rotation_t& a, const bivector_t& b) {

    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return -a1 * b0 - a2 * b1 - a3 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between rotation and trivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const rotation_t& a, const trivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between rotation and quadvector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const rotation_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between rotation and horizon  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const rotation_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between rotation and origin  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const rotation_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between rotation and point  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const rotation_t& a, const point_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between rotation and direction  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const rotation_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between rotation and ebivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const rotation_t& a, const ebivector_t& b) {

    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return -a1 * b0 - a2 * b1 - a3 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between rotation and ibivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const rotation_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between rotation and evector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t rip(const rotation_t& a, const evector_t& b) {
    evector_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b1 - a2 * b2;
    res.d[1] = a1 * b2 - a3 * b0;
    res.d[2] = a2 * b0 - a1 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between rotation and dpoint  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t rip(const rotation_t& a, const dpoint_t& b) {
    evector_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b1 - a2 * b2;
    res.d[1] = a1 * b2 - a3 * b0;
    res.d[2] = a2 * b0 - a1 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between rotation and rotation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 7 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t rip(const rotation_t& a, const rotation_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0 - a1 * b1 - a2 * b2 - a3 * b3;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    res.d[3] = a3 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between rotation and translation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t rip(const rotation_t& a, const translation_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between rotation and even  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 7 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t rip(const rotation_t& a, const even_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0 - a1 * b1 - a2 * b2 - a3 * b3;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    res.d[3] = a3 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between rotation and odd  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t rip(const rotation_t& a, const odd_t& b) {
    evector_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b1 - a2 * b2;
    res.d[1] = a1 * b2 - a3 * b0;
    res.d[2] = a2 * b0 - a1 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between translation and scalar  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t rip(const translation_t& a, const scalar_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = b;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a0 * b;
    res.d[5] = a1 * b;
    res.d[6] = a2 * b;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between translation and vector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const translation_t& a, const vector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between translation and bivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const translation_t& a, const bivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between translation and trivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const translation_t& a, const trivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between translation and quadvector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const translation_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between translation and horizon  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const translation_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between translation and origin  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const translation_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between translation and point  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const translation_t& a, const point_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between translation and direction  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const translation_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between translation and ebivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const translation_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between translation and ibivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const translation_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between translation and evector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const translation_t& a, const evector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between translation and dpoint  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const translation_t& a, const dpoint_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between translation and rotation  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t rip(const translation_t& a, const rotation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = b0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a0 * b0;
    res.d[5] = a1 * b0;
    res.d[6] = a2 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between translation and translation  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline translation_t rip(const translation_t& a, const translation_t& b) {
    translation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between translation and even  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t rip(const translation_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = b0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a0 * b0;
    res.d[5] = a1 * b0;
    res.d[6] = a2 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between translation and odd  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const translation_t& a, const odd_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between even and scalar  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 8 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t rip(const even_t& a, const scalar_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    res.d[3] = a3 * b;
    res.d[4] = a4 * b;
    res.d[5] = a5 * b;
    res.d[6] = a6 * b;
    res.d[7] = a7 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between even and vector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t rip(const even_t& a, const vector_t& b) {
    odd_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b1 - a2 * b2;
    res.d[1] = a1 * b2 - a3 * b0;
    res.d[2] = a2 * b0 - a1 * b1;
    res.d[3] = a4 * b0 + a5 * b1 + a6 * b2;
    res.d[4] = -a7 * b0;
    res.d[5] = -a7 * b1;
    res.d[6] = -a7 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between even and bivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 6 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t rip(const even_t& a, const bivector_t& b) {
    even_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a1 * b0 - a2 * b1 - a3 * b2;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = -a7 * b0;
    res.d[5] = -a7 * b1;
    res.d[6] = -a7 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between even and trivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 1 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const even_t& a, const trivector_t& b) {
    vector_t res;
    const float a7 = a.d[7], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a7 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between even and quadvector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const even_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between even and horizon  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const even_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between even and origin  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const even_t& a, const origin_t& b) {
    vector_t res;
    const float a7 = a.d[7];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between even and point  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const even_t& a, const point_t& b) {
    vector_t res;
    const float a7 = a.d[7];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between even and direction  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const even_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between even and ebivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 6 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t rip(const even_t& a, const ebivector_t& b) {
    even_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a1 * b0 - a2 * b1 - a3 * b2;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = -a7 * b0;
    res.d[5] = -a7 * b1;
    res.d[6] = -a7 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between even and ibivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const even_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between even and evector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t rip(const even_t& a, const evector_t& b) {
    odd_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b1 - a2 * b2;
    res.d[1] = a1 * b2 - a3 * b0;
    res.d[2] = a2 * b0 - a1 * b1;
    res.d[3] = a4 * b0 + a5 * b1 + a6 * b2;
    res.d[4] = -a7 * b0;
    res.d[5] = -a7 * b1;
    res.d[6] = -a7 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between even and dpoint  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t rip(const even_t& a, const dpoint_t& b) {
    odd_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b1 - a2 * b2;
    res.d[1] = a1 * b2 - a3 * b0;
    res.d[2] = a2 * b0 - a1 * b1;
    res.d[3] = a4 * b0 + a5 * b1 + a6 * b2;
    res.d[4] = -a7 * b0;
    res.d[5] = -a7 * b1;
    res.d[6] = -a7 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between even and rotation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 14 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t rip(const even_t& a, const rotation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0 - a1 * b1 - a2 * b2 - a3 * b3;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    res.d[3] = a3 * b0;
    res.d[4] = a4 * b0 - a7 * b1;
    res.d[5] = a5 * b0 - a7 * b2;
    res.d[6] = a6 * b0 - a7 * b3;
    res.d[7] = a7 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between even and translation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t rip(const even_t& a, const translation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a3;
    res.d[4] = a4;
    res.d[5] = a5;
    res.d[6] = a6;
    res.d[7] = a7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between even and even  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 14 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t rip(const even_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0 - a1 * b1 - a2 * b2 - a3 * b3;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    res.d[3] = a3 * b0;
    res.d[4] = a4 * b0 - a7 * b1;
    res.d[5] = a5 * b0 - a7 * b2;
    res.d[6] = a6 * b0 - a7 * b3;
    res.d[7] = a7 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between even and odd  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 13 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t rip(const even_t& a, const odd_t& b) {
    odd_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b7 = b.d[7];
    res.d[0] = a3 * b1 - a2 * b2;
    res.d[1] = a1 * b2 - a3 * b0;
    res.d[2] = a2 * b0 - a1 * b1;
    res.d[3] = a4 * b0 + a5 * b1 + a6 * b2 - a7 * b7;
    res.d[4] = -a7 * b0;
    res.d[5] = -a7 * b1;
    res.d[6] = -a7 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between odd and scalar  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 8 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t rip(const odd_t& a, const scalar_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7];
    res.d[0] = a0 * b;
    res.d[1] = a1 * b;
    res.d[2] = a2 * b;
    res.d[3] = a3 * b;
    res.d[4] = a4 * b;
    res.d[5] = a5 * b;
    res.d[6] = a6 * b;
    res.d[7] = a7 * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between odd and vector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t rip(const odd_t& a, const vector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[1] = a7 * b0;
    res.d[2] = a7 * b1;
    res.d[3] = a7 * b2;
    res.d[4] = a5 * b2 - a6 * b1;
    res.d[5] = a6 * b0 - a4 * b2;
    res.d[6] = a4 * b1 - a5 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between odd and bivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 6 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const odd_t& a, const bivector_t& b) {
    vector_t res;
    const float a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a7 * b0;
    res.d[1] = -a7 * b1;
    res.d[2] = -a7 * b2;
    res.d[3] = a4 * b0 + a5 * b1 + a6 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between odd and trivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 1 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const odd_t& a, const trivector_t& b) {

    const float a7 = a.d[7], b3 = b.d[3];
    return -a7 * b3;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between odd and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const odd_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between odd and horizon  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const odd_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between odd and origin  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// 1 e₁₂₃
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const odd_t& a, const origin_t& b) {

    const float a7 = a.d[7];
    return -a7;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between odd and point  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const odd_t& a, const point_t& b) {

    const float a7 = a.d[7];
    return -a7;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between odd and direction  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const odd_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between odd and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 6 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t rip(const odd_t& a, const ebivector_t& b) {
    vector_t res;
    const float a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a7 * b0;
    res.d[1] = -a7 * b1;
    res.d[2] = -a7 * b2;
    res.d[3] = a4 * b0 + a5 * b1 + a6 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between odd and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t rip(const odd_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rip between odd and evector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t rip(const odd_t& a, const evector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[1] = a7 * b0;
    res.d[2] = a7 * b1;
    res.d[3] = a7 * b2;
    res.d[4] = a5 * b2 - a6 * b1;
    res.d[5] = a6 * b0 - a4 * b2;
    res.d[6] = a4 * b1 - a5 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between odd and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t rip(const odd_t& a, const dpoint_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[1] = a7 * b0;
    res.d[2] = a7 * b1;
    res.d[3] = a7 * b2;
    res.d[4] = a5 * b2 - a6 * b1;
    res.d[5] = a6 * b0 - a4 * b2;
    res.d[6] = a4 * b1 - a5 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between odd and rotation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 14 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t rip(const odd_t& a, const rotation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0 - a7 * b1;
    res.d[1] = a1 * b0 - a7 * b2;
    res.d[2] = a2 * b0 - a7 * b3;
    res.d[3] = a3 * b0 + a4 * b1 + a5 * b2 + a6 * b3;
    res.d[4] = a4 * b0;
    res.d[5] = a5 * b0;
    res.d[6] = a6 * b0;
    res.d[7] = a7 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between odd and translation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t rip(const odd_t& a, const translation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a3;
    res.d[4] = a4;
    res.d[5] = a5;
    res.d[6] = a6;
    res.d[7] = a7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between odd and even  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 14 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t rip(const odd_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0 - a7 * b1;
    res.d[1] = a1 * b0 - a7 * b2;
    res.d[2] = a2 * b0 - a7 * b3;
    res.d[3] = a3 * b0 + a4 * b1 + a5 * b2 + a6 * b3;
    res.d[4] = a4 * b0;
    res.d[5] = a5 * b0;
    res.d[6] = a6 * b0;
    res.d[7] = a7 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rip between odd and odd  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 13 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t rip(const odd_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b7 = b.d[7];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2 - a7 * b7;
    res.d[1] = a7 * b0;
    res.d[2] = a7 * b1;
    res.d[3] = a7 * b2;
    res.d[4] = a5 * b2 - a6 * b1;
    res.d[5] = a6 * b0 - a4 * b2;
    res.d[6] = a4 * b1 - a5 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// reverse of vector
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator~(const vector_t& a) {
    vector_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// reverse of bivector
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 0 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator~(const bivector_t& a) {
    bivector_t res;
    res.d[0] = -a.d[0];
    res.d[1] = -a.d[1];
    res.d[2] = -a.d[2];
    res.d[3] = -a.d[3];
    res.d[4] = -a.d[4];
    res.d[5] = -a.d[5];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// reverse of trivector
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator~(const trivector_t& a) {
    trivector_t res;
    res.d[0] = -a.d[0];
    res.d[1] = -a.d[1];
    res.d[2] = -a.d[2];
    res.d[3] = -a.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// reverse of quadvector
// a0 e₀₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator~(const quadvector_t& a) {
    quadvector_t res;
    res.d[0] = a.d[0];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// reverse of horizon

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline horizon_t operator~(const horizon_t& a) {

    return horizon_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// reverse of origin
// 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator~(const origin_t& a) {
    trivector_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// reverse of point
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator~(const point_t& a) {
    trivector_t res;
    res.d[0] = -a.d[0];
    res.d[1] = -a.d[1];
    res.d[2] = -a.d[2];
    res.d[3] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// reverse of direction
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator~(const direction_t& a) {
    direction_t res;
    res.d[0] = -a.d[0];
    res.d[1] = -a.d[1];
    res.d[2] = -a.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// reverse of ebivector
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator~(const ebivector_t& a) {
    ebivector_t res;
    res.d[0] = -a.d[0];
    res.d[1] = -a.d[1];
    res.d[2] = -a.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// reverse of ibivector
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator~(const ibivector_t& a) {
    ibivector_t res;
    res.d[0] = -a.d[0];
    res.d[1] = -a.d[1];
    res.d[2] = -a.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// reverse of evector
// a0 e₁ + a1 e₂ + a2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator~(const evector_t& a) {
    evector_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// reverse of dpoint
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + 1 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline dpoint_t operator~(const dpoint_t& a) {
    dpoint_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// reverse of rotation
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator~(const rotation_t& a) {
    rotation_t res;
    res.d[0] = a.d[0];
    res.d[1] = -a.d[1];
    res.d[2] = -a.d[2];
    res.d[3] = -a.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// reverse of translation
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline translation_t operator~(const translation_t& a) {
    translation_t res;
    res.d[0] = -a.d[0];
    res.d[1] = -a.d[1];
    res.d[2] = -a.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// reverse of even
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator~(const even_t& a) {
    even_t res;
    res.d[0] = a.d[0];
    res.d[1] = -a.d[1];
    res.d[2] = -a.d[2];
    res.d[3] = -a.d[3];
    res.d[4] = -a.d[4];
    res.d[5] = -a.d[5];
    res.d[6] = -a.d[6];
    res.d[7] = a.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// reverse of odd
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator~(const odd_t& a) {
    odd_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    res.d[4] = -a.d[4];
    res.d[5] = -a.d[5];
    res.d[6] = -a.d[6];
    res.d[7] = -a.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// involute of scalar
// a
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t involute(const scalar_t& a) {

    return a;

}

////////////////////////////////////////////////////////////////////////////////  
// involute of vector
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t involute(const vector_t& a) {
    vector_t res;
    res.d[0] = -a.d[0];
    res.d[1] = -a.d[1];
    res.d[2] = -a.d[2];
    res.d[3] = -a.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// involute of bivector
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t involute(const bivector_t& a) {
    bivector_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    res.d[4] = a.d[4];
    res.d[5] = a.d[5];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// involute of trivector
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t involute(const trivector_t& a) {
    trivector_t res;
    res.d[0] = -a.d[0];
    res.d[1] = -a.d[1];
    res.d[2] = -a.d[2];
    res.d[3] = -a.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// involute of quadvector
// a0 e₀₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t involute(const quadvector_t& a) {
    quadvector_t res;
    res.d[0] = a.d[0];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// involute of horizon
// 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t involute(const horizon_t& a) {
    vector_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// involute of origin
// 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t involute(const origin_t& a) {
    trivector_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// involute of point
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t involute(const point_t& a) {
    trivector_t res;
    res.d[0] = -a.d[0];
    res.d[1] = -a.d[1];
    res.d[2] = -a.d[2];
    res.d[3] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// involute of direction
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t involute(const direction_t& a) {
    direction_t res;
    res.d[0] = -a.d[0];
    res.d[1] = -a.d[1];
    res.d[2] = -a.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// involute of ebivector
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t involute(const ebivector_t& a) {
    ebivector_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// involute of ibivector
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t involute(const ibivector_t& a) {
    ibivector_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// involute of evector
// a0 e₁ + a1 e₂ + a2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t involute(const evector_t& a) {
    evector_t res;
    res.d[0] = -a.d[0];
    res.d[1] = -a.d[1];
    res.d[2] = -a.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// involute of dpoint
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t involute(const dpoint_t& a) {
    vector_t res;
    res.d[0] = -a.d[0];
    res.d[1] = -a.d[1];
    res.d[2] = -a.d[2];
    res.d[3] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// involute of rotation
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t involute(const rotation_t& a) {
    rotation_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// involute of translation
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline translation_t involute(const translation_t& a) {
    translation_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// involute of even
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t involute(const even_t& a) {
    even_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    res.d[4] = a.d[4];
    res.d[5] = a.d[5];
    res.d[6] = a.d[6];
    res.d[7] = a.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// involute of odd
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t involute(const odd_t& a) {
    odd_t res;
    res.d[0] = -a.d[0];
    res.d[1] = -a.d[1];
    res.d[2] = -a.d[2];
    res.d[3] = -a.d[3];
    res.d[4] = -a.d[4];
    res.d[5] = -a.d[5];
    res.d[6] = -a.d[6];
    res.d[7] = -a.d[7];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// conjugate of scalar
// a
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t conjugate(const scalar_t& a) {

    return a;

}

////////////////////////////////////////////////////////////////////////////////  
// conjugate of vector
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t conjugate(const vector_t& a) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    res.d[3] = -a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// conjugate of bivector
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 0 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t conjugate(const bivector_t& a) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    res.d[3] = -a3;
    res.d[4] = -a4;
    res.d[5] = -a5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// conjugate of trivector
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t conjugate(const trivector_t& a) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// conjugate of quadvector
// a0 e₀₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t conjugate(const quadvector_t& a) {
    quadvector_t res;
    const float a0 = a.d[0];
    res.d[0] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// conjugate of horizon
// 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t conjugate(const horizon_t& a) {
    vector_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// conjugate of origin

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline origin_t conjugate(const origin_t& a) {

    return origin_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// conjugate of point
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t conjugate(const point_t& a) {
    point_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// conjugate of direction
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t conjugate(const direction_t& a) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// conjugate of ebivector
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t conjugate(const ebivector_t& a) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// conjugate of ibivector
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t conjugate(const ibivector_t& a) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// conjugate of evector
// a0 e₁ + a1 e₂ + a2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t conjugate(const evector_t& a) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// conjugate of dpoint
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t conjugate(const dpoint_t& a) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    res.d[3] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// conjugate of rotation
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t conjugate(const rotation_t& a) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    res.d[3] = -a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// conjugate of translation
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline translation_t conjugate(const translation_t& a) {
    translation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// conjugate of even
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t conjugate(const even_t& a) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7];
    res.d[0] = a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    res.d[3] = -a3;
    res.d[4] = -a4;
    res.d[5] = -a5;
    res.d[6] = -a6;
    res.d[7] = a7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// conjugate of odd
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t conjugate(const odd_t& a) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    res.d[3] = -a3;
    res.d[4] = a4;
    res.d[5] = a5;
    res.d[6] = a6;
    res.d[7] = a7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// dual of vector
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator!(const vector_t& a) {
    trivector_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    res.d[3] = a.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// dual of bivector
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator!(const bivector_t& a) {
    bivector_t res;
    res.d[0] = a.d[3];
    res.d[1] = a.d[4];
    res.d[2] = a.d[5];
    res.d[3] = a.d[0];
    res.d[4] = a.d[1];
    res.d[5] = a.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// dual of trivector
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator!(const trivector_t& a) {
    vector_t res;
    res.d[0] = -a.d[0];
    res.d[1] = -a.d[1];
    res.d[2] = -a.d[2];
    res.d[3] = -a.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// dual of quadvector
// a0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator!(const quadvector_t& a) {

    return a.d[0];

}

////////////////////////////////////////////////////////////////////////////////  
// dual of horizon

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline origin_t operator!(const horizon_t& a) {

    return origin_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// dual of origin
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator!(const origin_t& a) {
    vector_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// dual of point
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator!(const point_t& a) {
    vector_t res;
    res.d[0] = -a.d[0];
    res.d[1] = -a.d[1];
    res.d[2] = -a.d[2];
    res.d[3] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// dual of direction
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator!(const direction_t& a) {
    evector_t res;
    res.d[0] = -a.d[0];
    res.d[1] = -a.d[1];
    res.d[2] = -a.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// dual of ebivector
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator!(const ebivector_t& a) {
    ibivector_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// dual of ibivector
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator!(const ibivector_t& a) {
    ebivector_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// dual of evector
// a0 e₁ + a1 e₂ + a2 e₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator!(const evector_t& a) {
    direction_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// dual of dpoint
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t operator!(const dpoint_t& a) {
    point_t res;
    res.d[0] = a.d[0];
    res.d[1] = a.d[1];
    res.d[2] = a.d[2];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// dual of rotation
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator!(const rotation_t& a) {
    even_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a.d[1];
    res.d[5] = a.d[2];
    res.d[6] = a.d[3];
    res.d[7] = a.d[0];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// dual of translation
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator!(const translation_t& a) {
    even_t res;
    res.d[0] = 0.0;
    res.d[1] = a.d[0];
    res.d[2] = a.d[1];
    res.d[3] = a.d[2];
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// dual of even
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator!(const even_t& a) {
    even_t res;
    res.d[0] = a.d[7];
    res.d[1] = a.d[4];
    res.d[2] = a.d[5];
    res.d[3] = a.d[6];
    res.d[4] = a.d[1];
    res.d[5] = a.d[2];
    res.d[6] = a.d[3];
    res.d[7] = a.d[0];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// dual of odd
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator!(const odd_t& a) {
    odd_t res;
    res.d[0] = -a.d[4];
    res.d[1] = -a.d[5];
    res.d[2] = -a.d[6];
    res.d[3] = -a.d[7];
    res.d[4] = a.d[0];
    res.d[5] = a.d[1];
    res.d[6] = a.d[2];
    res.d[7] = a.d[3];
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// undual of scalar
// a
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t undual(const scalar_t& a) {
    quadvector_t res;
    res.d[0] = a;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// undual of vector
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t undual(const vector_t& a) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    res.d[3] = -a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// undual of bivector
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t undual(const bivector_t& a) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5];
    res.d[0] = a3;
    res.d[1] = a4;
    res.d[2] = a5;
    res.d[3] = a0;
    res.d[4] = a1;
    res.d[5] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// undual of trivector
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t undual(const trivector_t& a) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// undual of quadvector
// a0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t undual(const quadvector_t& a) {

    const float a0 = a.d[0];
    return a0;

}

////////////////////////////////////////////////////////////////////////////////  
// undual of horizon
// 1 e₀
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t undual(const horizon_t& a) {
    trivector_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// undual of origin

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline horizon_t undual(const origin_t& a) {

    return horizon_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// undual of point
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + 1 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline dpoint_t undual(const point_t& a) {
    dpoint_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// undual of direction
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t undual(const direction_t& a) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// undual of ebivector
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t undual(const ebivector_t& a) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// undual of ibivector
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t undual(const ibivector_t& a) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// undual of evector
// a0 e₁ + a1 e₂ + a2 e₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t undual(const evector_t& a) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// undual of dpoint
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t undual(const dpoint_t& a) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    res.d[3] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// undual of rotation
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t undual(const rotation_t& a) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a1;
    res.d[5] = a2;
    res.d[6] = a3;
    res.d[7] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// undual of translation
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t undual(const translation_t& a) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = 0.0;
    res.d[1] = a0;
    res.d[2] = a1;
    res.d[3] = a2;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// undual of even
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t undual(const even_t& a) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7];
    res.d[0] = a7;
    res.d[1] = a4;
    res.d[2] = a5;
    res.d[3] = a6;
    res.d[4] = a1;
    res.d[5] = a2;
    res.d[6] = a3;
    res.d[7] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// undual of odd
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t undual(const odd_t& a) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7];
    res.d[0] = a4;
    res.d[1] = a5;
    res.d[2] = a6;
    res.d[3] = a7;
    res.d[4] = -a0;
    res.d[5] = -a1;
    res.d[6] = -a2;
    res.d[7] = -a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between scalar and scalar  
// a
// b
// -> r
// 2 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const scalar_t& a, const scalar_t& b) {

    return a * b * b;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between scalar and vector  
// a
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const scalar_t& a, const vector_t& b) {

    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a * b0 * b0 + a * b1 * b1 + a * b2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between scalar and bivector  
// a
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const scalar_t& a, const bivector_t& b) {
    even_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a * (b0 * b0 + b1 * b1 + b2 * b2);
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = 2.0 * (a * (b0 * b3 + b1 * b4 + b2 * b5));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between scalar and trivector  
// a
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 2 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const scalar_t& a, const trivector_t& b) {

    const float b3 = b.d[3];
    return a * b3 * b3;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between scalar and quadvector  
// a
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const scalar_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between scalar and horizon  
// a
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const scalar_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between scalar and origin  
// a
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const scalar_t& a, const origin_t& b) {

    return a;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between scalar and point  
// a
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const scalar_t& a, const point_t& b) {

    return a;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between scalar and direction  
// a
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const scalar_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between scalar and ebivector  
// a
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const scalar_t& a, const ebivector_t& b) {

    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a * b0 * b0 + a * b1 * b1 + a * b2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between scalar and ibivector  
// a
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const scalar_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between scalar and evector  
// a
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const scalar_t& a, const evector_t& b) {

    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a * b0 * b0 + a * b1 * b1 + a * b2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between scalar and dpoint  
// a
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const scalar_t& a, const dpoint_t& b) {

    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a * b0 * b0 + a * b1 * b1 + a * b2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between scalar and rotation  
// a
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r
// 8 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const scalar_t& a, const rotation_t& b) {

    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    return a * b0 * b0 + a * b1 * b1 + a * b2 * b2 + a * b3 * b3;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between scalar and translation  
// a
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const scalar_t& a, const translation_t& b) {

    return a;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between scalar and even  
// a
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 11 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const scalar_t& a, const even_t& b) {
    even_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a * (b0 * b0 + b1 * b1 + b2 * b2 + b3 * b3);
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = 2.0 * (a * (b0 * b7 - b1 * b4 - b2 * b5 - b3 * b6));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between scalar and odd  
// a
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 11 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const scalar_t& a, const odd_t& b) {
    even_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a * (b0 * b0 + b1 * b1 + b2 * b2 + b7 * b7);
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = 2.0 * (a * (b0 * b4 + b1 * b5 + b2 * b6 + b3 * b7));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between vector and scalar  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 8 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t prj(const vector_t& a, const scalar_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3],
        a0b = a0 * b, a1b = a1 * b, a2b = a2 * b, a3b = a3 * b;
    res.d[0] = a0b * b;
    res.d[1] = a1b * b;
    res.d[2] = a2b * b;
    res.d[3] = a3b * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between vector and vector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 7 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t prj(const vector_t& a, const vector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 * t1;
    res.d[1] = b1 * t1;
    res.d[2] = b2 * t1;
    res.d[3] = b3 * t1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between vector and bivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 31 muls / 18 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const vector_t& a, const bivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5],
        a1b2 = a1 * b2, a2b1 = a2 * b1, b0b3 = b0 * b3, b1b4 = b1 * b4, b2b5 = b2 * b5,
        t0 = b0b3 + b1b4, t1 = t0 + b2b5, t2 = a1b2 - a2b1;
    res.d[0] = a0 * (b1 * b1 + b2 * b2) - b0 * (a1 * b1 + a2 * b2);
    res.d[1] = b2 * t2 + b0 * (a1 * b0 - a0 * b1);
    res.d[2] = b0 * (a2 * b0 - a0 * b2) - b1 * t2;
    res.d[3] = a2 * (b1 * b3 - b0 * b4) + a1 * (b0 * b5 - b2 * b3) + a0 * (b2 * b4 - b1 * b5);
    res.d[4] = -a0 * t1;
    res.d[5] = -a1 * t1;
    res.d[6] = -a2 * t1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between vector and trivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 10 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t prj(const vector_t& a, const trivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a0b3 = a0 * b3, a1b3 = a1 * b3, a2b3 = a2 * b3;
    res.d[0] = a0b3 * b3;
    res.d[1] = a1b3 * b3;
    res.d[2] = a2b3 * b3;
    res.d[3] = -b3 * (a0 * b0 + a1 * b1 + a2 * b2);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between vector and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const vector_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between vector and horizon  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const vector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between vector and origin  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t prj(const vector_t& a, const origin_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between vector and point  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t prj(const vector_t& a, const point_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between vector and direction  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const vector_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between vector and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃
// 16 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t prj(const vector_t& a, const ebivector_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a2b1 = a2 * b1,
        t0 = a1b2 - a2b1;
    res.d[0] = a0 * (b1 * b1 + b2 * b2) - b0 * (a1 * b1 + a2 * b2);
    res.d[1] = b2 * t0 + b0 * (a1 * b0 - a0 * b1);
    res.d[2] = b0 * (a2 * b0 - a0 * b2) - b1 * t0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between vector and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const vector_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between vector and evector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t prj(const vector_t& a, const evector_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 * t1;
    res.d[1] = b1 * t1;
    res.d[2] = b2 * t1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between vector and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t prj(const vector_t& a, const dpoint_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 * t1;
    res.d[1] = b1 * t1;
    res.d[2] = b2 * t1;
    res.d[3] = t1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between vector and rotation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 19 muls / 13 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const vector_t& a, const rotation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a1b2 = a1 * b2, a2b3 = a2 * b3, b0b0 = b0 * b0, b2b2 = b2 * b2, b3b3 = b3 * b3,
        b1b1 = b1 * b1, a0b1 = a0 * b1, a3b0 = a3 * b0,
        t0 = a1b2 + a2b3, t1 = b0b0 + b2b2;
    res.d[0] = a0 * (t1 + b3b3) - b1 * t0;
    res.d[1] = a1 * (b0b0 + b1b1 + b3b3) - b2 * (a0b1 + a2b3);
    res.d[2] = a2 * (t1 + b1b1) - b3 * (a0b1 + a1b2);
    res.d[3] = a3b0 * b0;
    res.d[4] = a3b0 * b1;
    res.d[5] = a3b0 * b2;
    res.d[6] = a3b0 * b3;
    res.d[7] = -b0 * (a0b1 + t0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between vector and translation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const vector_t& a, const translation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a3;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between vector and even  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 52 muls / 38 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const vector_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a1b2 = a1 * b2, a2b3 = a2 * b3, b0b0 = b0 * b0, b2b2 = b2 * b2, b3b3 = b3 * b3,
        b1b1 = b1 * b1, a0b1 = a0 * b1, a3b0 = a3 * b0, b1b4 = b1 * b4, b2b5 = b2 * b5,
        b3b6 = b3 * b6,
        s0 = b1b4 + b2b5 + b3b6,
        t0 = a1b2 + a2b3, t1 = b0b0 + b2b2;
    res.d[0] = a0 * (t1 + b3b3) - b1 * t0;
    res.d[1] = a1 * (b0b0 + b1b1 + b3b3) - b2 * (a0b1 + a2b3);
    res.d[2] = a2 * (t1 + b1b1) - b3 * (a0b1 + a1b2);
    res.d[3] = a3b0 * b0 + a2 * (b2 * b4 - b1 * b5 - b3 * b7) + a1 * (b1 * b6 - b2 * b7 - b3 * b4) + a0 * (b3 * b5 - b1 * b7 - b2 * b6);
    res.d[4] = b0 * (a2 * b5 + a3 * b1 - a1 * b6) + a0 * (2 * b0 * b7 - b1b4 - b2b5 - b3b6);
    res.d[5] = b0 * (a0 * b6 + 2 * a1 * b7 + a3 * b2 - a2 * b4) - a1 * s0;
    res.d[6] = b0 * (a1 * b4 + 2 * a2 * b7 + a3 * b3 - a0 * b5) - a2 * s0;
    res.d[7] = -b0 * (a0b1 + t0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between vector and odd  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 40 muls / 28 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const vector_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2, b0b4 = b0 * b4, b1b5 = b1 * b5,
        b2b6 = b2 * b6, b3b7 = b3 * b7,
        s0 = a0b0 + a1b1 + a2b2,
        t0 = b0b4 + b1b5, t1 = t0 + b2b6, t2 = t1 + b3b7;
    res.d[0] = b7 * (a0 * b7 + a2 * b1 - a1 * b2) + b0 * s0;
    res.d[1] = b7 * (a0 * b2 + a1 * b7 - a2 * b0) + b1 * s0;
    res.d[2] = b7 * (a1 * b0 + a2 * b7 - a0 * b1) + b2 * s0;
    res.d[3] = a2 * (b0 * b5 + b2 * b3 - b1 * b4 - b6 * b7) + a1 * (b1 * b3 + b2 * b4 - b0 * b6 - b5 * b7) + a0 * (b0 * b3 + b1 * b6 - b2 * b5 - b4 * b7);
    res.d[4] = -a0 * t2;
    res.d[5] = -a1 * t2;
    res.d[6] = -a2 * t2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between bivector and scalar  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 12 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t prj(const bivector_t& a, const scalar_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5],
        a0b = a0 * b, a1b = a1 * b, a2b = a2 * b, a3b = a3 * b,
        a4b = a4 * b, a5b = a5 * b;
    res.d[0] = a0b * b;
    res.d[1] = a1b * b;
    res.d[2] = a2b * b;
    res.d[3] = a3b * b;
    res.d[4] = a4b * b;
    res.d[5] = a5b * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between bivector and vector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 25 muls / 13 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t prj(const bivector_t& a, const vector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a1b2 = a1 * b2, a2b1 = a2 * b1, a0b1 = a0 * b1, a1b0 = a1 * b0, a0b2 = a0 * b2,
        a2b0 = a2 * b0, a3b0 = a3 * b0, a4b1 = a4 * b1, a5b2 = a5 * b2,
        s0 = a1b2 - a2b1, s1 = a2b0 - a0b2, s2 = a3b0 + a4b1 + a5b2,
        t0 = a0b1 - a1b0;
    res.d[0] = a0 * (b1 * b1 + b2 * b2) - b0 * (a1 * b1 + a2 * b2);
    res.d[1] = b2 * s0 - b0 * t0;
    res.d[2] = b0 * s1 - b1 * s0;
    res.d[3] = b0 * s2 + b3 * s0;
    res.d[4] = b1 * s2 + b3 * s1;
    res.d[5] = b2 * s2 + b3 * t0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between bivector and bivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 9 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t prj(const bivector_t& a, const bivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 * t1;
    res.d[1] = b1 * t1;
    res.d[2] = b2 * t1;
    res.d[3] = b3 * t1;
    res.d[4] = b4 * t1;
    res.d[5] = b5 * t1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between bivector and trivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 15 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t prj(const bivector_t& a, const trivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a0b3 = a0 * b3, a1b3 = a1 * b3, a2b3 = a2 * b3;
    res.d[0] = a0b3 * b3;
    res.d[1] = a1b3 * b3;
    res.d[2] = a2b3 * b3;
    res.d[3] = b3 * (a2 * b1 - a1 * b2);
    res.d[4] = b3 * (a0 * b2 - a2 * b0);
    res.d[5] = b3 * (a1 * b0 - a0 * b1);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between bivector and quadvector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const bivector_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between bivector and horizon  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const bivector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between bivector and origin  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// 1 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t prj(const bivector_t& a, const origin_t& b) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between bivector and point  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t prj(const bivector_t& a, const point_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a2 * b1 - a1 * b2;
    res.d[4] = a0 * b2 - a2 * b0;
    res.d[5] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between bivector and direction  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const bivector_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between bivector and ebivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t prj(const bivector_t& a, const ebivector_t& b) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 * t1;
    res.d[1] = b1 * t1;
    res.d[2] = b2 * t1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between bivector and ibivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const bivector_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between bivector and evector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 22 muls / 10 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t prj(const bivector_t& a, const evector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a2b1 = a2 * b1, a3b0 = a3 * b0, a4b1 = a4 * b1, a5b2 = a5 * b2,
        t0 = a3b0 + a4b1, t1 = t0 + a5b2, t2 = a1b2 - a2b1;
    res.d[0] = a0 * (b1 * b1 + b2 * b2) - b0 * (a1 * b1 + a2 * b2);
    res.d[1] = b2 * t2 + b0 * (a1 * b0 - a0 * b1);
    res.d[2] = b0 * (a2 * b0 - a0 * b2) - b1 * t2;
    res.d[3] = b0 * t1;
    res.d[4] = b1 * t1;
    res.d[5] = b2 * t1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between bivector and dpoint  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 22 muls / 14 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t prj(const bivector_t& a, const dpoint_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a2b1 = a2 * b1, a0b1 = a0 * b1, a1b0 = a1 * b0, a0b2 = a0 * b2,
        a2b0 = a2 * b0, a3b0 = a3 * b0, a4b1 = a4 * b1, a5b2 = a5 * b2,
        s0 = a3b0 + a4b1 + a5b2,
        t0 = a1b2 - a2b1, t1 = a0b1 - a1b0, t2 = a0b2 - a2b0;
    res.d[0] = a0 * (b1 * b1 + b2 * b2) - b0 * (a1 * b1 + a2 * b2);
    res.d[1] = b2 * t0 - b0 * t1;
    res.d[2] = -b1 * t0 - b0 * t2;
    res.d[3] = t0 + b0 * s0;
    res.d[4] = b1 * s0 - t2;
    res.d[5] = t1 + b2 * s0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between bivector and rotation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 34 muls / 20 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const bivector_t& a, const rotation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a0b1 = a0 * b1, a1b2 = a1 * b2, a2b3 = a2 * b3,
        s0 = a0b1 + a1b2 + a2b3;
    res.d[0] = 0.0;
    res.d[1] = b1 * s0 + b0 * (a0 * b0 + a1 * b3 - a2 * b2);
    res.d[2] = b2 * s0 + b0 * (a1 * b0 + a2 * b1 - a0 * b3);
    res.d[3] = b3 * s0 + b0 * (a0 * b2 + a2 * b0 - a1 * b1);
    res.d[4] = b0 * (a3 * b0 + a4 * b3 - a5 * b2);
    res.d[5] = b0 * (a4 * b0 + a5 * b1 - a3 * b3);
    res.d[6] = b0 * (a3 * b2 + a5 * b0 - a4 * b1);
    res.d[7] = -b0 * (a3 * b1 + a4 * b2 + a5 * b3);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between bivector and translation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const bivector_t& a, const translation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = a0;
    res.d[2] = a1;
    res.d[3] = a2;
    res.d[4] = a1 * b2 + a3 - a2 * b1;
    res.d[5] = a2 * b0 + a4 - a0 * b2;
    res.d[6] = a0 * b1 + a5 - a1 * b0;
    res.d[7] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between bivector and even  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 55 muls / 38 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const bivector_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a0b1 = a0 * b1, a1b2 = a1 * b2, a2b3 = a2 * b3, a1b3 = a1 * b3, a2b2 = a2 * b2,
        a0b3 = a0 * b3, a2b1 = a2 * b1, a0b2 = a0 * b2, a1b1 = a1 * b1,
        s0 = a0b1 + a1b2 + a2b3,
        t0 = a1b3 - a2b2, t1 = a0b3 - a2b1, t2 = a0b2 - a1b1;
    res.d[0] = 0.0;
    res.d[1] = b1 * s0 + b0 * (a0 * b0 + t0);
    res.d[2] = b2 * s0 + b0 * (a1 * b0 - t1);
    res.d[3] = b3 * s0 + b0 * (t2 + a2 * b0);
    res.d[4] = b4 * s0 + b0 * (a1 * b6 + a3 * b0 + a4 * b3 - 2 * a0 * b7 - a2 * b5 - a5 * b2) - b7 * t0;
    res.d[5] = b7 * t1 + b5 * s0 + b0 * (a2 * b4 + a4 * b0 + a5 * b1 - a0 * b6 - 2 * a1 * b7 - a3 * b3);
    res.d[6] = b6 * s0 + b0 * (a0 * b5 + a3 * b2 + a5 * b0 - a1 * b4 - 2 * a2 * b7 - a4 * b1) - b7 * t2;
    res.d[7] = -b0 * (a0 * b4 + a1 * b5 + a2 * b6 + a3 * b1 + a4 * b2 + a5 * b3);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between bivector and odd  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 51 muls / 38 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const bivector_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2, b1b1 = b1 * b1, b2b2 = b2 * b2,
        b7b7 = b7 * b7, b0b0 = b0 * b0, a3b0 = a3 * b0, a4b1 = a4 * b1, a5b2 = a5 * b2,
        b1b3 = b1 * b3, b5b7 = b5 * b7, b2b3 = b2 * b3, b6b7 = b6 * b7, b0b4 = b0 * b4,
        b1b5 = b1 * b5, b2b6 = b2 * b6, b3b7 = b3 * b7, b0b3 = b0 * b3, b4b7 = b4 * b7,
        s0 = a3b0 + a4b1 + a5b2, s1 = b0b4 + b1b5 + b2b6 + b3b7,
        t0 = a0b0 + a1b1, t1 = b1b1 + b7b7, t2 = b1b3 - b5b7, t3 = b2b3 - b6b7, t4 = b0b3 - b4b7;
    res.d[0] = -b7 * (t0 + a2b2);
    res.d[1] = a0 * (t1 + b2b2) - b0 * (a1b1 + a2b2);
    res.d[2] = a1 * (b0b0 + b2b2 + b7b7) - b1 * (a0b0 + a2b2);
    res.d[3] = a2 * (b0b0 + t1) - b2 * t0;
    res.d[4] = b0 * s0 + a1 * t3 + a0 * s1 - a2 * t2;
    res.d[5] = b1 * s0 + a2 * t4 + a1 * s1 - a0 * t3;
    res.d[6] = b2 * s0 + a2 * s1 + a0 * t2 - a1 * t4;
    res.d[7] = b0 * (a2 * b5 - a1 * b6 - a3 * b7) + b2 * (a1 * b4 - a0 * b5 - a5 * b7) + b1 * (a0 * b6 - a2 * b4 - a4 * b7);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between trivector and scalar  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 8 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t prj(const trivector_t& a, const scalar_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3],
        a0b = a0 * b, a1b = a1 * b, a2b = a2 * b, a3b = a3 * b;
    res.d[0] = a0b * b;
    res.d[1] = a1b * b;
    res.d[2] = a2b * b;
    res.d[3] = a3b * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between trivector and vector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 14 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t prj(const trivector_t& a, const vector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a1b1 = a1 * b1, a2b2 = a2 * b2, a3b3 = a3 * b3, b1b1 = b1 * b1, b2b2 = b2 * b2,
        b0b0 = b0 * b0, a0b0 = a0 * b0,
        t0 = a1b1 + a3b3, t1 = b1b1 + b2b2;
    res.d[0] = a0 * t1 - b0 * (t0 + a2b2);
    res.d[1] = a1 * (b0b0 + b2b2) - b1 * (a0b0 + a2b2 + a3b3);
    res.d[2] = a2 * (b0b0 + b1b1) - b2 * (a0b0 + t0);
    res.d[3] = a3 * (b0b0 + t1);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between trivector and bivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 23 muls / 13 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const trivector_t& a, const bivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        s0 = a0b0 + a1b1 + a2b2;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a3 * (b0 * b3 + b1 * b4 + b2 * b5);
    res.d[4] = a3 * (b1 * b5 - b2 * b4) + b0 * s0;
    res.d[5] = a3 * (b2 * b3 - b0 * b5) + b1 * s0;
    res.d[6] = a3 * (b0 * b4 - b1 * b3) + b2 * s0;
    res.d[7] = a3 * (b0 * b0 + b1 * b1 + b2 * b2);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between trivector and trivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 5 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t prj(const trivector_t& a, const trivector_t& b) {
    trivector_t res;
    const float a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a3b3 = a3 * b3;
    res.d[0] = a3b3 * b0;
    res.d[1] = a3b3 * b1;
    res.d[2] = a3b3 * b2;
    res.d[3] = a3b3 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between trivector and quadvector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const trivector_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between trivector and horizon  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const trivector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between trivector and origin  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t prj(const trivector_t& a, const origin_t& b) {
    trivector_t res;
    const float a3 = a.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between trivector and point  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t prj(const trivector_t& a, const point_t& b) {
    trivector_t res;
    const float a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b0;
    res.d[1] = a3 * b1;
    res.d[2] = a3 * b2;
    res.d[3] = a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between trivector and direction  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const trivector_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between trivector and ebivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 10 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t prj(const trivector_t& a, const ebivector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 * t1;
    res.d[1] = b1 * t1;
    res.d[2] = b2 * t1;
    res.d[3] = a3 * (b0 * b0 + b1 * b1 + b2 * b2);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between trivector and ibivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const trivector_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between trivector and evector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 18 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t prj(const trivector_t& a, const evector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        b1b1 = b1 * b1, b2b2 = b2 * b2, a1b2 = a1 * b2, a2b1 = a2 * b1,
        t0 = b1b1 + b2b2, t1 = a1b2 - a2b1;
    res.d[0] = a0 * t0 - b0 * (a1 * b1 + a2 * b2);
    res.d[1] = b2 * t1 + b0 * (a1 * b0 - a0 * b1);
    res.d[2] = b0 * (a2 * b0 - a0 * b2) - b1 * t1;
    res.d[3] = a3 * (b0 * b0 + t0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between trivector and dpoint  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 13 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t prj(const trivector_t& a, const dpoint_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b1 = a1 * b1, a2b2 = a2 * b2, b1b1 = b1 * b1, b2b2 = b2 * b2, b0b0 = b0 * b0,
        a0b0 = a0 * b0,
        t0 = a1b1 + a3, t1 = b1b1 + b2b2;
    res.d[0] = a0 * t1 - b0 * (t0 + a2b2);
    res.d[1] = a1 * (b0b0 + b2b2) - b1 * (a0b0 + a2b2 + a3);
    res.d[2] = a2 * (b0b0 + b1b1) - b2 * (a0b0 + t0);
    res.d[3] = a3 * (b0b0 + t1);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between trivector and rotation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 23 muls / 14 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t prj(const trivector_t& a, const rotation_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a0b1 = a0 * b1, a1b2 = a1 * b2, a2b3 = a2 * b3,
        s0 = a0b1 + a1b2 + a2b3;
    res.d[0] = b1 * s0 + b0 * (a0 * b0 + a1 * b3 - a2 * b2);
    res.d[1] = b2 * s0 + b0 * (a1 * b0 + a2 * b1 - a0 * b3);
    res.d[2] = b3 * s0 + b0 * (a0 * b2 + a2 * b0 - a1 * b1);
    res.d[3] = a3 * (b0 * b0 + b1 * b1 + b2 * b2 + b3 * b3);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between trivector and translation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t prj(const trivector_t& a, const translation_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 - a3 * b0;
    res.d[1] = a1 - a3 * b1;
    res.d[2] = a2 - a3 * b2;
    res.d[3] = a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between trivector and even  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 41 muls / 26 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const trivector_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a0b1 = a0 * b1, a1b2 = a1 * b2, a2b3 = a2 * b3,
        s0 = a0b1 + a1b2 + a2b3;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a3 * (2 * b0 * b7 - b1 * b4 - b2 * b5 - b3 * b6);
    res.d[4] = a3 * (b2 * b6 - b3 * b5) + b1 * s0 + b0 * (a0 * b0 + a1 * b3 - a2 * b2 - a3 * b4);
    res.d[5] = a3 * (b3 * b4 - b1 * b6) + b2 * s0 + b0 * (a1 * b0 + a2 * b1 - a0 * b3 - a3 * b5);
    res.d[6] = a3 * (b1 * b5 - b2 * b4) + b3 * s0 + b0 * (a0 * b2 + a2 * b0 - a1 * b1 - a3 * b6);
    res.d[7] = a3 * (b0 * b0 + b1 * b1 + b2 * b2 + b3 * b3);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between trivector and odd  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 37 muls / 28 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const trivector_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a0b2 = a0 * b2, a1b7 = a1 * b7, a2b0 = a2 * b0, a3b5 = a3 * b5, a0b1 = a0 * b1,
        a1b0 = a1 * b0, a2b7 = a2 * b7, a3b6 = a3 * b6, a0b7 = a0 * b7, a1b2 = a1 * b2,
        a2b1 = a2 * b1, a3b4 = a3 * b4,
        t0 = a0b2 + a1b7, t1 = t0 - a2b0, t2 = t1 - a3b5, t3 = a0b1 - a1b0, t4 = t3 - a2b7, t5 = t4 + a3b6;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a3 * (b0 * b4 + b1 * b5 + b2 * b6 + b3 * b7);
    res.d[4] = a3 * (b4 * b7 - b0 * b3) + b2 * t2 + b1 * t5;
    res.d[5] = a3 * (b5 * b7 - b1 * b3) + b2 * (a1b2 + a3b4 - a0b7 - a2b1) - b0 * t5;
    res.d[6] = a3 * (b6 * b7 - b2 * b3) + b1 * (a0b7 + a2b1 - a1b2 - a3b4) - b0 * t2;
    res.d[7] = a3 * (b0 * b0 + b1 * b1 + b2 * b2 + b7 * b7);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between quadvector and scalar  
// a0 e₀₁₂₃
// b
// -> r0 e₀₁₂₃
// 2 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t prj(const quadvector_t& a, const scalar_t& b) {
    quadvector_t res;
    const float a0 = a.d[0],
        a0b = a0 * b;
    res.d[0] = a0b * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between quadvector and vector  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₀₁₂₃
// 4 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t prj(const quadvector_t& a, const vector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * (b0 * b0 + b1 * b1 + b2 * b2);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between quadvector and bivector  
// a0 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₀₁₂₃
// 4 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t prj(const quadvector_t& a, const bivector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * (b0 * b0 + b1 * b1 + b2 * b2);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between quadvector and trivector  
// a0 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₁₂₃
// 2 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t prj(const quadvector_t& a, const trivector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], b3 = b.d[3],
        a0b3 = a0 * b3;
    res.d[0] = a0b3 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between quadvector and quadvector  
// a0 e₀₁₂₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const quadvector_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between quadvector and horizon  
// a0 e₀₁₂₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const quadvector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between quadvector and origin  
// a0 e₀₁₂₃
// 1 e₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t prj(const quadvector_t& a, const origin_t& b) {
    quadvector_t res;
    const float a0 = a.d[0];
    res.d[0] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between quadvector and point  
// a0 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t prj(const quadvector_t& a, const point_t& b) {
    quadvector_t res;
    const float a0 = a.d[0];
    res.d[0] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between quadvector and direction  
// a0 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const quadvector_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between quadvector and ebivector  
// a0 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₀₁₂₃
// 4 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t prj(const quadvector_t& a, const ebivector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * (b0 * b0 + b1 * b1 + b2 * b2);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between quadvector and ibivector  
// a0 e₀₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const quadvector_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between quadvector and evector  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₀₁₂₃
// 4 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t prj(const quadvector_t& a, const evector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * (b0 * b0 + b1 * b1 + b2 * b2);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between quadvector and dpoint  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₀₁₂₃
// 4 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t prj(const quadvector_t& a, const dpoint_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * (b0 * b0 + b1 * b1 + b2 * b2);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between quadvector and rotation  
// a0 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₀₁₂₃
// 5 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t prj(const quadvector_t& a, const rotation_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * (b0 * b0 + b1 * b1 + b2 * b2 + b3 * b3);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between quadvector and translation  
// a0 e₀₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t prj(const quadvector_t& a, const translation_t& b) {
    quadvector_t res;
    const float a0 = a.d[0];
    res.d[0] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between quadvector and even  
// a0 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₀₁₂₃
// 5 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t prj(const quadvector_t& a, const even_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * (b0 * b0 + b1 * b1 + b2 * b2 + b3 * b3);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between quadvector and odd  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₀₁₂₃
// 5 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t prj(const quadvector_t& a, const odd_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b7 = b.d[7];
    res.d[0] = a0 * (b0 * b0 + b1 * b1 + b2 * b2 + b7 * b7);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between horizon and scalar  
// 1 e₀
// b
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 1 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t prj(const horizon_t& a, const scalar_t& b) {
    vector_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between horizon and vector  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const horizon_t& a, const vector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between horizon and bivector  
// 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const horizon_t& a, const bivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between horizon and trivector  
// 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const horizon_t& a, const trivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between horizon and quadvector  
// 1 e₀
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const horizon_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between horizon and horizon  
// 1 e₀
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const horizon_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between horizon and origin  
// 1 e₀
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const horizon_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between horizon and point  
// 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const horizon_t& a, const point_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between horizon and direction  
// 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const horizon_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between horizon and ebivector  
// 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const horizon_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between horizon and ibivector  
// 1 e₀
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const horizon_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between horizon and evector  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const horizon_t& a, const evector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between horizon and dpoint  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const horizon_t& a, const dpoint_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between horizon and rotation  
// 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const horizon_t& a, const rotation_t& b) {
    odd_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b0 * b0;
    res.d[4] = b0 * b1;
    res.d[5] = b0 * b2;
    res.d[6] = b0 * b3;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between horizon and translation  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline horizon_t prj(const horizon_t& a, const translation_t& b) {

    return horizon_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// prj between horizon and even  
// 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const horizon_t& a, const even_t& b) {
    odd_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b0 * b0;
    res.d[4] = b0 * b1;
    res.d[5] = b0 * b2;
    res.d[6] = b0 * b3;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between horizon and odd  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const horizon_t& a, const odd_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between origin and scalar  
// 1 e₁₂₃
// b
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 1 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t prj(const origin_t& a, const scalar_t& b) {
    trivector_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between origin and vector  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 6 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t prj(const origin_t& a, const vector_t& b) {
    trivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -b0 * b3;
    res.d[1] = -b1 * b3;
    res.d[2] = -b2 * b3;
    res.d[3] = b0 * b0 + b1 * b1 + b2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between origin and bivector  
// 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const origin_t& a, const bivector_t& b) {
    odd_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -b0 * b3 - b1 * b4 - b2 * b5;
    res.d[4] = b1 * b5 - b2 * b4;
    res.d[5] = b2 * b3 - b0 * b5;
    res.d[6] = b0 * b4 - b1 * b3;
    res.d[7] = b0 * b0 + b1 * b1 + b2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between origin and trivector  
// 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t prj(const origin_t& a, const trivector_t& b) {
    trivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0 * b3;
    res.d[1] = b1 * b3;
    res.d[2] = b2 * b3;
    res.d[3] = b3 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between origin and quadvector  
// 1 e₁₂₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const origin_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between origin and horizon  
// 1 e₁₂₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const origin_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between origin and origin  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline origin_t prj(const origin_t& a, const origin_t& b) {

    return origin_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// prj between origin and point  
// 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t prj(const origin_t& a, const point_t& b) {
    point_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between origin and direction  
// 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const origin_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between origin and ebivector  
// 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t prj(const origin_t& a, const ebivector_t& b) {
    trivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b0 * b0 + b1 * b1 + b2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between origin and ibivector  
// 1 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const origin_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between origin and evector  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t prj(const origin_t& a, const evector_t& b) {
    trivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b0 * b0 + b1 * b1 + b2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between origin and dpoint  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 3 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t prj(const origin_t& a, const dpoint_t& b) {
    trivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    res.d[3] = b0 * b0 + b1 * b1 + b2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between origin and rotation  
// 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 4 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t prj(const origin_t& a, const rotation_t& b) {
    trivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b0 * b0 + b1 * b1 + b2 * b2 + b3 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between origin and translation  
// 1 e₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t prj(const origin_t& a, const translation_t& b) {
    point_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between origin and even  
// 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 18 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const origin_t& a, const even_t& b) {
    odd_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 2 * b0 * b7 - b1 * b4 - b2 * b5 - b3 * b6;
    res.d[4] = b2 * b6 - b0 * b4 - b3 * b5;
    res.d[5] = b3 * b4 - b0 * b5 - b1 * b6;
    res.d[6] = b1 * b5 - b0 * b6 - b2 * b4;
    res.d[7] = b0 * b0 + b1 * b1 + b2 * b2 + b3 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between origin and odd  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 20 muls / 16 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const origin_t& a, const odd_t& b) {
    odd_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -b0 * b4 - b1 * b5 - b2 * b6 - b3 * b7;
    res.d[4] = b1 * b6 + b4 * b7 - b0 * b3 - b2 * b5;
    res.d[5] = b2 * b4 + b5 * b7 - b0 * b6 - b1 * b3;
    res.d[6] = b0 * b5 + b6 * b7 - b1 * b4 - b2 * b3;
    res.d[7] = b0 * b0 + b1 * b1 + b2 * b2 + b7 * b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between point and scalar  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 7 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t prj(const point_t& a, const scalar_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2],
        a0b = a0 * b, bb = b * b, a1b = a1 * b, a2b = a2 * b;
    res.d[0] = a0b * b;
    res.d[1] = a1b * b;
    res.d[2] = a2b * b;
    res.d[3] = bb;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between point and vector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 12 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t prj(const point_t& a, const vector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a1b1 = a1 * b1, a2b2 = a2 * b2, b1b1 = b1 * b1, b2b2 = b2 * b2, b0b0 = b0 * b0,
        a0b0 = a0 * b0,
        t0 = a1b1 + b3, t1 = b1b1 + b2b2;
    res.d[0] = a0 * t1 - b0 * (t0 + a2b2);
    res.d[1] = a1 * (b0b0 + b2b2) - b1 * (a0b0 + a2b2 + b3);
    res.d[2] = a2 * (b0b0 + b1b1) - b2 * (a0b0 + t0);
    res.d[3] = b0b0 + t1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between point and bivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 18 muls / 13 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const point_t& a, const bivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        s0 = a0b0 + a1b1 + a2b2;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -b0 * b3 - b1 * b4 - b2 * b5;
    res.d[4] = b1 * b5 + b0 * s0 - b2 * b4;
    res.d[5] = b2 * b3 + b1 * s0 - b0 * b5;
    res.d[6] = b0 * b4 + b2 * s0 - b1 * b3;
    res.d[7] = b0 * b0 + b1 * b1 + b2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between point and trivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t prj(const point_t& a, const trivector_t& b) {
    trivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0 * b3;
    res.d[1] = b1 * b3;
    res.d[2] = b2 * b3;
    res.d[3] = b3 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between point and quadvector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const point_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between point and horizon  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const point_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between point and origin  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline origin_t prj(const point_t& a, const origin_t& b) {

    return origin_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// prj between point and point  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t prj(const point_t& a, const point_t& b) {
    point_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between point and direction  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const point_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between point and ebivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 9 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t prj(const point_t& a, const ebivector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 * t1;
    res.d[1] = b1 * t1;
    res.d[2] = b2 * t1;
    res.d[3] = b0 * b0 + b1 * b1 + b2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between point and ibivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const point_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between point and evector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 17 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t prj(const point_t& a, const evector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        b1b1 = b1 * b1, b2b2 = b2 * b2, a1b2 = a1 * b2, a2b1 = a2 * b1,
        t0 = b1b1 + b2b2, t1 = a1b2 - a2b1;
    res.d[0] = a0 * t0 - b0 * (a1 * b1 + a2 * b2);
    res.d[1] = b2 * t1 + b0 * (a1 * b0 - a0 * b1);
    res.d[2] = b0 * (a2 * b0 - a0 * b2) - b1 * t1;
    res.d[3] = b0 * b0 + t0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between point and dpoint  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 12 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t prj(const point_t& a, const dpoint_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b1 = a1 * b1, a2b2 = a2 * b2, b1b1 = b1 * b1, b2b2 = b2 * b2, b0b0 = b0 * b0,
        a0b0 = a0 * b0,
        t0 = a1b1 + 1, t1 = b1b1 + b2b2;
    res.d[0] = a0 * t1 - b0 * (t0 + a2b2);
    res.d[1] = a1 * (b0b0 + b2b2) - b1 * (a0b0 + a2b2 + 1);
    res.d[2] = a2 * (b0b0 + b1b1) - b2 * (a0b0 + t0);
    res.d[3] = b0b0 + t1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between point and rotation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 22 muls / 14 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t prj(const point_t& a, const rotation_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a0b1 = a0 * b1, a1b2 = a1 * b2, a2b3 = a2 * b3,
        s0 = a0b1 + a1b2 + a2b3;
    res.d[0] = b1 * s0 + b0 * (a0 * b0 + a1 * b3 - a2 * b2);
    res.d[1] = b2 * s0 + b0 * (a1 * b0 + a2 * b1 - a0 * b3);
    res.d[2] = b3 * s0 + b0 * (a0 * b2 + a2 * b0 - a1 * b1);
    res.d[3] = b0 * b0 + b1 * b1 + b2 * b2 + b3 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between point and translation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t prj(const point_t& a, const translation_t& b) {
    point_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 - b0;
    res.d[1] = a1 - b1;
    res.d[2] = a2 - b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between point and even  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 33 muls / 26 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const point_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a0b1 = a0 * b1, a1b2 = a1 * b2, a2b3 = a2 * b3,
        s0 = a0b1 + a1b2 + a2b3;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 2 * b0 * b7 - b1 * b4 - b2 * b5 - b3 * b6;
    res.d[4] = b2 * b6 + b1 * s0 + b0 * (a0 * b0 + a1 * b3 - a2 * b2 - b4) - b3 * b5;
    res.d[5] = b3 * b4 + b2 * s0 + b0 * (a1 * b0 + a2 * b1 - a0 * b3 - b5) - b1 * b6;
    res.d[6] = b1 * b5 + b3 * s0 + b0 * (a0 * b2 + a2 * b0 - a1 * b1 - b6) - b2 * b4;
    res.d[7] = b0 * b0 + b1 * b1 + b2 * b2 + b3 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between point and odd  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 29 muls / 28 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const point_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a0b2 = a0 * b2, a1b7 = a1 * b7, a2b0 = a2 * b0, a0b1 = a0 * b1, a1b0 = a1 * b0,
        a2b7 = a2 * b7, a0b7 = a0 * b7, a1b2 = a1 * b2, a2b1 = a2 * b1,
        t0 = a0b2 + a1b7, t1 = t0 - a2b0, t2 = t1 - b5, t3 = a0b1 - a1b0, t4 = t3 - a2b7, t5 = t4 + b6;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -b0 * b4 - b1 * b5 - b2 * b6 - b3 * b7;
    res.d[4] = b4 * b7 + b2 * t2 + b1 * t5 - b0 * b3;
    res.d[5] = b5 * b7 + b2 * (a1b2 + b4 - a0b7 - a2b1) - b1 * b3 - b0 * t5;
    res.d[6] = b6 * b7 + b1 * (a0b7 + a2b1 - a1b2 - b4) - b2 * b3 - b0 * t2;
    res.d[7] = b0 * b0 + b1 * b1 + b2 * b2 + b7 * b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between direction and scalar  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 6 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t prj(const direction_t& a, const scalar_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2],
        a0b = a0 * b, a1b = a1 * b, a2b = a2 * b;
    res.d[0] = a0b * b;
    res.d[1] = a1b * b;
    res.d[2] = a2b * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between direction and vector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 16 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t prj(const direction_t& a, const vector_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a2b1 = a2 * b1,
        t0 = a1b2 - a2b1;
    res.d[0] = a0 * (b1 * b1 + b2 * b2) - b0 * (a1 * b1 + a2 * b2);
    res.d[1] = b2 * t0 + b0 * (a1 * b0 - a0 * b1);
    res.d[2] = b0 * (a2 * b0 - a0 * b2) - b1 * t0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between direction and bivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t prj(const direction_t& a, const bivector_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 * t1;
    res.d[1] = b1 * t1;
    res.d[2] = b2 * t1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between direction and trivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const direction_t& a, const trivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between direction and quadvector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const direction_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between direction and horizon  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const direction_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between direction and origin  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const direction_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between direction and point  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const direction_t& a, const point_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between direction and direction  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const direction_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between direction and ebivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t prj(const direction_t& a, const ebivector_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 * t1;
    res.d[1] = b1 * t1;
    res.d[2] = b2 * t1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between direction and ibivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const direction_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between direction and evector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 16 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t prj(const direction_t& a, const evector_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a2b1 = a2 * b1,
        t0 = a1b2 - a2b1;
    res.d[0] = a0 * (b1 * b1 + b2 * b2) - b0 * (a1 * b1 + a2 * b2);
    res.d[1] = b2 * t0 + b0 * (a1 * b0 - a0 * b1);
    res.d[2] = b0 * (a2 * b0 - a0 * b2) - b1 * t0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between direction and dpoint  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 16 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t prj(const direction_t& a, const dpoint_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a2b1 = a2 * b1,
        t0 = a1b2 - a2b1;
    res.d[0] = a0 * (b1 * b1 + b2 * b2) - b0 * (a1 * b1 + a2 * b2);
    res.d[1] = b2 * t0 + b0 * (a1 * b0 - a0 * b1);
    res.d[2] = b0 * (a2 * b0 - a0 * b2) - b1 * t0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between direction and rotation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 18 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t prj(const direction_t& a, const rotation_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a0b1 = a0 * b1, a1b2 = a1 * b2, a2b3 = a2 * b3,
        s0 = a0b1 + a1b2 + a2b3;
    res.d[0] = b1 * s0 + b0 * (a0 * b0 + a1 * b3 - a2 * b2);
    res.d[1] = b2 * s0 + b0 * (a1 * b0 + a2 * b1 - a0 * b3);
    res.d[2] = b3 * s0 + b0 * (a0 * b2 + a2 * b0 - a1 * b1);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between direction and translation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t prj(const direction_t& a, const translation_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between direction and even  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 18 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t prj(const direction_t& a, const even_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a0b1 = a0 * b1, a1b2 = a1 * b2, a2b3 = a2 * b3,
        s0 = a0b1 + a1b2 + a2b3;
    res.d[0] = b1 * s0 + b0 * (a0 * b0 + a1 * b3 - a2 * b2);
    res.d[1] = b2 * s0 + b0 * (a1 * b0 + a2 * b1 - a0 * b3);
    res.d[2] = b3 * s0 + b0 * (a0 * b2 + a2 * b0 - a1 * b1);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between direction and odd  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 15 muls / 10 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t prj(const direction_t& a, const odd_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b7 = b.d[7],
        a0b2 = a0 * b2, a1b7 = a1 * b7, a2b0 = a2 * b0, a0b1 = a0 * b1, a1b0 = a1 * b0,
        a2b7 = a2 * b7, a0b7 = a0 * b7, a1b2 = a1 * b2, a2b1 = a2 * b1,
        t0 = a0b2 + a1b7, t1 = t0 - a2b0, t2 = a0b1 - a1b0, t3 = t2 - a2b7, t4 = a0b7 - a1b2, t5 = t4 + a2b1;
    res.d[0] = b2 * t1 + b1 * t3;
    res.d[1] = -b2 * t5 - b0 * t3;
    res.d[2] = b1 * t5 - b0 * t1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between ebivector and scalar  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 6 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t prj(const ebivector_t& a, const scalar_t& b) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2],
        a0b = a0 * b, a1b = a1 * b, a2b = a2 * b;
    res.d[0] = a0b * b;
    res.d[1] = a1b * b;
    res.d[2] = a2b * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between ebivector and vector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 19 muls / 10 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t prj(const ebivector_t& a, const vector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a1b2 = a1 * b2, a2b1 = a2 * b1, a0b1 = a0 * b1, a1b0 = a1 * b0, a0b2 = a0 * b2,
        a2b0 = a2 * b0,
        t0 = a1b2 - a2b1, t1 = a0b1 - a1b0, t2 = a0b2 - a2b0;
    res.d[0] = a0 * (b1 * b1 + b2 * b2) - b0 * (a1 * b1 + a2 * b2);
    res.d[1] = b2 * t0 - b0 * t1;
    res.d[2] = -b1 * t0 - b0 * t2;
    res.d[3] = b3 * t0;
    res.d[4] = -b3 * t2;
    res.d[5] = b3 * t1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between ebivector and bivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 9 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t prj(const ebivector_t& a, const bivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 * t1;
    res.d[1] = b1 * t1;
    res.d[2] = b2 * t1;
    res.d[3] = b3 * t1;
    res.d[4] = b4 * t1;
    res.d[5] = b5 * t1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between ebivector and trivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 15 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t prj(const ebivector_t& a, const trivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a0b3 = a0 * b3, a1b3 = a1 * b3, a2b3 = a2 * b3;
    res.d[0] = a0b3 * b3;
    res.d[1] = a1b3 * b3;
    res.d[2] = a2b3 * b3;
    res.d[3] = b3 * (a2 * b1 - a1 * b2);
    res.d[4] = b3 * (a0 * b2 - a2 * b0);
    res.d[5] = b3 * (a1 * b0 - a0 * b1);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between ebivector and quadvector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const ebivector_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between ebivector and horizon  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const ebivector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between ebivector and origin  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// 1 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t prj(const ebivector_t& a, const origin_t& b) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between ebivector and point  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t prj(const ebivector_t& a, const point_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a2 * b1 - a1 * b2;
    res.d[4] = a0 * b2 - a2 * b0;
    res.d[5] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between ebivector and direction  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const ebivector_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between ebivector and ebivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t prj(const ebivector_t& a, const ebivector_t& b) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 * t1;
    res.d[1] = b1 * t1;
    res.d[2] = b2 * t1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between ebivector and ibivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const ebivector_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between ebivector and evector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 16 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t prj(const ebivector_t& a, const evector_t& b) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a2b1 = a2 * b1,
        t0 = a1b2 - a2b1;
    res.d[0] = a0 * (b1 * b1 + b2 * b2) - b0 * (a1 * b1 + a2 * b2);
    res.d[1] = b2 * t0 + b0 * (a1 * b0 - a0 * b1);
    res.d[2] = b0 * (a2 * b0 - a0 * b2) - b1 * t0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between ebivector and dpoint  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 16 muls / 10 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t prj(const ebivector_t& a, const dpoint_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a2b1 = a2 * b1, a0b1 = a0 * b1, a1b0 = a1 * b0, a0b2 = a0 * b2,
        a2b0 = a2 * b0,
        s0 = a1b2 - a2b1, s1 = a2b0 - a0b2,
        t0 = a0b1 - a1b0;
    res.d[0] = a0 * (b1 * b1 + b2 * b2) - b0 * (a1 * b1 + a2 * b2);
    res.d[1] = b2 * s0 - b0 * t0;
    res.d[2] = b0 * s1 - b1 * s0;
    res.d[3] = a1b2 - a2b1;
    res.d[4] = a2b0 - a0b2;
    res.d[5] = t0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between ebivector and rotation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 18 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t prj(const ebivector_t& a, const rotation_t& b) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a0b1 = a0 * b1, a1b2 = a1 * b2, a2b3 = a2 * b3,
        s0 = a0b1 + a1b2 + a2b3;
    res.d[0] = b1 * s0 + b0 * (a0 * b0 + a1 * b3 - a2 * b2);
    res.d[1] = b2 * s0 + b0 * (a1 * b0 + a2 * b1 - a0 * b3);
    res.d[2] = b3 * s0 + b0 * (a0 * b2 + a2 * b0 - a1 * b1);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between ebivector and translation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const ebivector_t& a, const translation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = a0;
    res.d[2] = a1;
    res.d[3] = a2;
    res.d[4] = a1 * b2 - a2 * b1;
    res.d[5] = a2 * b0 - a0 * b2;
    res.d[6] = a0 * b1 - a1 * b0;
    res.d[7] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between ebivector and even  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 50 muls / 32 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const ebivector_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a0b1 = a0 * b1, a1b2 = a1 * b2, a2b3 = a2 * b3, b0b5 = b0 * b5, b2b7 = b2 * b7,
        b0b6 = b0 * b6, b3b7 = b3 * b7, b0b7 = b0 * b7, b0b4 = b0 * b4, b1b7 = b1 * b7,
        s0 = a0b1 + a1b2 + a2b3,
        t0 = b0b5 - b2b7, t1 = b0b6 - b3b7, t2 = b0b4 - b1b7;
    res.d[0] = 0.0;
    res.d[1] = b1 * s0 + b0 * (a0 * b0 + a1 * b3 - a2 * b2);
    res.d[2] = b2 * s0 + b0 * (a1 * b0 + a2 * b1 - a0 * b3);
    res.d[3] = b3 * s0 + b0 * (a0 * b2 + a2 * b0 - a1 * b1);
    res.d[4] = a2 * (b3 * b4 - t0) + a1 * (t1 + b2 * b4) + a0 * (b1 * b4 - 2 * b0b7);
    res.d[5] = a2 * (t2 + b3 * b5) + a1 * (b2 * b5 - 2 * b0b7) + a0 * (b1 * b5 - t1);
    res.d[6] = a2 * (b3 * b6 - 2 * b0b7) + a1 * (b2 * b6 - t2) + a0 * (t0 + b1 * b6);
    res.d[7] = -b0 * (a0 * b4 + a1 * b5 + a2 * b6);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between ebivector and odd  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 42 muls / 30 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const ebivector_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2, b1b1 = b1 * b1, b2b2 = b2 * b2,
        b7b7 = b7 * b7, b0b0 = b0 * b0, b1b3 = b1 * b3, b5b7 = b5 * b7, b2b3 = b2 * b3,
        b6b7 = b6 * b7, b0b4 = b0 * b4, b1b5 = b1 * b5, b2b6 = b2 * b6, b3b7 = b3 * b7,
        b0b3 = b0 * b3, b4b7 = b4 * b7,
        s0 = b0b4 + b1b5 + b2b6 + b3b7,
        t0 = a0b0 + a1b1, t1 = b1b1 + b7b7, t2 = b1b3 - b5b7, t3 = b2b3 - b6b7, t4 = b0b3 - b4b7;
    res.d[0] = -b7 * (t0 + a2b2);
    res.d[1] = a0 * (t1 + b2b2) - b0 * (a1b1 + a2b2);
    res.d[2] = a1 * (b0b0 + b2b2 + b7b7) - b1 * (a0b0 + a2b2);
    res.d[3] = a2 * (b0b0 + t1) - b2 * t0;
    res.d[4] = a1 * t3 + a0 * s0 - a2 * t2;
    res.d[5] = a2 * t4 + a1 * s0 - a0 * t3;
    res.d[6] = a2 * s0 + a0 * t2 - a1 * t4;
    res.d[7] = a2 * (b0 * b5 - b1 * b4) + a1 * (b2 * b4 - b0 * b6) + a0 * (b1 * b6 - b2 * b5);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between ibivector and scalar  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t prj(const ibivector_t& a, const scalar_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2],
        a0b = a0 * b, a1b = a1 * b, a2b = a2 * b;
    res.d[0] = a0b * b;
    res.d[1] = a1b * b;
    res.d[2] = a2b * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between ibivector and vector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t prj(const ibivector_t& a, const vector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 * t1;
    res.d[1] = b1 * t1;
    res.d[2] = b2 * t1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between ibivector and bivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const ibivector_t& a, const bivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between ibivector and trivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const ibivector_t& a, const trivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between ibivector and quadvector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const ibivector_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between ibivector and horizon  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const ibivector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between ibivector and origin  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const ibivector_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between ibivector and point  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const ibivector_t& a, const point_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between ibivector and direction  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const ibivector_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between ibivector and ebivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const ibivector_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between ibivector and ibivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const ibivector_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between ibivector and evector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t prj(const ibivector_t& a, const evector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 * t1;
    res.d[1] = b1 * t1;
    res.d[2] = b2 * t1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between ibivector and dpoint  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t prj(const ibivector_t& a, const dpoint_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 * t1;
    res.d[1] = b1 * t1;
    res.d[2] = b2 * t1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between ibivector and rotation  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 16 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const ibivector_t& a, const rotation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = b0 * (a0 * b0 + a1 * b3 - a2 * b2);
    res.d[5] = b0 * (a1 * b0 + a2 * b1 - a0 * b3);
    res.d[6] = b0 * (a0 * b2 + a2 * b0 - a1 * b1);
    res.d[7] = -b0 * (a0 * b1 + a1 * b2 + a2 * b3);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between ibivector and translation  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t prj(const ibivector_t& a, const translation_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between ibivector and even  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 16 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const ibivector_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = b0 * (a0 * b0 + a1 * b3 - a2 * b2);
    res.d[5] = b0 * (a1 * b0 + a2 * b1 - a0 * b3);
    res.d[6] = b0 * (a0 * b2 + a2 * b0 - a1 * b1);
    res.d[7] = -b0 * (a0 * b1 + a1 * b2 + a2 * b3);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between ibivector and odd  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 7 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const ibivector_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b7 = b.d[7],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = b0 * t1;
    res.d[5] = b1 * t1;
    res.d[6] = b2 * t1;
    res.d[7] = -b7 * t1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between evector and scalar  
// a0 e₁ + a1 e₂ + a2 e₃
// b
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t prj(const evector_t& a, const scalar_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2],
        a0b = a0 * b, a1b = a1 * b, a2b = a2 * b;
    res.d[0] = a0b * b;
    res.d[1] = a1b * b;
    res.d[2] = a2b * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between evector and vector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 7 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t prj(const evector_t& a, const vector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 * t1;
    res.d[1] = b1 * t1;
    res.d[2] = b2 * t1;
    res.d[3] = b3 * t1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between evector and bivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 31 muls / 18 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const evector_t& a, const bivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5],
        a1b2 = a1 * b2, a2b1 = a2 * b1, b0b3 = b0 * b3, b1b4 = b1 * b4, b2b5 = b2 * b5,
        t0 = b0b3 + b1b4, t1 = t0 + b2b5, t2 = a1b2 - a2b1;
    res.d[0] = a0 * (b1 * b1 + b2 * b2) - b0 * (a1 * b1 + a2 * b2);
    res.d[1] = b2 * t2 + b0 * (a1 * b0 - a0 * b1);
    res.d[2] = b0 * (a2 * b0 - a0 * b2) - b1 * t2;
    res.d[3] = a2 * (b1 * b3 - b0 * b4) + a1 * (b0 * b5 - b2 * b3) + a0 * (b2 * b4 - b1 * b5);
    res.d[4] = -a0 * t1;
    res.d[5] = -a1 * t1;
    res.d[6] = -a2 * t1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between evector and trivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 10 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t prj(const evector_t& a, const trivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a0b3 = a0 * b3, a1b3 = a1 * b3, a2b3 = a2 * b3;
    res.d[0] = a0b3 * b3;
    res.d[1] = a1b3 * b3;
    res.d[2] = a2b3 * b3;
    res.d[3] = -b3 * (a0 * b0 + a1 * b1 + a2 * b2);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between evector and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const evector_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between evector and horizon  
// a0 e₁ + a1 e₂ + a2 e₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const evector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between evector and origin  
// a0 e₁ + a1 e₂ + a2 e₃
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t prj(const evector_t& a, const origin_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between evector and point  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t prj(const evector_t& a, const point_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between evector and direction  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const evector_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between evector and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃
// 16 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t prj(const evector_t& a, const ebivector_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a2b1 = a2 * b1,
        t0 = a1b2 - a2b1;
    res.d[0] = a0 * (b1 * b1 + b2 * b2) - b0 * (a1 * b1 + a2 * b2);
    res.d[1] = b2 * t0 + b0 * (a1 * b0 - a0 * b1);
    res.d[2] = b0 * (a2 * b0 - a0 * b2) - b1 * t0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between evector and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const evector_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between evector and evector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t prj(const evector_t& a, const evector_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 * t1;
    res.d[1] = b1 * t1;
    res.d[2] = b2 * t1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between evector and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t prj(const evector_t& a, const dpoint_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 * t1;
    res.d[1] = b1 * t1;
    res.d[2] = b2 * t1;
    res.d[3] = t1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between evector and rotation  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 14 muls / 13 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const evector_t& a, const rotation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a1b2 = a1 * b2, a2b3 = a2 * b3, b0b0 = b0 * b0, b2b2 = b2 * b2, b3b3 = b3 * b3,
        b1b1 = b1 * b1, a0b1 = a0 * b1,
        t0 = a1b2 + a2b3, t1 = b0b0 + b2b2;
    res.d[0] = a0 * (t1 + b3b3) - b1 * t0;
    res.d[1] = a1 * (b0b0 + b1b1 + b3b3) - b2 * (a0b1 + a2b3);
    res.d[2] = a2 * (t1 + b1b1) - b3 * (a0b1 + a1b2);
    res.d[3] = 0.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = -b0 * (a0b1 + t0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between evector and translation  
// a0 e₁ + a1 e₂ + a2 e₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const evector_t& a, const translation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = 0.0;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between evector and even  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 47 muls / 34 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const evector_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a1b2 = a1 * b2, a2b3 = a2 * b3, b0b0 = b0 * b0, b2b2 = b2 * b2, b3b3 = b3 * b3,
        b1b1 = b1 * b1, a0b1 = a0 * b1, b1b4 = b1 * b4, b2b5 = b2 * b5, b3b6 = b3 * b6,
        s0 = b1b4 + b2b5 + b3b6,
        t0 = a1b2 + a2b3, t1 = b0b0 + b2b2;
    res.d[0] = a0 * (t1 + b3b3) - b1 * t0;
    res.d[1] = a1 * (b0b0 + b1b1 + b3b3) - b2 * (a0b1 + a2b3);
    res.d[2] = a2 * (t1 + b1b1) - b3 * (a0b1 + a1b2);
    res.d[3] = a2 * (b2 * b4 - b1 * b5 - b3 * b7) + a1 * (b1 * b6 - b2 * b7 - b3 * b4) + a0 * (b3 * b5 - b1 * b7 - b2 * b6);
    res.d[4] = b0 * (a2 * b5 - a1 * b6) + a0 * (2 * b0 * b7 - b1b4 - b2b5 - b3b6);
    res.d[5] = b0 * (a0 * b6 + 2 * a1 * b7 - a2 * b4) - a1 * s0;
    res.d[6] = b0 * (a1 * b4 + 2 * a2 * b7 - a0 * b5) - a2 * s0;
    res.d[7] = -b0 * (a0b1 + t0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between evector and odd  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 40 muls / 28 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const evector_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2, b0b4 = b0 * b4, b1b5 = b1 * b5,
        b2b6 = b2 * b6, b3b7 = b3 * b7,
        s0 = a0b0 + a1b1 + a2b2,
        t0 = b0b4 + b1b5, t1 = t0 + b2b6, t2 = t1 + b3b7;
    res.d[0] = b7 * (a0 * b7 + a2 * b1 - a1 * b2) + b0 * s0;
    res.d[1] = b7 * (a0 * b2 + a1 * b7 - a2 * b0) + b1 * s0;
    res.d[2] = b7 * (a1 * b0 + a2 * b7 - a0 * b1) + b2 * s0;
    res.d[3] = a2 * (b0 * b5 + b2 * b3 - b1 * b4 - b6 * b7) + a1 * (b1 * b3 + b2 * b4 - b0 * b6 - b5 * b7) + a0 * (b0 * b3 + b1 * b6 - b2 * b5 - b4 * b7);
    res.d[4] = -a0 * t2;
    res.d[5] = -a1 * t2;
    res.d[6] = -a2 * t2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between dpoint and scalar  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 7 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t prj(const dpoint_t& a, const scalar_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2],
        a0b = a0 * b, bb = b * b, a1b = a1 * b, a2b = a2 * b;
    res.d[0] = a0b * b;
    res.d[1] = a1b * b;
    res.d[2] = a2b * b;
    res.d[3] = bb;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between dpoint and vector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 7 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t prj(const dpoint_t& a, const vector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 * t1;
    res.d[1] = b1 * t1;
    res.d[2] = b2 * t1;
    res.d[3] = b3 * t1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between dpoint and bivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 31 muls / 18 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const dpoint_t& a, const bivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5],
        a1b2 = a1 * b2, a2b1 = a2 * b1, b0b3 = b0 * b3, b1b4 = b1 * b4, b2b5 = b2 * b5,
        t0 = b0b3 + b1b4, t1 = t0 + b2b5, t2 = a1b2 - a2b1;
    res.d[0] = a0 * (b1 * b1 + b2 * b2) - b0 * (a1 * b1 + a2 * b2);
    res.d[1] = b2 * t2 + b0 * (a1 * b0 - a0 * b1);
    res.d[2] = b0 * (a2 * b0 - a0 * b2) - b1 * t2;
    res.d[3] = a2 * (b1 * b3 - b0 * b4) + a1 * (b0 * b5 - b2 * b3) + a0 * (b2 * b4 - b1 * b5);
    res.d[4] = -a0 * t1;
    res.d[5] = -a1 * t1;
    res.d[6] = -a2 * t1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between dpoint and trivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 10 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t prj(const dpoint_t& a, const trivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a0b3 = a0 * b3, a1b3 = a1 * b3, a2b3 = a2 * b3;
    res.d[0] = a0b3 * b3;
    res.d[1] = a1b3 * b3;
    res.d[2] = a2b3 * b3;
    res.d[3] = -b3 * (a0 * b0 + a1 * b1 + a2 * b2);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between dpoint and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const dpoint_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between dpoint and horizon  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const dpoint_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between dpoint and origin  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t prj(const dpoint_t& a, const origin_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between dpoint and point  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t prj(const dpoint_t& a, const point_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between dpoint and direction  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const dpoint_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between dpoint and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃
// 16 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t prj(const dpoint_t& a, const ebivector_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a2b1 = a2 * b1,
        t0 = a1b2 - a2b1;
    res.d[0] = a0 * (b1 * b1 + b2 * b2) - b0 * (a1 * b1 + a2 * b2);
    res.d[1] = b2 * t0 + b0 * (a1 * b0 - a0 * b1);
    res.d[2] = b0 * (a2 * b0 - a0 * b2) - b1 * t0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between dpoint and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const dpoint_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between dpoint and evector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t prj(const dpoint_t& a, const evector_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 * t1;
    res.d[1] = b1 * t1;
    res.d[2] = b2 * t1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between dpoint and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t prj(const dpoint_t& a, const dpoint_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 * t1;
    res.d[1] = b1 * t1;
    res.d[2] = b2 * t1;
    res.d[3] = t1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between dpoint and rotation  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 17 muls / 13 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const dpoint_t& a, const rotation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a1b2 = a1 * b2, a2b3 = a2 * b3, b0b0 = b0 * b0, b2b2 = b2 * b2, b3b3 = b3 * b3,
        b1b1 = b1 * b1, a0b1 = a0 * b1,
        t0 = a1b2 + a2b3, t1 = b0b0 + b2b2;
    res.d[0] = a0 * (t1 + b3b3) - b1 * t0;
    res.d[1] = a1 * (b0b0 + b1b1 + b3b3) - b2 * (a0b1 + a2b3);
    res.d[2] = a2 * (t1 + b1b1) - b3 * (a0b1 + a1b2);
    res.d[3] = b0b0;
    res.d[4] = b0 * b1;
    res.d[5] = b0 * b2;
    res.d[6] = b0 * b3;
    res.d[7] = -b0 * (a0b1 + t0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between dpoint and translation  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const dpoint_t& a, const translation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = 1.0;
    res.d[4] = a2 * b1 - a1 * b2;
    res.d[5] = a0 * b2 - a2 * b0;
    res.d[6] = a1 * b0 - a0 * b1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between dpoint and even  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 47 muls / 38 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const dpoint_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a1b2 = a1 * b2, a2b3 = a2 * b3, b0b0 = b0 * b0, b2b2 = b2 * b2, b3b3 = b3 * b3,
        b1b1 = b1 * b1, a0b1 = a0 * b1, b1b4 = b1 * b4, b2b5 = b2 * b5, b3b6 = b3 * b6,
        s0 = b1b4 + b2b5 + b3b6,
        t0 = a1b2 + a2b3, t1 = b0b0 + b2b2;
    res.d[0] = a0 * (t1 + b3b3) - b1 * t0;
    res.d[1] = a1 * (b0b0 + b1b1 + b3b3) - b2 * (a0b1 + a2b3);
    res.d[2] = a2 * (t1 + b1b1) - b3 * (a0b1 + a1b2);
    res.d[3] = b0b0 + a2 * (b2 * b4 - b1 * b5 - b3 * b7) + a1 * (b1 * b6 - b2 * b7 - b3 * b4) + a0 * (b3 * b5 - b1 * b7 - b2 * b6);
    res.d[4] = b0 * (a2 * b5 + b1 - a1 * b6) + a0 * (2 * b0 * b7 - b1b4 - b2b5 - b3b6);
    res.d[5] = b0 * (a0 * b6 + 2 * a1 * b7 + b2 - a2 * b4) - a1 * s0;
    res.d[6] = b0 * (a1 * b4 + 2 * a2 * b7 + b3 - a0 * b5) - a2 * s0;
    res.d[7] = -b0 * (a0b1 + t0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between dpoint and odd  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 40 muls / 28 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const dpoint_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2, b0b4 = b0 * b4, b1b5 = b1 * b5,
        b2b6 = b2 * b6, b3b7 = b3 * b7,
        s0 = a0b0 + a1b1 + a2b2,
        t0 = b0b4 + b1b5, t1 = t0 + b2b6, t2 = t1 + b3b7;
    res.d[0] = b7 * (a0 * b7 + a2 * b1 - a1 * b2) + b0 * s0;
    res.d[1] = b7 * (a0 * b2 + a1 * b7 - a2 * b0) + b1 * s0;
    res.d[2] = b7 * (a1 * b0 + a2 * b7 - a0 * b1) + b2 * s0;
    res.d[3] = a2 * (b0 * b5 + b2 * b3 - b1 * b4 - b6 * b7) + a1 * (b1 * b3 + b2 * b4 - b0 * b6 - b5 * b7) + a0 * (b0 * b3 + b1 * b6 - b2 * b5 - b4 * b7);
    res.d[4] = -a0 * t2;
    res.d[5] = -a1 * t2;
    res.d[6] = -a2 * t2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between rotation and scalar  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 8 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t prj(const rotation_t& a, const scalar_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3],
        a0b = a0 * b, a1b = a1 * b, a2b = a2 * b, a3b = a3 * b;
    res.d[0] = a0b * b;
    res.d[1] = a1b * b;
    res.d[2] = a2b * b;
    res.d[3] = a3b * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between rotation and vector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 21 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const rotation_t& a, const vector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        b1b1 = b1 * b1, b2b2 = b2 * b2, a2b2 = a2 * b2, a3b1 = a3 * b1, a1b1 = a1 * b1,
        a2b0 = a2 * b0, a1b2 = a1 * b2, a3b0 = a3 * b0,
        t0 = a2b2 - a3b1, t1 = b1b1 + b2b2, t2 = a1b1 - a2b0, t3 = a1b2 - a3b0;
    res.d[0] = a0 * (b0 * b0 + t1);
    res.d[1] = a1 * t1 - b0 * (a2 * b1 + a3 * b2);
    res.d[2] = b2 * t0 - b0 * t2;
    res.d[3] = -b1 * t0 - b0 * t3;
    res.d[4] = b3 * t0;
    res.d[5] = -b3 * t3;
    res.d[6] = b3 * t2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between rotation and bivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 18 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const rotation_t& a, const bivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5],
        a1b0 = a1 * b0, a2b1 = a2 * b1, a3b2 = a3 * b2,
        t0 = a1b0 + a2b1, t1 = t0 + a3b2;
    res.d[0] = a0 * (b0 * b0 + b1 * b1 + b2 * b2);
    res.d[1] = b0 * t1;
    res.d[2] = b1 * t1;
    res.d[3] = b2 * t1;
    res.d[4] = b3 * t1;
    res.d[5] = b4 * t1;
    res.d[6] = b5 * t1;
    res.d[7] = 2.0 * (a0 * (b0 * b3 + b1 * b4 + b2 * b5));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between rotation and trivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 17 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const rotation_t& a, const trivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a0b3 = a0 * b3, a1b3 = a1 * b3, a2b3 = a2 * b3, a3b3 = a3 * b3;
    res.d[0] = a0b3 * b3;
    res.d[1] = a1b3 * b3;
    res.d[2] = a2b3 * b3;
    res.d[3] = a3b3 * b3;
    res.d[4] = b3 * (a3 * b1 - a2 * b2);
    res.d[5] = b3 * (a1 * b2 - a3 * b0);
    res.d[6] = b3 * (a2 * b0 - a1 * b1);
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between rotation and quadvector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const rotation_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between rotation and horizon  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const rotation_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between rotation and origin  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// 1 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t prj(const rotation_t& a, const origin_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between rotation and point  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const rotation_t& a, const point_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a3;
    res.d[4] = a3 * b1 - a2 * b2;
    res.d[5] = a1 * b2 - a3 * b0;
    res.d[6] = a2 * b0 - a1 * b1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between rotation and direction  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const rotation_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between rotation and ebivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 10 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t prj(const rotation_t& a, const ebivector_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b0 = a1 * b0, a2b1 = a2 * b1, a3b2 = a3 * b2,
        t0 = a1b0 + a2b1, t1 = t0 + a3b2;
    res.d[0] = a0 * (b0 * b0 + b1 * b1 + b2 * b2);
    res.d[1] = b0 * t1;
    res.d[2] = b1 * t1;
    res.d[3] = b2 * t1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between rotation and ibivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const rotation_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between rotation and evector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 18 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t prj(const rotation_t& a, const evector_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        b1b1 = b1 * b1, b2b2 = b2 * b2, a2b2 = a2 * b2, a3b1 = a3 * b1,
        t0 = b1b1 + b2b2, t1 = a2b2 - a3b1;
    res.d[0] = a0 * (b0 * b0 + t0);
    res.d[1] = a1 * t0 - b0 * (a2 * b1 + a3 * b2);
    res.d[2] = b2 * t1 + b0 * (a2 * b0 - a1 * b1);
    res.d[3] = b0 * (a3 * b0 - a1 * b2) - b1 * t1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between rotation and dpoint  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 18 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const rotation_t& a, const dpoint_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        b1b1 = b1 * b1, b2b2 = b2 * b2, a2b2 = a2 * b2, a3b1 = a3 * b1, a1b1 = a1 * b1,
        a2b0 = a2 * b0, a1b2 = a1 * b2, a3b0 = a3 * b0,
        s0 = a2b2 - a3b1, s1 = a3b0 - a1b2,
        t0 = b1b1 + b2b2, t1 = a1b1 - a2b0;
    res.d[0] = a0 * (b0 * b0 + t0);
    res.d[1] = a1 * t0 - b0 * (a2 * b1 + a3 * b2);
    res.d[2] = b2 * s0 - b0 * t1;
    res.d[3] = b0 * s1 - b1 * s0;
    res.d[4] = a2b2 - a3b1;
    res.d[5] = a3b0 - a1b2;
    res.d[6] = t1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between rotation and rotation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 23 muls / 14 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t prj(const rotation_t& a, const rotation_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a1b1 = a1 * b1, a2b2 = a2 * b2, a3b3 = a3 * b3,
        s0 = a1b1 + a2b2 + a3b3;
    res.d[0] = a0 * (b0 * b0 + b1 * b1 + b2 * b2 + b3 * b3);
    res.d[1] = b1 * s0 + b0 * (a1 * b0 + a2 * b3 - a3 * b2);
    res.d[2] = b2 * s0 + b0 * (a2 * b0 + a3 * b1 - a1 * b3);
    res.d[3] = b3 * s0 + b0 * (a1 * b2 + a3 * b0 - a2 * b1);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between rotation and translation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const rotation_t& a, const translation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a3;
    res.d[4] = a2 * b2 - a3 * b1;
    res.d[5] = a3 * b0 - a1 * b2;
    res.d[6] = a1 * b1 - a2 * b0;
    res.d[7] = -a1 * b0 - a2 * b1 - a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between rotation and even  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 57 muls / 38 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const rotation_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a1b1 = a1 * b1, a2b2 = a2 * b2, a3b3 = a3 * b3, b0b5 = b0 * b5, b2b7 = b2 * b7,
        b0b6 = b0 * b6, b3b7 = b3 * b7, b0b7 = b0 * b7, b1b4 = b1 * b4, b0b4 = b0 * b4,
        b1b7 = b1 * b7, b2b5 = b2 * b5, b3b6 = b3 * b6,
        s0 = a1b1 + a2b2 + a3b3,
        t0 = b0b5 - b2b7, t1 = b0b6 - b3b7, t2 = b0b4 - b1b7;
    res.d[0] = a0 * (b0 * b0 + b1 * b1 + b2 * b2 + b3 * b3);
    res.d[1] = b1 * s0 + b0 * (a1 * b0 + a2 * b3 - a3 * b2);
    res.d[2] = b2 * s0 + b0 * (a2 * b0 + a3 * b1 - a1 * b3);
    res.d[3] = b3 * s0 + b0 * (a1 * b2 + a3 * b0 - a2 * b1);
    res.d[4] = a3 * (b3 * b4 - t0) + a2 * (t1 + b2 * b4) + a1 * (b1b4 - 2 * b0b7);
    res.d[5] = a3 * (t2 + b3 * b5) + a2 * (b2b5 - 2 * b0b7) + a1 * (b1 * b5 - t1);
    res.d[6] = a3 * (b3b6 - 2 * b0b7) + a2 * (b2 * b6 - t2) + a1 * (t0 + b1 * b6);
    res.d[7] = 2.0 * (a0 * (b0b7 - b1b4 - b2b5 - b3b6)) - b0 * (a1 * b4 + a2 * b5 + a3 * b6);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between rotation and odd  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 45 muls / 32 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const rotation_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a1b0 = a1 * b0, a2b1 = a2 * b1, a3b2 = a3 * b2, b0b0 = b0 * b0, b1b1 = b1 * b1,
        b2b2 = b2 * b2, b7b7 = b7 * b7, b1b3 = b1 * b3, b5b7 = b5 * b7, b2b3 = b2 * b3,
        b6b7 = b6 * b7, b0b4 = b0 * b4, b1b5 = b1 * b5, b2b6 = b2 * b6, b3b7 = b3 * b7,
        b0b3 = b0 * b3, b4b7 = b4 * b7,
        s0 = b0b4 + b1b5 + b2b6 + b3b7,
        t0 = b0b0 + b7b7, t1 = a1b0 + a2b1, t2 = t0 + b1b1, t3 = b1b3 - b5b7, t4 = b2b3 - b6b7, t5 = b0b3 - b4b7;
    res.d[0] = a0 * (t2 + b2b2) - b7 * (t1 + a3b2);
    res.d[1] = a1 * (b1b1 + b2b2 + b7b7) - b0 * (a2b1 + a3b2);
    res.d[2] = a2 * (t0 + b2b2) - b1 * (a1b0 + a3b2);
    res.d[3] = a3 * t2 - b2 * t1;
    res.d[4] = a2 * t4 + a1 * s0 - a3 * t3;
    res.d[5] = a3 * t5 + a2 * s0 - a1 * t4;
    res.d[6] = a3 * s0 + a1 * t3 - a2 * t5;
    res.d[7] = a3 * (b0 * b5 - b1 * b4) + a2 * (b2 * b4 - b0 * b6) + a1 * (b1 * b6 - b2 * b5) + 2.0 * (a0 * s0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between translation and scalar  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 7 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const translation_t& a, const scalar_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2],
        bb = b * b, a0b = a0 * b, a1b = a1 * b, a2b = a2 * b;
    res.d[0] = bb;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a0b * b;
    res.d[5] = a1b * b;
    res.d[6] = a2b * b;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between translation and vector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const translation_t& a, const vector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 * b0 + b1 * b1 + b2 * b2;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = b0 * t1;
    res.d[5] = b1 * t1;
    res.d[6] = b2 * t1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between translation and bivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 7 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const translation_t& a, const bivector_t& b) {
    even_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = b0 * b0 + b1 * b1 + b2 * b2;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = 2.0 * (b0 * b3 + b1 * b4 + b2 * b5);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between translation and trivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 1 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const translation_t& a, const trivector_t& b) {

    const float b3 = b.d[3];
    return b3 * b3;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between translation and quadvector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const translation_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between translation and horizon  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const translation_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between translation and origin  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 e₁₂₃
// -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline translation_t prj(const translation_t& a, const origin_t& b) {
    translation_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between translation and point  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline translation_t prj(const translation_t& a, const point_t& b) {
    translation_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between translation and direction  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const translation_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between translation and ebivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const translation_t& a, const ebivector_t& b) {

    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return b0 * b0 + b1 * b1 + b2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between translation and ibivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const translation_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between translation and evector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const translation_t& a, const evector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 * b0 + b1 * b1 + b2 * b2;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = b0 * t1;
    res.d[5] = b1 * t1;
    res.d[6] = b2 * t1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between translation and dpoint  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const translation_t& a, const dpoint_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 * b0 + b1 * b1 + b2 * b2;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = b0 * t1;
    res.d[5] = b1 * t1;
    res.d[6] = b2 * t1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between translation and rotation  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 20 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const translation_t& a, const rotation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0 * b0 + b1 * b1 + b2 * b2 + b3 * b3;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = b0 * (a0 * b0 + a1 * b3 - a2 * b2);
    res.d[5] = b0 * (a1 * b0 + a2 * b1 - a0 * b3);
    res.d[6] = b0 * (a0 * b2 + a2 * b0 - a1 * b1);
    res.d[7] = -b0 * (a0 * b1 + a1 * b2 + a2 * b3);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between translation and translation  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline translation_t prj(const translation_t& a, const translation_t& b) {
    translation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between translation and even  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 25 muls / 15 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const translation_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = b0 * b0 + b1 * b1 + b2 * b2 + b3 * b3;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = b0 * (a0 * b0 + a1 * b3 - a2 * b2);
    res.d[5] = b0 * (a1 * b0 + a2 * b1 - a0 * b3);
    res.d[6] = b0 * (a0 * b2 + a2 * b0 - a1 * b1);
    res.d[7] = 2.0 * (b0 * b7 - b1 * b4 - b2 * b5 - b3 * b6) - b0 * (a0 * b1 + a1 * b2 + a2 * b3);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between translation and odd  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 16 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const translation_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 * b0 + b1 * b1 + b2 * b2 + b7 * b7;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = b0 * t1;
    res.d[5] = b1 * t1;
    res.d[6] = b2 * t1;
    res.d[7] = 2.0 * (b0 * b4 + b1 * b5 + b2 * b6 + b3 * b7) - b7 * t1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between even and scalar  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 16 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const even_t& a, const scalar_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7],
        a0b = a0 * b, a1b = a1 * b, a2b = a2 * b, a3b = a3 * b,
        a4b = a4 * b, a5b = a5 * b, a6b = a6 * b, a7b = a7 * b;
    res.d[0] = a0b * b;
    res.d[1] = a1b * b;
    res.d[2] = a2b * b;
    res.d[3] = a3b * b;
    res.d[4] = a4b * b;
    res.d[5] = a5b * b;
    res.d[6] = a6b * b;
    res.d[7] = a7b * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between even and vector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 28 muls / 14 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const even_t& a, const vector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        b0b0 = b0 * b0, b1b1 = b1 * b1, b2b2 = b2 * b2, a2b2 = a2 * b2, a3b1 = a3 * b1,
        a1b1 = a1 * b1, a2b0 = a2 * b0, a1b2 = a1 * b2, a3b0 = a3 * b0, a4b0 = a4 * b0,
        a5b1 = a5 * b1, a6b2 = a6 * b2,
        s0 = a2b2 - a3b1, s1 = a3b0 - a1b2, s2 = a4b0 + a5b1 + a6b2,
        t0 = b1b1 + b2b2, t1 = b0b0 + t0, t2 = a1b1 - a2b0;
    res.d[0] = a0 * t1;
    res.d[1] = a1 * t0 - b0 * (a2 * b1 + a3 * b2);
    res.d[2] = b2 * s0 - b0 * t2;
    res.d[3] = b0 * s1 - b1 * s0;
    res.d[4] = b0 * s2 + b3 * s0;
    res.d[5] = b1 * s2 + b3 * s1;
    res.d[6] = b2 * s2 + b3 * t2;
    res.d[7] = a7 * t1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between even and bivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 19 muls / 7 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const even_t& a, const bivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5],
        b0b0 = b0 * b0, b1b1 = b1 * b1, b2b2 = b2 * b2, a1b0 = a1 * b0, a2b1 = a2 * b1,
        a3b2 = a3 * b2,
        t0 = a1b0 + a2b1, t1 = t0 + a3b2, t2 = b0b0 + b1b1, t3 = t2 + b2b2;
    res.d[0] = a0 * t3;
    res.d[1] = b0 * t1;
    res.d[2] = b1 * t1;
    res.d[3] = b2 * t1;
    res.d[4] = b3 * t1;
    res.d[5] = b4 * t1;
    res.d[6] = b5 * t1;
    res.d[7] = a7 * t3 + 2.0 * (a0 * (b0 * b3 + b1 * b4 + b2 * b5));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between even and trivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 19 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const even_t& a, const trivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a0b3 = a0 * b3, a1b3 = a1 * b3, a2b3 = a2 * b3, a3b3 = a3 * b3,
        a7b3 = a7 * b3;
    res.d[0] = a0b3 * b3;
    res.d[1] = a1b3 * b3;
    res.d[2] = a2b3 * b3;
    res.d[3] = a3b3 * b3;
    res.d[4] = b3 * (a3 * b1 - a2 * b2);
    res.d[5] = b3 * (a1 * b2 - a3 * b0);
    res.d[6] = b3 * (a2 * b0 - a1 * b1);
    res.d[7] = a7b3 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between even and quadvector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const even_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between even and horizon  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const even_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between even and origin  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// 1 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const even_t& a, const origin_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a7 = a.d[7];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a3;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = a7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between even and point  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const even_t& a, const point_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a3;
    res.d[4] = a3 * b1 - a2 * b2;
    res.d[5] = a1 * b2 - a3 * b0;
    res.d[6] = a2 * b0 - a1 * b1;
    res.d[7] = a7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between even and direction  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const even_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between even and ebivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 11 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const even_t& a, const ebivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        b0b0 = b0 * b0, b1b1 = b1 * b1, b2b2 = b2 * b2, a1b0 = a1 * b0, a2b1 = a2 * b1,
        a3b2 = a3 * b2,
        t0 = a1b0 + a2b1, t1 = t0 + a3b2, t2 = b0b0 + b1b1, t3 = t2 + b2b2;
    res.d[0] = a0 * t3;
    res.d[1] = b0 * t1;
    res.d[2] = b1 * t1;
    res.d[3] = b2 * t1;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = a7 * t3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between even and ibivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const even_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between even and evector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 25 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const even_t& a, const evector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        b0b0 = b0 * b0, b1b1 = b1 * b1, b2b2 = b2 * b2, a2b2 = a2 * b2, a3b1 = a3 * b1,
        a4b0 = a4 * b0, a5b1 = a5 * b1, a6b2 = a6 * b2,
        t0 = b1b1 + b2b2, t1 = a4b0 + a5b1, t2 = t1 + a6b2, t3 = b0b0 + t0, t4 = a2b2 - a3b1;
    res.d[0] = a0 * t3;
    res.d[1] = a1 * t0 - b0 * (a2 * b1 + a3 * b2);
    res.d[2] = b2 * t4 + b0 * (a2 * b0 - a1 * b1);
    res.d[3] = b0 * (a3 * b0 - a1 * b2) - b1 * t4;
    res.d[4] = b0 * t2;
    res.d[5] = b1 * t2;
    res.d[6] = b2 * t2;
    res.d[7] = a7 * t3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between even and dpoint  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 25 muls / 15 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const even_t& a, const dpoint_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        b0b0 = b0 * b0, b1b1 = b1 * b1, b2b2 = b2 * b2, a2b2 = a2 * b2, a3b1 = a3 * b1,
        a1b1 = a1 * b1, a2b0 = a2 * b0, a1b2 = a1 * b2, a3b0 = a3 * b0, a4b0 = a4 * b0,
        a5b1 = a5 * b1, a6b2 = a6 * b2,
        s0 = a4b0 + a5b1 + a6b2,
        t0 = b1b1 + b2b2, t1 = a2b2 - a3b1, t2 = b0b0 + t0, t3 = a1b1 - a2b0, t4 = a1b2 - a3b0;
    res.d[0] = a0 * t2;
    res.d[1] = a1 * t0 - b0 * (a2 * b1 + a3 * b2);
    res.d[2] = b2 * t1 - b0 * t3;
    res.d[3] = -b1 * t1 - b0 * t4;
    res.d[4] = t1 + b0 * s0;
    res.d[5] = b1 * s0 - t4;
    res.d[6] = t3 + b2 * s0;
    res.d[7] = a7 * t2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between even and rotation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 41 muls / 24 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const even_t& a, const rotation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        b1b1 = b1 * b1, b2b2 = b2 * b2, b3b3 = b3 * b3, a1b1 = a1 * b1, a2b2 = a2 * b2,
        a3b3 = a3 * b3,
        s0 = a1b1 + a2b2 + a3b3,
        t0 = b1b1 + b2b2, t1 = t0 + b3b3;
    res.d[0] = a0 * (b0 * b0 + t1);
    res.d[1] = b1 * s0 + b0 * (a1 * b0 + a2 * b3 - a3 * b2);
    res.d[2] = b2 * s0 + b0 * (a2 * b0 + a3 * b1 - a1 * b3);
    res.d[3] = b3 * s0 + b0 * (a1 * b2 + a3 * b0 - a2 * b1);
    res.d[4] = b0 * (a4 * b0 + a5 * b3 - a6 * b2);
    res.d[5] = b0 * (a5 * b0 + a6 * b1 - a4 * b3);
    res.d[6] = b0 * (a4 * b2 + a6 * b0 - a5 * b1);
    res.d[7] = a7 * t1 + b0 * (a7 * b0 - a4 * b1 - a5 * b2 - a6 * b3);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between even and translation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const even_t& a, const translation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a3;
    res.d[4] = a2 * b2 + a4 - a3 * b1;
    res.d[5] = a3 * b0 + a5 - a1 * b2;
    res.d[6] = a1 * b1 + a6 - a2 * b0;
    res.d[7] = a7 - a1 * b0 - a2 * b1 - a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between even and even  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 68 muls / 46 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const even_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        b1b1 = b1 * b1, b2b2 = b2 * b2, b3b3 = b3 * b3, a1b1 = a1 * b1, a2b2 = a2 * b2,
        a3b3 = a3 * b3, a2b3 = a2 * b3, a3b2 = a3 * b2, a1b3 = a1 * b3, a3b1 = a3 * b1,
        a1b2 = a1 * b2, a2b1 = a2 * b1,
        s0 = a1b1 + a2b2 + a3b3,
        t0 = b1b1 + b2b2, t1 = t0 + b3b3, t2 = a2b3 - a3b2, t3 = a1b3 - a3b1, t4 = a1b2 - a2b1;
    res.d[0] = a0 * (b0 * b0 + t1);
    res.d[1] = b1 * s0 + b0 * (a1 * b0 + t2);
    res.d[2] = b2 * s0 + b0 * (a2 * b0 - t3);
    res.d[3] = b3 * s0 + b0 * (t4 + a3 * b0);
    res.d[4] = b4 * s0 + b0 * (a2 * b6 + a4 * b0 + a5 * b3 - 2 * a1 * b7 - a3 * b5 - a6 * b2) - b7 * t2;
    res.d[5] = b7 * t3 + b5 * s0 + b0 * (a3 * b4 + a5 * b0 + a6 * b1 - a1 * b6 - 2 * a2 * b7 - a4 * b3);
    res.d[6] = b6 * s0 + b0 * (a1 * b5 + a4 * b2 + a6 * b0 - a2 * b4 - 2 * a3 * b7 - a5 * b1) - b7 * t4;
    res.d[7] = a7 * t1 + b0 * (a7 * b0 - a1 * b4 - a2 * b5 - a3 * b6 - a4 * b1 - a5 * b2 - a6 * b3) + 2.0 * (a0 * (b0 * b7 - b1 * b4 - b2 * b5 - b3 * b6));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between even and odd  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 59 muls / 44 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t prj(const even_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a1b0 = a1 * b0, a2b1 = a2 * b1, a3b2 = a3 * b2, b0b0 = b0 * b0, b1b1 = b1 * b1,
        b2b2 = b2 * b2, b7b7 = b7 * b7, a4b0 = a4 * b0, a5b1 = a5 * b1, a6b2 = a6 * b2,
        b1b3 = b1 * b3, b5b7 = b5 * b7, b2b3 = b2 * b3, b6b7 = b6 * b7, b0b4 = b0 * b4,
        b1b5 = b1 * b5, b2b6 = b2 * b6, b3b7 = b3 * b7, b0b3 = b0 * b3, b4b7 = b4 * b7,
        a7b7 = a7 * b7,
        s0 = a4b0 + a5b1 + a6b2, s1 = b0b4 + b1b5 + b2b6 + b3b7,
        t0 = b0b0 + b7b7, t1 = a1b0 + a2b1, t2 = t0 + b1b1, t3 = b1b3 - b5b7, t4 = b2b3 - b6b7, t5 = b0b3 - b4b7;
    res.d[0] = a0 * (t2 + b2b2) - b7 * (t1 + a3b2);
    res.d[1] = a1 * (b1b1 + b2b2 + b7b7) - b0 * (a2b1 + a3b2);
    res.d[2] = a2 * (t0 + b2b2) - b1 * (a1b0 + a3b2);
    res.d[3] = a3 * t2 - b2 * t1;
    res.d[4] = b0 * s0 + a2 * t4 + a1 * s1 - a3 * t3;
    res.d[5] = b1 * s0 + a3 * t5 + a2 * s1 - a1 * t4;
    res.d[6] = b2 * s0 + a3 * s1 + a1 * t3 - a2 * t5;
    res.d[7] = a7b7 * b7 + b0 * (a3 * b5 + a7 * b0 - a2 * b6 - a4 * b7) + b2 * (a2 * b4 + a7 * b2 - a1 * b5 - a6 * b7) + b1 * (a1 * b6 + a7 * b1 - a3 * b4 - a5 * b7) + 2.0 * (a0 * s1);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between odd and scalar  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 16 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const odd_t& a, const scalar_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7],
        a0b = a0 * b, a1b = a1 * b, a2b = a2 * b, a3b = a3 * b,
        a4b = a4 * b, a5b = a5 * b, a6b = a6 * b, a7b = a7 * b;
    res.d[0] = a0b * b;
    res.d[1] = a1b * b;
    res.d[2] = a2b * b;
    res.d[3] = a3b * b;
    res.d[4] = a4b * b;
    res.d[5] = a5b * b;
    res.d[6] = a6b * b;
    res.d[7] = a7b * b;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between odd and vector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 21 muls / 14 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const odd_t& a, const vector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2, a5b1 = a5 * b1, a6b2 = a6 * b2,
        a7b3 = a7 * b3, b1b1 = b1 * b1, b2b2 = b2 * b2, b0b0 = b0 * b0, a4b0 = a4 * b0,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2, t2 = a5b1 + a7b3, t3 = b1b1 + b2b2;
    res.d[0] = b0 * t1;
    res.d[1] = b1 * t1;
    res.d[2] = b2 * t1;
    res.d[3] = b3 * t1;
    res.d[4] = a4 * t3 - b0 * (t2 + a6b2);
    res.d[5] = a5 * (b0b0 + b2b2) - b1 * (a4b0 + a6b2 + a7b3);
    res.d[6] = a6 * (b0b0 + b1b1) - b2 * (a4b0 + t2);
    res.d[7] = a7 * (b0b0 + t3);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between odd and bivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 51 muls / 30 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const odd_t& a, const bivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5],
        b1b1 = b1 * b1, b2b2 = b2 * b2, a1b2 = a1 * b2, a2b1 = a2 * b1, a4b0 = a4 * b0,
        a5b1 = a5 * b1, a6b2 = a6 * b2, b0b3 = b0 * b3, b1b4 = b1 * b4, b2b5 = b2 * b5,
        s0 = a4b0 + a5b1 + a6b2, s1 = b0b3 + b1b4 + b2b5,
        t0 = b1b1 + b2b2, t1 = a1b2 - a2b1;
    res.d[0] = a0 * t0 - b0 * (a1 * b1 + a2 * b2);
    res.d[1] = b2 * t1 + b0 * (a1 * b0 - a0 * b1);
    res.d[2] = b0 * (a2 * b0 - a0 * b2) - b1 * t1;
    res.d[3] = b0 * (a1 * b5 - a2 * b4 - a7 * b3) + b2 * (a0 * b4 - a1 * b3 - a7 * b5) + b1 * (a2 * b3 - a0 * b5 - a7 * b4);
    res.d[4] = a7 * (b1 * b5 - b2 * b4) + b0 * s0 - a0 * s1;
    res.d[5] = a7 * (b2 * b3 - b0 * b5) + b1 * s0 - a1 * s1;
    res.d[6] = a7 * (b0 * b4 - b1 * b3) + b2 * s0 - a2 * s1;
    res.d[7] = a7 * (b0 * b0 + t0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between odd and trivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 15 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const odd_t& a, const trivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a0b3 = a0 * b3, a1b3 = a1 * b3, a2b3 = a2 * b3, a7b3 = a7 * b3;
    res.d[0] = a0b3 * b3;
    res.d[1] = a1b3 * b3;
    res.d[2] = a2b3 * b3;
    res.d[3] = -b3 * (a0 * b0 + a1 * b1 + a2 * b2);
    res.d[4] = a7b3 * b0;
    res.d[5] = a7b3 * b1;
    res.d[6] = a7b3 * b2;
    res.d[7] = a7b3 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between odd and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const odd_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between odd and horizon  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const odd_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between odd and origin  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const odd_t& a, const origin_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a7 = a.d[7];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = 0.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = a7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between odd and point  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const odd_t& a, const point_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    res.d[4] = a7 * b0;
    res.d[5] = a7 * b1;
    res.d[6] = a7 * b2;
    res.d[7] = a7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between odd and direction  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const odd_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between odd and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 24 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const odd_t& a, const ebivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        b1b1 = b1 * b1, b2b2 = b2 * b2, a1b2 = a1 * b2, a2b1 = a2 * b1, a4b0 = a4 * b0,
        a5b1 = a5 * b1, a6b2 = a6 * b2,
        t0 = a4b0 + a5b1, t1 = t0 + a6b2, t2 = b1b1 + b2b2, t3 = a1b2 - a2b1;
    res.d[0] = a0 * t2 - b0 * (a1 * b1 + a2 * b2);
    res.d[1] = b2 * t3 + b0 * (a1 * b0 - a0 * b1);
    res.d[2] = b0 * (a2 * b0 - a0 * b2) - b1 * t3;
    res.d[3] = 0.0;
    res.d[4] = b0 * t1;
    res.d[5] = b1 * t1;
    res.d[6] = b2 * t1;
    res.d[7] = a7 * (b0 * b0 + t2);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between odd and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t prj(const odd_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// prj between odd and evector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 24 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const odd_t& a, const evector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2, b1b1 = b1 * b1, b2b2 = b2 * b2,
        a5b2 = a5 * b2, a6b1 = a6 * b1,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2, t2 = b1b1 + b2b2, t3 = a5b2 - a6b1;
    res.d[0] = b0 * t1;
    res.d[1] = b1 * t1;
    res.d[2] = b2 * t1;
    res.d[3] = 0.0;
    res.d[4] = a4 * t2 - b0 * (a5 * b1 + a6 * b2);
    res.d[5] = b2 * t3 + b0 * (a5 * b0 - a4 * b1);
    res.d[6] = b0 * (a6 * b0 - a4 * b2) - b1 * t3;
    res.d[7] = a7 * (b0 * b0 + t2);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between odd and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 19 muls / 14 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const odd_t& a, const dpoint_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2, a5b1 = a5 * b1, a6b2 = a6 * b2,
        b1b1 = b1 * b1, b2b2 = b2 * b2, b0b0 = b0 * b0, a4b0 = a4 * b0,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2, t2 = a5b1 + a7, t3 = b1b1 + b2b2;
    res.d[0] = b0 * t1;
    res.d[1] = b1 * t1;
    res.d[2] = b2 * t1;
    res.d[3] = t1;
    res.d[4] = a4 * t3 - b0 * (t2 + a6b2);
    res.d[5] = a5 * (b0b0 + b2b2) - b1 * (a4b0 + a6b2 + a7);
    res.d[6] = a6 * (b0b0 + b1b1) - b2 * (a4b0 + t2);
    res.d[7] = a7 * (b0b0 + t3);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between odd and rotation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 39 muls / 29 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const odd_t& a, const rotation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a1b2 = a1 * b2, a2b3 = a2 * b3, b0b0 = b0 * b0, b2b2 = b2 * b2, b3b3 = b3 * b3,
        b1b1 = b1 * b1, a0b1 = a0 * b1, a3b0 = a3 * b0, a4b1 = a4 * b1, a5b2 = a5 * b2,
        a6b3 = a6 * b3,
        s0 = a4b1 + a5b2 + a6b3,
        t0 = a1b2 + a2b3, t1 = b0b0 + b2b2, t2 = b1b1 + b3b3;
    res.d[0] = a0 * (t1 + b3b3) - b1 * t0;
    res.d[1] = a1 * (b0b0 + t2) - b2 * (a0b1 + a2b3);
    res.d[2] = a2 * (t1 + b1b1) - b3 * (a0b1 + a1b2);
    res.d[3] = a3b0 * b0;
    res.d[4] = b1 * s0 + b0 * (a3 * b1 + a4 * b0 + a5 * b3 - a6 * b2);
    res.d[5] = b2 * s0 + b0 * (a3 * b2 + a5 * b0 + a6 * b1 - a4 * b3);
    res.d[6] = b3 * s0 + b0 * (a3 * b3 + a4 * b2 + a6 * b0 - a5 * b1);
    res.d[7] = a7 * (t2 + b2b2) + b0 * (a7 * b0 - a0b1 - t0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between odd and translation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 9 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const odd_t& a, const translation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = a3;
    res.d[4] = a2 * b1 + a4 - a1 * b2 - a7 * b0;
    res.d[5] = a0 * b2 + a5 - a2 * b0 - a7 * b1;
    res.d[6] = a1 * b0 + a6 - a0 * b1 - a7 * b2;
    res.d[7] = a7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between odd and even  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 75 muls / 64 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const odd_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a1b2 = a1 * b2, a2b3 = a2 * b3, b0b0 = b0 * b0, b2b2 = b2 * b2, b3b3 = b3 * b3,
        b1b1 = b1 * b1, a0b1 = a0 * b1, a0b5 = a0 * b5, a1b4 = a1 * b4, a2b7 = a2 * b7,
        a7b6 = a7 * b6, a0b6 = a0 * b6, a1b7 = a1 * b7, a2b4 = a2 * b4, a7b5 = a7 * b5,
        a1b6 = a1 * b6, a2b5 = a2 * b5, a7b4 = a7 * b4, a4b1 = a4 * b1, a5b2 = a5 * b2,
        a6b3 = a6 * b3, b1b4 = b1 * b4, b2b5 = b2 * b5, b3b6 = b3 * b6,
        s0 = a4b1 + a5b2 + a6b3, s1 = b1b4 + b2b5 + b3b6,
        t0 = a1b2 + a2b3, t1 = b0b0 + b2b2, t2 = b1b1 + b3b3, t3 = a0b5 - a1b4, t4 = a0b6 - a2b4, t5 = a1b6 - a2b5;
    res.d[0] = a0 * (t1 + b3b3) - b1 * t0;
    res.d[1] = a1 * (b0b0 + t2) - b2 * (a0b1 + a2b3);
    res.d[2] = a2 * (t1 + b1b1) - b3 * (a0b1 + a1b2);
    res.d[3] = b0 * (a3 * b0 + 2 * a7 * b7) + b3 * (t3 - a2b7 - a7b6) + b1 * (t5 - a0 * b7 - a7b4) - b2 * (t4 + a1b7 + a7b5);
    res.d[4] = a7 * (b2 * b6 - b3 * b5) + b1 * s0 + b0 * (a3 * b1 + a4 * b0 + a5 * b3 - t5 - a6 * b2 - a7b4) + a0 * (2 * b0 * b7 - b1b4 - b2b5 - b3b6);
    res.d[5] = a7 * (b3 * b4 - b1 * b6) + b2 * s0 + b0 * (t4 + 2 * a1b7 + a3 * b2 + a5 * b0 + a6 * b1 - a4 * b3 - a7b5) - a1 * s1;
    res.d[6] = a7 * (b1 * b5 - b2 * b4) + b3 * s0 + b0 * (2 * a2b7 + a3 * b3 + a4 * b2 + a6 * b0 - t3 - a5 * b1 - a7b6) - a2 * s1;
    res.d[7] = a7 * (t2 + b2b2) + b0 * (a7 * b0 - a0b1 - t0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// prj between odd and odd  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 67 muls / 53 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t prj(const odd_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2, b0b4 = b0 * b4, b1b5 = b1 * b5,
        b2b6 = b2 * b6, b3b7 = b3 * b7, b2b3 = b2 * b3, b6b7 = b6 * b7, b1b3 = b1 * b3,
        b5b7 = b5 * b7, b0b3 = b0 * b3, b4b7 = b4 * b7, a4b2 = a4 * b2, a5b7 = a5 * b7,
        a6b0 = a6 * b0, a7b5 = a7 * b5, a4b1 = a4 * b1, a5b0 = a5 * b0, a6b7 = a6 * b7,
        a7b6 = a7 * b6, a4b7 = a4 * b7, a5b2 = a5 * b2, a6b1 = a6 * b1, a7b4 = a7 * b4,
        s0 = a0b0 + a1b1 + a2b2, s1 = b0b4 + b1b5 + b2b6 + b3b7,
        t0 = b2b3 - b6b7, t1 = b1b3 - b5b7, t2 = b0b3 - b4b7, t3 = a4b2 + a5b7, t4 = t3 - a6b0, t5 = t4 - a7b5;
    res.d[0] = b7 * (a0 * b7 + a2 * b1 - a1 * b2) + b0 * s0;
    res.d[1] = b7 * (a0 * b2 + a1 * b7 - a2 * b0) + b1 * s0;
    res.d[2] = b7 * (a1 * b0 + a2 * b7 - a0 * b1) + b2 * s0;
    res.d[3] = a2 * (b0 * b5 + t0 - b1 * b4) + a1 * (t1 + b2 * b4 - b0 * b6) + a0 * (t2 + b1 * b6 - b2 * b5) - a7 * s1;
    res.d[4] = b2 * t5 + b1 * (a4b1 + a7b6 - a5b0 - a6b7) - a7 * t2 - a0 * s1;
    res.d[5] = b2 * (a5b2 + a7b4 - a4b7 - a6b1) + b0 * (a5b0 + a6b7 - a4b1 - a7b6) - a7 * t1 - a1 * s1;
    res.d[6] = b1 * (a4b7 + a6b1 - a5b2 - a7b4) - a7 * t0 - b0 * t5 - a2 * s1;
    res.d[7] = a7 * (b0 * b0 + b1 * b1 + b2 * b2 + b7 * b7);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between scalar and vector  
// a
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const scalar_t& a, const vector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between scalar and bivector  
// a
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const scalar_t& a, const bivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between scalar and trivector  
// a
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const scalar_t& a, const trivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between scalar and quadvector  
// a
// b0 e₀₁₂₃
// -> r
// 1 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const scalar_t& a, const quadvector_t& b) {

    const float b0 = b.d[0];
    return a * b0;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between scalar and horizon  
// a
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const scalar_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between scalar and origin  
// a
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const scalar_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between scalar and point  
// a
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const scalar_t& a, const point_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between scalar and direction  
// a
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const scalar_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between scalar and ebivector  
// a
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const scalar_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between scalar and ibivector  
// a
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const scalar_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between scalar and evector  
// a
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const scalar_t& a, const evector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between scalar and dpoint  
// a
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const scalar_t& a, const dpoint_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between scalar and rotation  
// a
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const scalar_t& a, const rotation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between scalar and translation  
// a
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const scalar_t& a, const translation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between scalar and even  
// a
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r
// 1 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const scalar_t& a, const even_t& b) {

    const float b7 = b.d[7];
    return a * b7;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between scalar and odd  
// a
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const scalar_t& a, const odd_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between vector and scalar  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const vector_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between vector and vector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const vector_t& a, const vector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between vector and bivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const vector_t& a, const bivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between vector and trivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 4 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const vector_t& a, const trivector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    return a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between vector and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const vector_t& a, const quadvector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    res.d[3] = a3 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between vector and horizon  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const vector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between vector and origin  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const vector_t& a, const origin_t& b) {

    const float a3 = a.d[3];
    return a3;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between vector and point  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const vector_t& a, const point_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2 + a3;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between vector and direction  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const vector_t& a, const direction_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between vector and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const vector_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between vector and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const vector_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between vector and evector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const vector_t& a, const evector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between vector and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const vector_t& a, const dpoint_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between vector and rotation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const vector_t& a, const rotation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between vector and translation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const vector_t& a, const translation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between vector and even  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const vector_t& a, const even_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b7 = b.d[7];
    res.d[0] = a0 * b7;
    res.d[1] = a1 * b7;
    res.d[2] = a2 * b7;
    res.d[3] = a3 * b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between vector and odd  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r
// 4 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const vector_t& a, const odd_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    return a0 * b4 + a1 * b5 + a2 * b6 + a3 * b7;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between bivector and scalar  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const bivector_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between bivector and vector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const bivector_t& a, const vector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between bivector and bivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 6 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const bivector_t& a, const bivector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    return a0 * b3 + a1 * b4 + a2 * b5 + a3 * b0 + a4 * b1 + a5 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between bivector and trivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 12 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const bivector_t& a, const trivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a1 * b2 + a3 * b3 - a2 * b1;
    res.d[1] = a2 * b0 + a4 * b3 - a0 * b2;
    res.d[2] = a0 * b1 + a5 * b3 - a1 * b0;
    res.d[3] = -a3 * b0 - a4 * b1 - a5 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between bivector and quadvector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 6 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator&(const bivector_t& a, const quadvector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    res.d[3] = a3 * b0;
    res.d[4] = a4 * b0;
    res.d[5] = a5 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between bivector and horizon  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const bivector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between bivector and origin  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator&(const bivector_t& a, const origin_t& b) {
    evector_t res;
    const float a3 = a.d[3], a4 = a.d[4], a5 = a.d[5];
    res.d[0] = a3;
    res.d[1] = a4;
    res.d[2] = a5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between bivector and point  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 9 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const bivector_t& a, const point_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a1 * b2 + a3 - a2 * b1;
    res.d[1] = a2 * b0 + a4 - a0 * b2;
    res.d[2] = a0 * b1 + a5 - a1 * b0;
    res.d[3] = -a3 * b0 - a4 * b1 - a5 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between bivector and direction  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const bivector_t& a, const direction_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    res.d[3] = -a3 * b0 - a4 * b1 - a5 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between bivector and ebivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const bivector_t& a, const ebivector_t& b) {

    const float a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a3 * b0 + a4 * b1 + a5 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between bivector and ibivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const bivector_t& a, const ibivector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between bivector and evector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const bivector_t& a, const evector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between bivector and dpoint  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const bivector_t& a, const dpoint_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between bivector and rotation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const bivector_t& a, const rotation_t& b) {

    const float a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    return a3 * b1 + a4 * b2 + a5 * b3;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between bivector and translation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const bivector_t& a, const translation_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between bivector and even  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator&(const bivector_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b4 + a1 * b5 + a2 * b6 + a3 * b1 + a4 * b2 + a5 * b3;
    res.d[1] = a0 * b7;
    res.d[2] = a1 * b7;
    res.d[3] = a2 * b7;
    res.d[4] = a3 * b7;
    res.d[5] = a4 * b7;
    res.d[6] = a5 * b7;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between bivector and odd  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 12 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const bivector_t& a, const odd_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a1 * b6 + a3 * b7 - a2 * b5;
    res.d[1] = a2 * b4 + a4 * b7 - a0 * b6;
    res.d[2] = a0 * b5 + a5 * b7 - a1 * b4;
    res.d[3] = -a3 * b4 - a4 * b5 - a5 * b6;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between trivector and scalar  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const trivector_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between trivector and vector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 4 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const trivector_t& a, const vector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    return -a0 * b0 - a1 * b1 - a2 * b2 - a3 * b3;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between trivector and bivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 12 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const trivector_t& a, const bivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a2 * b1 + a3 * b3 - a1 * b2;
    res.d[1] = a0 * b2 + a3 * b4 - a2 * b0;
    res.d[2] = a1 * b0 + a3 * b5 - a0 * b1;
    res.d[3] = -a0 * b3 - a1 * b4 - a2 * b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between trivector and trivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 12 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator&(const trivector_t& a, const trivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a3 * b0 - a0 * b3;
    res.d[1] = a3 * b1 - a1 * b3;
    res.d[2] = a3 * b2 - a2 * b3;
    res.d[3] = a1 * b2 - a2 * b1;
    res.d[4] = a2 * b0 - a0 * b2;
    res.d[5] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between trivector and quadvector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator&(const trivector_t& a, const quadvector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    res.d[3] = a3 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between trivector and horizon  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// 1 e₀
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const trivector_t& a, const horizon_t& b) {

    const float a3 = a.d[3];
    return -a3;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between trivector and origin  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// 1 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator&(const trivector_t& a, const origin_t& b) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between trivector and point  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator&(const trivector_t& a, const point_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b0 - a0;
    res.d[1] = a3 * b1 - a1;
    res.d[2] = a3 * b2 - a2;
    res.d[3] = a1 * b2 - a2 * b1;
    res.d[4] = a2 * b0 - a0 * b2;
    res.d[5] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between trivector and direction  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 9 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator&(const trivector_t& a, const direction_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b0;
    res.d[1] = a3 * b1;
    res.d[2] = a3 * b2;
    res.d[3] = a1 * b2 - a2 * b1;
    res.d[4] = a2 * b0 - a0 * b2;
    res.d[5] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between trivector and ebivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator&(const trivector_t& a, const ebivector_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between trivector and ibivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const trivector_t& a, const ibivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b0;
    res.d[1] = a3 * b1;
    res.d[2] = a3 * b2;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between trivector and evector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const trivector_t& a, const evector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return -a0 * b0 - a1 * b1 - a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between trivector and dpoint  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 3 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const trivector_t& a, const dpoint_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return -a0 * b0 - a1 * b1 - a2 * b2 - a3;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between trivector and rotation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator&(const trivector_t& a, const rotation_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 - a2 * b1;
    res.d[2] = a1 * b1 - a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between trivector and translation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const trivector_t& a, const translation_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b0;
    res.d[1] = a3 * b1;
    res.d[2] = a3 * b2;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between trivector and even  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 16 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator&(const trivector_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a2 * b2 + a3 * b4 - a1 * b3;
    res.d[1] = a0 * b3 + a3 * b5 - a2 * b1;
    res.d[2] = a1 * b1 + a3 * b6 - a0 * b2;
    res.d[3] = -a0 * b4 - a1 * b5 - a2 * b6;
    res.d[4] = a0 * b7;
    res.d[5] = a1 * b7;
    res.d[6] = a2 * b7;
    res.d[7] = a3 * b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between trivector and odd  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 16 muls / 10 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator&(const trivector_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = -a0 * b0 - a1 * b1 - a2 * b2 - a3 * b3;
    res.d[1] = a3 * b4 - a0 * b7;
    res.d[2] = a3 * b5 - a1 * b7;
    res.d[3] = a3 * b6 - a2 * b7;
    res.d[4] = a1 * b6 - a2 * b5;
    res.d[5] = a2 * b4 - a0 * b6;
    res.d[6] = a0 * b5 - a1 * b4;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between quadvector and scalar  
// a0 e₀₁₂₃
// b
// -> r
// 1 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const quadvector_t& a, const scalar_t& b) {

    const float a0 = a.d[0];
    return a0 * b;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between quadvector and vector  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const quadvector_t& a, const vector_t& b) {
    vector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    res.d[3] = a0 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between quadvector and bivector  
// a0 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 6 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator&(const quadvector_t& a, const bivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    res.d[3] = a0 * b3;
    res.d[4] = a0 * b4;
    res.d[5] = a0 * b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between quadvector and trivector  
// a0 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator&(const quadvector_t& a, const trivector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    res.d[3] = a0 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between quadvector and quadvector  
// a0 e₀₁₂₃
// b0 e₀₁₂₃
// -> r0 e₀₁₂₃
// 1 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator&(const quadvector_t& a, const quadvector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], b0 = b.d[0];
    res.d[0] = a0 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between quadvector and horizon  
// a0 e₀₁₂₃
// 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const quadvector_t& a, const horizon_t& b) {
    vector_t res;
    const float a0 = a.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between quadvector and origin  
// a0 e₀₁₂₃
// 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator&(const quadvector_t& a, const origin_t& b) {
    trivector_t res;
    const float a0 = a.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between quadvector and point  
// a0 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator&(const quadvector_t& a, const point_t& b) {
    trivector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    res.d[3] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between quadvector and direction  
// a0 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator&(const quadvector_t& a, const direction_t& b) {
    direction_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between quadvector and ebivector  
// a0 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator&(const quadvector_t& a, const ebivector_t& b) {
    ebivector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between quadvector and ibivector  
// a0 e₀₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator&(const quadvector_t& a, const ibivector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between quadvector and evector  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator&(const quadvector_t& a, const evector_t& b) {
    evector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between quadvector and dpoint  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const quadvector_t& a, const dpoint_t& b) {
    vector_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    res.d[3] = a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between quadvector and rotation  
// a0 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator&(const quadvector_t& a, const rotation_t& b) {
    rotation_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    res.d[3] = a0 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between quadvector and translation  
// a0 e₀₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator&(const quadvector_t& a, const translation_t& b) {
    even_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a0 * b0;
    res.d[5] = a0 * b1;
    res.d[6] = a0 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between quadvector and even  
// a0 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 8 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator&(const quadvector_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    res.d[3] = a0 * b3;
    res.d[4] = a0 * b4;
    res.d[5] = a0 * b5;
    res.d[6] = a0 * b6;
    res.d[7] = a0 * b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between quadvector and odd  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 8 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator&(const quadvector_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b0;
    res.d[1] = a0 * b1;
    res.d[2] = a0 * b2;
    res.d[3] = a0 * b3;
    res.d[4] = a0 * b4;
    res.d[5] = a0 * b5;
    res.d[6] = a0 * b6;
    res.d[7] = a0 * b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between horizon and scalar  
// 1 e₀
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const horizon_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between horizon and vector  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const horizon_t& a, const vector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between horizon and bivector  
// 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const horizon_t& a, const bivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between horizon and trivector  
// 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const horizon_t& a, const trivector_t& b) {

    const float b3 = b.d[3];
    return b3;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between horizon and quadvector  
// 1 e₀
// b0 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const horizon_t& a, const quadvector_t& b) {
    vector_t res;
    const float b0 = b.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between horizon and horizon  
// 1 e₀
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const horizon_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between horizon and origin  
// 1 e₀
// 1 e₁₂₃
// -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline translation_t operator&(const horizon_t& a, const origin_t& b) {
    translation_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between horizon and point  
// 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline translation_t operator&(const horizon_t& a, const point_t& b) {
    translation_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between horizon and direction  
// 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const horizon_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between horizon and ebivector  
// 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const horizon_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between horizon and ibivector  
// 1 e₀
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const horizon_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between horizon and evector  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const horizon_t& a, const evector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between horizon and dpoint  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const horizon_t& a, const dpoint_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between horizon and rotation  
// 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const horizon_t& a, const rotation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between horizon and translation  
// 1 e₀
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const horizon_t& a, const translation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between horizon and even  
// 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const horizon_t& a, const even_t& b) {
    vector_t res;
    const float b7 = b.d[7];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between horizon and odd  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const horizon_t& a, const odd_t& b) {

    const float b7 = b.d[7];
    return b7;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between origin and scalar  
// 1 e₁₂₃
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const origin_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between origin and vector  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const origin_t& a, const vector_t& b) {

    const float b3 = b.d[3];
    return -b3;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between origin and bivector  
// 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator&(const origin_t& a, const bivector_t& b) {
    evector_t res;
    const float b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = b3;
    res.d[1] = b4;
    res.d[2] = b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between origin and trivector  
// 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator&(const origin_t& a, const trivector_t& b) {
    ebivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between origin and quadvector  
// 1 e₁₂₃
// b0 e₀₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator&(const origin_t& a, const quadvector_t& b) {
    trivector_t res;
    const float b0 = b.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between origin and horizon  
// 1 e₁₂₃
// 1 e₀
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const origin_t& a, const horizon_t& b) {

    return -1;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between origin and origin  
// 1 e₁₂₃
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const origin_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between origin and point  
// 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator&(const origin_t& a, const point_t& b) {
    ebivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between origin and direction  
// 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator&(const origin_t& a, const direction_t& b) {
    ebivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between origin and ebivector  
// 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const origin_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between origin and ibivector  
// 1 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator&(const origin_t& a, const ibivector_t& b) {
    evector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between origin and evector  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const origin_t& a, const evector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between origin and dpoint  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const origin_t& a, const dpoint_t& b) {

    return -1;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between origin and rotation  
// 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const origin_t& a, const rotation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between origin and translation  
// 1 e₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator&(const origin_t& a, const translation_t& b) {
    evector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between origin and even  
// 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator&(const origin_t& a, const even_t& b) {
    odd_t res;
    const float b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = b4;
    res.d[1] = b5;
    res.d[2] = b6;
    res.d[3] = 0.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between origin and odd  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator&(const origin_t& a, const odd_t& b) {
    rotation_t res;
    const float b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6];
    res.d[0] = -b3;
    res.d[1] = b4;
    res.d[2] = b5;
    res.d[3] = b6;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between point and scalar  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const point_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between point and vector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 3 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const point_t& a, const vector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    return -a0 * b0 - a1 * b1 - a2 * b2 - b3;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between point and bivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 9 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const point_t& a, const bivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a2 * b1 + b3 - a1 * b2;
    res.d[1] = a0 * b2 + b4 - a2 * b0;
    res.d[2] = a1 * b0 + b5 - a0 * b1;
    res.d[3] = -a0 * b3 - a1 * b4 - a2 * b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between point and trivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator&(const point_t& a, const trivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0 - a0 * b3;
    res.d[1] = b1 - a1 * b3;
    res.d[2] = b2 - a2 * b3;
    res.d[3] = a1 * b2 - a2 * b1;
    res.d[4] = a2 * b0 - a0 * b2;
    res.d[5] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between point and quadvector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator&(const point_t& a, const quadvector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    res.d[3] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between point and horizon  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// 1 e₀
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const point_t& a, const horizon_t& b) {

    return -1;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between point and origin  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// 1 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator&(const point_t& a, const origin_t& b) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between point and point  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 6 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator&(const point_t& a, const point_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0 - a0;
    res.d[1] = b1 - a1;
    res.d[2] = b2 - a2;
    res.d[3] = a1 * b2 - a2 * b1;
    res.d[4] = a2 * b0 - a0 * b2;
    res.d[5] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between point and direction  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator&(const point_t& a, const direction_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = a1 * b2 - a2 * b1;
    res.d[4] = a2 * b0 - a0 * b2;
    res.d[5] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between point and ebivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator&(const point_t& a, const ebivector_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between point and ibivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const point_t& a, const ibivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between point and evector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const point_t& a, const evector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return -a0 * b0 - a1 * b1 - a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between point and dpoint  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 3 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const point_t& a, const dpoint_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return -1 - a0 * b0 - a1 * b1 - a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between point and rotation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator&(const point_t& a, const rotation_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 - a2 * b1;
    res.d[2] = a1 * b1 - a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between point and translation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const point_t& a, const translation_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between point and even  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator&(const point_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a2 * b2 + b4 - a1 * b3;
    res.d[1] = a0 * b3 + b5 - a2 * b1;
    res.d[2] = a1 * b1 + b6 - a0 * b2;
    res.d[3] = -a0 * b4 - a1 * b5 - a2 * b6;
    res.d[4] = a0 * b7;
    res.d[5] = a1 * b7;
    res.d[6] = a2 * b7;
    res.d[7] = b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between point and odd  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 10 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator&(const point_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = -a0 * b0 - a1 * b1 - a2 * b2 - b3;
    res.d[1] = b4 - a0 * b7;
    res.d[2] = b5 - a1 * b7;
    res.d[3] = b6 - a2 * b7;
    res.d[4] = a1 * b6 - a2 * b5;
    res.d[5] = a2 * b4 - a0 * b6;
    res.d[6] = a0 * b5 - a1 * b4;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between direction and scalar  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const direction_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between direction and vector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const direction_t& a, const vector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return -a0 * b0 - a1 * b1 - a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between direction and bivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const direction_t& a, const bivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = -a0 * b3 - a1 * b4 - a2 * b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between direction and trivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator&(const direction_t& a, const trivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a0 * b3;
    res.d[1] = -a1 * b3;
    res.d[2] = -a2 * b3;
    res.d[3] = a1 * b2 - a2 * b1;
    res.d[4] = a2 * b0 - a0 * b2;
    res.d[5] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between direction and quadvector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator&(const direction_t& a, const quadvector_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between direction and horizon  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const direction_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between direction and origin  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// 1 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator&(const direction_t& a, const origin_t& b) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between direction and point  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 6 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator&(const direction_t& a, const point_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    res.d[3] = a1 * b2 - a2 * b1;
    res.d[4] = a2 * b0 - a0 * b2;
    res.d[5] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between direction and direction  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator&(const direction_t& a, const direction_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between direction and ebivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator&(const direction_t& a, const ebivector_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between direction and ibivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const direction_t& a, const ibivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between direction and evector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const direction_t& a, const evector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return -a0 * b0 - a1 * b1 - a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between direction and dpoint  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const direction_t& a, const dpoint_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return -a0 * b0 - a1 * b1 - a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between direction and rotation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator&(const direction_t& a, const rotation_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 - a2 * b1;
    res.d[2] = a1 * b1 - a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between direction and translation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const direction_t& a, const translation_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between direction and even  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator&(const direction_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 - a2 * b1;
    res.d[2] = a1 * b1 - a0 * b2;
    res.d[3] = -a0 * b4 - a1 * b5 - a2 * b6;
    res.d[4] = a0 * b7;
    res.d[5] = a1 * b7;
    res.d[6] = a2 * b7;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between direction and odd  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator&(const direction_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = -a0 * b0 - a1 * b1 - a2 * b2;
    res.d[1] = -a0 * b7;
    res.d[2] = -a1 * b7;
    res.d[3] = -a2 * b7;
    res.d[4] = a1 * b6 - a2 * b5;
    res.d[5] = a2 * b4 - a0 * b6;
    res.d[6] = a0 * b5 - a1 * b4;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ebivector and scalar  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const ebivector_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between ebivector and vector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const ebivector_t& a, const vector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between ebivector and bivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const ebivector_t& a, const bivector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    return a0 * b3 + a1 * b4 + a2 * b5;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between ebivector and trivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator&(const ebivector_t& a, const trivector_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ebivector and quadvector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator&(const ebivector_t& a, const quadvector_t& b) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ebivector and horizon  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const ebivector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between ebivector and origin  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const ebivector_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between ebivector and point  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator&(const ebivector_t& a, const point_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ebivector and direction  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator&(const ebivector_t& a, const direction_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ebivector and ebivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const ebivector_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between ebivector and ibivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const ebivector_t& a, const ibivector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between ebivector and evector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const ebivector_t& a, const evector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between ebivector and dpoint  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const ebivector_t& a, const dpoint_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between ebivector and rotation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const ebivector_t& a, const rotation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between ebivector and translation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const ebivector_t& a, const translation_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between ebivector and even  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator&(const ebivector_t& a, const even_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b4 + a1 * b5 + a2 * b6;
    res.d[1] = a0 * b7;
    res.d[2] = a1 * b7;
    res.d[3] = a2 * b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ebivector and odd  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator&(const ebivector_t& a, const odd_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6];
    res.d[0] = a1 * b6 - a2 * b5;
    res.d[1] = a2 * b4 - a0 * b6;
    res.d[2] = a0 * b5 - a1 * b4;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ibivector and scalar  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const ibivector_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between ibivector and vector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const ibivector_t& a, const vector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between ibivector and bivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const ibivector_t& a, const bivector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between ibivector and trivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const ibivector_t& a, const trivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b3;
    res.d[1] = a1 * b3;
    res.d[2] = a2 * b3;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ibivector and quadvector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁₂₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator&(const ibivector_t& a, const quadvector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ibivector and horizon  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const ibivector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between ibivector and origin  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator&(const ibivector_t& a, const origin_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ibivector and point  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const ibivector_t& a, const point_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ibivector and direction  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const ibivector_t& a, const direction_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ibivector and ebivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const ibivector_t& a, const ebivector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between ibivector and ibivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const ibivector_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between ibivector and evector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const ibivector_t& a, const evector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between ibivector and dpoint  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const ibivector_t& a, const dpoint_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between ibivector and rotation  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const ibivector_t& a, const rotation_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    return a0 * b1 + a1 * b2 + a2 * b3;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between ibivector and translation  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const ibivector_t& a, const translation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between ibivector and even  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator&(const ibivector_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b7 = b.d[7];
    res.d[0] = a0 * b1 + a1 * b2 + a2 * b3;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a0 * b7;
    res.d[5] = a1 * b7;
    res.d[6] = a2 * b7;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between ibivector and odd  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const ibivector_t& a, const odd_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b7;
    res.d[1] = a1 * b7;
    res.d[2] = a2 * b7;
    res.d[3] = -a0 * b4 - a1 * b5 - a2 * b6;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between evector and scalar  
// a0 e₁ + a1 e₂ + a2 e₃
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const evector_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between evector and vector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const evector_t& a, const vector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between evector and bivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const evector_t& a, const bivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between evector and trivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const evector_t& a, const trivector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between evector and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator&(const evector_t& a, const quadvector_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between evector and horizon  
// a0 e₁ + a1 e₂ + a2 e₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const evector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between evector and origin  
// a0 e₁ + a1 e₂ + a2 e₃
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const evector_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between evector and point  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const evector_t& a, const point_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between evector and direction  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const evector_t& a, const direction_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between evector and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const evector_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between evector and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const evector_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between evector and evector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const evector_t& a, const evector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between evector and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const evector_t& a, const dpoint_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between evector and rotation  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const evector_t& a, const rotation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between evector and translation  
// a0 e₁ + a1 e₂ + a2 e₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const evector_t& a, const translation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between evector and even  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator&(const evector_t& a, const even_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b7 = b.d[7];
    res.d[0] = a0 * b7;
    res.d[1] = a1 * b7;
    res.d[2] = a2 * b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between evector and odd  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const evector_t& a, const odd_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6];
    return a0 * b4 + a1 * b5 + a2 * b6;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between dpoint and scalar  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const dpoint_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between dpoint and vector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const dpoint_t& a, const vector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between dpoint and bivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const dpoint_t& a, const bivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between dpoint and trivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const dpoint_t& a, const trivector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    return a0 * b0 + a1 * b1 + a2 * b2 + b3;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between dpoint and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const dpoint_t& a, const quadvector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    res.d[3] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between dpoint and horizon  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const dpoint_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between dpoint and origin  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// 1 e₁₂₃
// -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline translation_t operator&(const dpoint_t& a, const origin_t& b) {
    translation_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between dpoint and point  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const dpoint_t& a, const point_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return 1 + a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between dpoint and direction  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const dpoint_t& a, const direction_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between dpoint and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const dpoint_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between dpoint and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const dpoint_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between dpoint and evector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const dpoint_t& a, const evector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between dpoint and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const dpoint_t& a, const dpoint_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between dpoint and rotation  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const dpoint_t& a, const rotation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between dpoint and translation  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const dpoint_t& a, const translation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between dpoint and even  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const dpoint_t& a, const even_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b7 = b.d[7];
    res.d[0] = a0 * b7;
    res.d[1] = a1 * b7;
    res.d[2] = a2 * b7;
    res.d[3] = b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between dpoint and odd  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const dpoint_t& a, const odd_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    return a0 * b4 + a1 * b5 + a2 * b6 + b7;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between rotation and scalar  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const rotation_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between rotation and vector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const rotation_t& a, const vector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between rotation and bivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const rotation_t& a, const bivector_t& b) {

    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    return a1 * b3 + a2 * b4 + a3 * b5;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between rotation and trivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator&(const rotation_t& a, const trivector_t& b) {
    evector_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b2 - a3 * b1;
    res.d[1] = a3 * b0 - a1 * b2;
    res.d[2] = a1 * b1 - a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between rotation and quadvector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator&(const rotation_t& a, const quadvector_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    res.d[3] = a3 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between rotation and horizon  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const rotation_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between rotation and origin  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const rotation_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between rotation and point  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator&(const rotation_t& a, const point_t& b) {
    evector_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b2 - a3 * b1;
    res.d[1] = a3 * b0 - a1 * b2;
    res.d[2] = a1 * b1 - a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between rotation and direction  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator&(const rotation_t& a, const direction_t& b) {
    evector_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b2 - a3 * b1;
    res.d[1] = a3 * b0 - a1 * b2;
    res.d[2] = a1 * b1 - a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between rotation and ebivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const rotation_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between rotation and ibivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const rotation_t& a, const ibivector_t& b) {

    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a1 * b0 + a2 * b1 + a3 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between rotation and evector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const rotation_t& a, const evector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between rotation and dpoint  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const rotation_t& a, const dpoint_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between rotation and rotation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const rotation_t& a, const rotation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between rotation and translation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const rotation_t& a, const translation_t& b) {

    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a1 * b0 + a2 * b1 + a3 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between rotation and even  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 7 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator&(const rotation_t& a, const even_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b7 + a1 * b4 + a2 * b5 + a3 * b6;
    res.d[1] = a1 * b7;
    res.d[2] = a2 * b7;
    res.d[3] = a3 * b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between rotation and odd  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator&(const rotation_t& a, const odd_t& b) {
    evector_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6];
    res.d[0] = a2 * b6 - a3 * b5;
    res.d[1] = a3 * b4 - a1 * b6;
    res.d[2] = a1 * b5 - a2 * b4;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between translation and scalar  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const translation_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between translation and vector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const translation_t& a, const vector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between translation and bivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const translation_t& a, const bivector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between translation and trivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const translation_t& a, const trivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b3;
    res.d[1] = a1 * b3;
    res.d[2] = a2 * b3;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between translation and quadvector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator&(const translation_t& a, const quadvector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = b0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a0 * b0;
    res.d[5] = a1 * b0;
    res.d[6] = a2 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between translation and horizon  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const translation_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between translation and origin  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator&(const translation_t& a, const origin_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between translation and point  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const translation_t& a, const point_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between translation and direction  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const translation_t& a, const direction_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between translation and ebivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const translation_t& a, const ebivector_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return a0 * b0 + a1 * b1 + a2 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between translation and ibivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const translation_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between translation and evector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const translation_t& a, const evector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between translation and dpoint  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const translation_t& a, const dpoint_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between translation and rotation  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const translation_t& a, const rotation_t& b) {

    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    return a0 * b1 + a1 * b2 + a2 * b3;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between translation and translation  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const translation_t& a, const translation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between translation and even  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator&(const translation_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b7 = b.d[7];
    res.d[0] = a0 * b1 + a1 * b2 + a2 * b3 + b7;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a0 * b7;
    res.d[5] = a1 * b7;
    res.d[6] = a2 * b7;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between translation and odd  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const translation_t& a, const odd_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b7;
    res.d[1] = a1 * b7;
    res.d[2] = a2 * b7;
    res.d[3] = -a0 * b4 - a1 * b5 - a2 * b6;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between even and scalar  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b
// -> r
// 1 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const even_t& a, const scalar_t& b) {

    const float a7 = a.d[7];
    return a7 * b;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between even and vector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const even_t& a, const vector_t& b) {
    vector_t res;
    const float a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a7 * b0;
    res.d[1] = a7 * b1;
    res.d[2] = a7 * b2;
    res.d[3] = a7 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between even and bivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator&(const even_t& a, const bivector_t& b) {
    even_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a1 * b3 + a2 * b4 + a3 * b5 + a4 * b0 + a5 * b1 + a6 * b2;
    res.d[1] = a7 * b0;
    res.d[2] = a7 * b1;
    res.d[3] = a7 * b2;
    res.d[4] = a7 * b3;
    res.d[5] = a7 * b4;
    res.d[6] = a7 * b5;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between even and trivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 16 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator&(const even_t& a, const trivector_t& b) {
    odd_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a2 * b2 + a4 * b3 - a3 * b1;
    res.d[1] = a3 * b0 + a5 * b3 - a1 * b2;
    res.d[2] = a1 * b1 + a6 * b3 - a2 * b0;
    res.d[3] = -a4 * b0 - a5 * b1 - a6 * b2;
    res.d[4] = a7 * b0;
    res.d[5] = a7 * b1;
    res.d[6] = a7 * b2;
    res.d[7] = a7 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between even and quadvector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 8 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator&(const even_t& a, const quadvector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    res.d[3] = a3 * b0;
    res.d[4] = a4 * b0;
    res.d[5] = a5 * b0;
    res.d[6] = a6 * b0;
    res.d[7] = a7 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between even and horizon  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const even_t& a, const horizon_t& b) {
    vector_t res;
    const float a7 = a.d[7];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between even and origin  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator&(const even_t& a, const origin_t& b) {
    odd_t res;
    const float a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7];
    res.d[0] = a4;
    res.d[1] = a5;
    res.d[2] = a6;
    res.d[3] = 0.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = a7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between even and point  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator&(const even_t& a, const point_t& b) {
    odd_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b2 + a4 - a3 * b1;
    res.d[1] = a3 * b0 + a5 - a1 * b2;
    res.d[2] = a1 * b1 + a6 - a2 * b0;
    res.d[3] = -a4 * b0 - a5 * b1 - a6 * b2;
    res.d[4] = a7 * b0;
    res.d[5] = a7 * b1;
    res.d[6] = a7 * b2;
    res.d[7] = a7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between even and direction  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator&(const even_t& a, const direction_t& b) {
    odd_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b2 - a3 * b1;
    res.d[1] = a3 * b0 - a1 * b2;
    res.d[2] = a1 * b1 - a2 * b0;
    res.d[3] = -a4 * b0 - a5 * b1 - a6 * b2;
    res.d[4] = a7 * b0;
    res.d[5] = a7 * b1;
    res.d[6] = a7 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between even and ebivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator&(const even_t& a, const ebivector_t& b) {
    rotation_t res;
    const float a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a4 * b0 + a5 * b1 + a6 * b2;
    res.d[1] = a7 * b0;
    res.d[2] = a7 * b1;
    res.d[3] = a7 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between even and ibivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 6 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator&(const even_t& a, const ibivector_t& b) {
    even_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a1 * b0 + a2 * b1 + a3 * b2;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a7 * b0;
    res.d[5] = a7 * b1;
    res.d[6] = a7 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between even and evector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator&(const even_t& a, const evector_t& b) {
    evector_t res;
    const float a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a7 * b0;
    res.d[1] = a7 * b1;
    res.d[2] = a7 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between even and dpoint  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const even_t& a, const dpoint_t& b) {
    vector_t res;
    const float a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a7 * b0;
    res.d[1] = a7 * b1;
    res.d[2] = a7 * b2;
    res.d[3] = a7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between even and rotation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 7 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator&(const even_t& a, const rotation_t& b) {
    rotation_t res;
    const float a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a4 * b1 + a5 * b2 + a6 * b3 + a7 * b0;
    res.d[1] = a7 * b1;
    res.d[2] = a7 * b2;
    res.d[3] = a7 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between even and translation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator&(const even_t& a, const translation_t& b) {
    even_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a1 * b0 + a2 * b1 + a3 * b2 + a7;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a7 * b0;
    res.d[5] = a7 * b1;
    res.d[6] = a7 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between even and even  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 21 muls / 13 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator&(const even_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b7 + a1 * b4 + a2 * b5 + a3 * b6 + a4 * b1 + a5 * b2 + a6 * b3 + a7 * b0;
    res.d[1] = a1 * b7 + a7 * b1;
    res.d[2] = a2 * b7 + a7 * b2;
    res.d[3] = a3 * b7 + a7 * b3;
    res.d[4] = a4 * b7 + a7 * b4;
    res.d[5] = a5 * b7 + a7 * b5;
    res.d[6] = a6 * b7 + a7 * b6;
    res.d[7] = a7 * b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between even and odd  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 20 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator&(const even_t& a, const odd_t& b) {
    odd_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a2 * b6 + a4 * b7 + a7 * b0 - a3 * b5;
    res.d[1] = a3 * b4 + a5 * b7 + a7 * b1 - a1 * b6;
    res.d[2] = a1 * b5 + a6 * b7 + a7 * b2 - a2 * b4;
    res.d[3] = a7 * b3 - a4 * b4 - a5 * b5 - a6 * b6;
    res.d[4] = a7 * b4;
    res.d[5] = a7 * b5;
    res.d[6] = a7 * b6;
    res.d[7] = a7 * b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between odd and scalar  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const odd_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between odd and vector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 4 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const odd_t& a, const vector_t& b) {

    const float a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    return -a4 * b0 - a5 * b1 - a6 * b2 - a7 * b3;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between odd and bivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 12 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const odd_t& a, const bivector_t& b) {
    vector_t res;
    const float a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a6 * b1 + a7 * b3 - a5 * b2;
    res.d[1] = a4 * b2 + a7 * b4 - a6 * b0;
    res.d[2] = a5 * b0 + a7 * b5 - a4 * b1;
    res.d[3] = -a4 * b3 - a5 * b4 - a6 * b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between odd and trivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 16 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator&(const odd_t& a, const trivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
    res.d[1] = a7 * b0 - a4 * b3;
    res.d[2] = a7 * b1 - a5 * b3;
    res.d[3] = a7 * b2 - a6 * b3;
    res.d[4] = a5 * b2 - a6 * b1;
    res.d[5] = a6 * b0 - a4 * b2;
    res.d[6] = a4 * b1 - a5 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between odd and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 8 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator&(const odd_t& a, const quadvector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    res.d[3] = a3 * b0;
    res.d[4] = a4 * b0;
    res.d[5] = a5 * b0;
    res.d[6] = a6 * b0;
    res.d[7] = a7 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between odd and horizon  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// 1 e₀
// -> r
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const odd_t& a, const horizon_t& b) {

    const float a7 = a.d[7];
    return -a7;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between odd and origin  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// 1 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator&(const odd_t& a, const origin_t& b) {
    rotation_t res;
    const float a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6];
    res.d[0] = a3;
    res.d[1] = -a4;
    res.d[2] = -a5;
    res.d[3] = -a6;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between odd and point  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator&(const odd_t& a, const point_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2 + a3;
    res.d[1] = a7 * b0 - a4;
    res.d[2] = a7 * b1 - a5;
    res.d[3] = a7 * b2 - a6;
    res.d[4] = a5 * b2 - a6 * b1;
    res.d[5] = a6 * b0 - a4 * b2;
    res.d[6] = a4 * b1 - a5 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between odd and direction  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator&(const odd_t& a, const direction_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[1] = a7 * b0;
    res.d[2] = a7 * b1;
    res.d[3] = a7 * b2;
    res.d[4] = a5 * b2 - a6 * b1;
    res.d[5] = a6 * b0 - a4 * b2;
    res.d[6] = a4 * b1 - a5 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between odd and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator&(const odd_t& a, const ebivector_t& b) {
    evector_t res;
    const float a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a6 * b1 - a5 * b2;
    res.d[1] = a4 * b2 - a6 * b0;
    res.d[2] = a5 * b0 - a4 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between odd and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const odd_t& a, const ibivector_t& b) {
    vector_t res;
    const float a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a7 * b0;
    res.d[1] = a7 * b1;
    res.d[2] = a7 * b2;
    res.d[3] = -a4 * b0 - a5 * b1 - a6 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between odd and evector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const odd_t& a, const evector_t& b) {

    const float a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return -a4 * b0 - a5 * b1 - a6 * b2;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between odd and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 3 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator&(const odd_t& a, const dpoint_t& b) {

    const float a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    return -a4 * b0 - a5 * b1 - a6 * b2 - a7;

}

////////////////////////////////////////////////////////////////////////////////  
// rp between odd and rotation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator&(const odd_t& a, const rotation_t& b) {
    evector_t res;
    const float a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a6 * b2 - a5 * b3;
    res.d[1] = a4 * b3 - a6 * b1;
    res.d[2] = a5 * b1 - a4 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between odd and translation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator&(const odd_t& a, const translation_t& b) {
    vector_t res;
    const float a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a7 * b0;
    res.d[1] = a7 * b1;
    res.d[2] = a7 * b2;
    res.d[3] = -a4 * b0 - a5 * b1 - a6 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between odd and even  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 20 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator&(const odd_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b7 + a6 * b2 + a7 * b4 - a5 * b3;
    res.d[1] = a1 * b7 + a4 * b3 + a7 * b5 - a6 * b1;
    res.d[2] = a2 * b7 + a5 * b1 + a7 * b6 - a4 * b2;
    res.d[3] = a3 * b7 - a4 * b4 - a5 * b5 - a6 * b6;
    res.d[4] = a4 * b7;
    res.d[5] = a5 * b7;
    res.d[6] = a6 * b7;
    res.d[7] = a7 * b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// rp between odd and odd  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 20 muls / 13 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator&(const odd_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a0 * b4 + a1 * b5 + a2 * b6 + a3 * b7 - a4 * b0 - a5 * b1 - a6 * b2 - a7 * b3;
    res.d[1] = a7 * b4 - a4 * b7;
    res.d[2] = a7 * b5 - a5 * b7;
    res.d[3] = a7 * b6 - a6 * b7;
    res.d[4] = a5 * b6 - a6 * b5;
    res.d[5] = a6 * b4 - a4 * b6;
    res.d[6] = a4 * b5 - a5 * b4;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between scalar and scalar  
// a
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const scalar_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between scalar and vector  
// a
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const scalar_t& a, const vector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between scalar and bivector  
// a
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const scalar_t& a, const bivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between scalar and trivector  
// a
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const scalar_t& a, const trivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between scalar and quadvector  
// a
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const scalar_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between scalar and horizon  
// a
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const scalar_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between scalar and origin  
// a
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const scalar_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between scalar and point  
// a
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const scalar_t& a, const point_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between scalar and direction  
// a
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const scalar_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between scalar and ebivector  
// a
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const scalar_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between scalar and ibivector  
// a
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const scalar_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between scalar and evector  
// a
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const scalar_t& a, const evector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between scalar and dpoint  
// a
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const scalar_t& a, const dpoint_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between scalar and rotation  
// a
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const scalar_t& a, const rotation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between scalar and translation  
// a
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const scalar_t& a, const translation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between scalar and even  
// a
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const scalar_t& a, const even_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between scalar and odd  
// a
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const scalar_t& a, const odd_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between vector and scalar  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const vector_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between vector and vector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 12 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t cp(const vector_t& a, const vector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    res.d[3] = a3 * b0 - a0 * b3;
    res.d[4] = a3 * b1 - a1 * b3;
    res.d[5] = a3 * b2 - a2 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between vector and bivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t cp(const vector_t& a, const bivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = -a0 * b3 - a1 * b4 - a2 * b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between vector and trivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₁₂₃
// 4 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t cp(const vector_t& a, const trivector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between vector and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const vector_t& a, const quadvector_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between vector and horizon  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// 1 e₀
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const vector_t& a, const horizon_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between vector and origin  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// 1 e₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t cp(const vector_t& a, const origin_t& b) {
    quadvector_t res;
    const float a3 = a.d[3];
    res.d[0] = a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between vector and point  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₁₂₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t cp(const vector_t& a, const point_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2 + a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between vector and direction  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₁₂₃
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t cp(const vector_t& a, const direction_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between vector and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t cp(const vector_t& a, const ebivector_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between vector and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t cp(const vector_t& a, const ibivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between vector and evector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 9 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t cp(const vector_t& a, const evector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    res.d[3] = a3 * b0;
    res.d[4] = a3 * b1;
    res.d[5] = a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between vector and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t cp(const vector_t& a, const dpoint_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    res.d[3] = a3 * b0 - a0;
    res.d[4] = a3 * b1 - a1;
    res.d[5] = a3 * b2 - a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between vector and rotation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t cp(const vector_t& a, const rotation_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 - a2 * b1;
    res.d[2] = a1 * b1 - a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between vector and translation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t cp(const vector_t& a, const translation_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between vector and even  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t cp(const vector_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 - a2 * b1;
    res.d[2] = a1 * b1 - a0 * b2;
    res.d[3] = -a0 * b4 - a1 * b5 - a2 * b6;
    res.d[4] = a0 * b7;
    res.d[5] = a1 * b7;
    res.d[6] = a2 * b7;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between vector and odd  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 16 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t cp(const vector_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = 0.0;
    res.d[1] = a1 * b2 - a2 * b1;
    res.d[2] = a2 * b0 - a0 * b2;
    res.d[3] = a0 * b1 - a1 * b0;
    res.d[4] = a3 * b0 - a0 * b3;
    res.d[5] = a3 * b1 - a1 * b3;
    res.d[6] = a3 * b2 - a2 * b3;
    res.d[7] = a0 * b4 + a1 * b5 + a2 * b6 + a3 * b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between bivector and scalar  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const bivector_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between bivector and vector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t cp(const bivector_t& a, const vector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = a3 * b0 + a4 * b1 + a5 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between bivector and bivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 18 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t cp(const bivector_t& a, const bivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = a2 * b4 + a5 * b1 - a1 * b5 - a4 * b2;
    res.d[4] = a0 * b5 + a3 * b2 - a2 * b3 - a5 * b0;
    res.d[5] = a1 * b3 + a4 * b0 - a0 * b4 - a3 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between bivector and trivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const bivector_t& a, const trivector_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a2 * b1 - a1 * b2 - a3 * b3;
    res.d[1] = a0 * b2 - a2 * b0 - a4 * b3;
    res.d[2] = a1 * b0 - a0 * b1 - a5 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between bivector and quadvector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const bivector_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between bivector and horizon  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const bivector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between bivector and origin  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const bivector_t& a, const origin_t& b) {
    direction_t res;
    const float a3 = a.d[3], a4 = a.d[4], a5 = a.d[5];
    res.d[0] = -a3;
    res.d[1] = -a4;
    res.d[2] = -a5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between bivector and point  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 6 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const bivector_t& a, const point_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2 - a3;
    res.d[1] = a0 * b2 - a2 * b0 - a4;
    res.d[2] = a1 * b0 - a0 * b1 - a5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between bivector and direction  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const bivector_t& a, const direction_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between bivector and ebivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 12 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t cp(const bivector_t& a, const ebivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = a5 * b1 - a4 * b2;
    res.d[4] = a3 * b2 - a5 * b0;
    res.d[5] = a4 * b0 - a3 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between bivector and ibivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const bivector_t& a, const ibivector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between bivector and evector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t cp(const bivector_t& a, const evector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = a3 * b0 + a4 * b1 + a5 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between bivector and dpoint  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t cp(const bivector_t& a, const dpoint_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = a3 * b0 + a4 * b1 + a5 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between bivector and rotation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 12 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t cp(const bivector_t& a, const rotation_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 - a2 * b1;
    res.d[2] = a1 * b1 - a0 * b2;
    res.d[3] = a5 * b2 - a4 * b3;
    res.d[4] = a3 * b3 - a5 * b1;
    res.d[5] = a4 * b1 - a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between bivector and translation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const bivector_t& a, const translation_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between bivector and even  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 18 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t cp(const bivector_t& a, const even_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6];
    res.d[0] = a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 - a2 * b1;
    res.d[2] = a1 * b1 - a0 * b2;
    res.d[3] = a2 * b5 + a5 * b2 - a1 * b6 - a4 * b3;
    res.d[4] = a0 * b6 + a3 * b3 - a2 * b4 - a5 * b1;
    res.d[5] = a1 * b4 + a4 * b1 - a0 * b5 - a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between bivector and odd  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 18 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t cp(const bivector_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = a3 * b0 + a4 * b1 + a5 * b2;
    res.d[4] = a2 * b5 - a1 * b6 - a3 * b7;
    res.d[5] = a0 * b6 - a2 * b4 - a4 * b7;
    res.d[6] = a1 * b4 - a0 * b5 - a5 * b7;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between trivector and scalar  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const trivector_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between trivector and vector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₀₁₂₃
// 4 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t cp(const trivector_t& a, const vector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a0 * b0 - a1 * b1 - a2 * b2 - a3 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between trivector and bivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const trivector_t& a, const bivector_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a2 * b1 + a3 * b3 - a1 * b2;
    res.d[1] = a0 * b2 + a3 * b4 - a2 * b0;
    res.d[2] = a1 * b0 + a3 * b5 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between trivector and trivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const trivector_t& a, const trivector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b3 - a3 * b0;
    res.d[1] = a1 * b3 - a3 * b1;
    res.d[2] = a2 * b3 - a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between trivector and quadvector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 1 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t cp(const trivector_t& a, const quadvector_t& b) {
    vector_t res;
    const float a3 = a.d[3], b0 = b.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a3 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between trivector and horizon  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// 1 e₀
// -> r0 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t cp(const trivector_t& a, const horizon_t& b) {
    quadvector_t res;
    const float a3 = a.d[3];
    res.d[0] = -a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between trivector and origin  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// 1 e₁₂₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const trivector_t& a, const origin_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between trivector and point  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const trivector_t& a, const point_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 - a3 * b0;
    res.d[1] = a1 - a3 * b1;
    res.d[2] = a2 - a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between trivector and direction  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const trivector_t& a, const direction_t& b) {
    ibivector_t res;
    const float a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a3 * b0;
    res.d[1] = -a3 * b1;
    res.d[2] = -a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between trivector and ebivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const trivector_t& a, const ebivector_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between trivector and ibivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const trivector_t& a, const ibivector_t& b) {
    direction_t res;
    const float a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b0;
    res.d[1] = a3 * b1;
    res.d[2] = a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between trivector and evector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₀₁₂₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t cp(const trivector_t& a, const evector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between trivector and dpoint  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₀₁₂₃
// 3 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t cp(const trivector_t& a, const dpoint_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0 * b0 - a1 * b1 - a2 * b2 - a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between trivector and rotation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const trivector_t& a, const rotation_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 - a2 * b1;
    res.d[2] = a1 * b1 - a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between trivector and translation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const trivector_t& a, const translation_t& b) {
    direction_t res;
    const float a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b0;
    res.d[1] = a3 * b1;
    res.d[2] = a3 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between trivector and even  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 10 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t cp(const trivector_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a3 * b7;
    res.d[4] = a2 * b2 + a3 * b4 - a1 * b3;
    res.d[5] = a0 * b3 + a3 * b5 - a2 * b1;
    res.d[6] = a1 * b1 + a3 * b6 - a0 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between trivector and odd  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 10 muls / 7 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t cp(const trivector_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a0 * b7 - a3 * b4;
    res.d[5] = a1 * b7 - a3 * b5;
    res.d[6] = a2 * b7 - a3 * b6;
    res.d[7] = -a0 * b0 - a1 * b1 - a2 * b2 - a3 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between quadvector and scalar  
// a0 e₀₁₂₃
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const quadvector_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between quadvector and vector  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const quadvector_t& a, const vector_t& b) {
    direction_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0 * b0;
    res.d[1] = -a0 * b1;
    res.d[2] = -a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between quadvector and bivector  
// a0 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const quadvector_t& a, const bivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between quadvector and trivector  
// a0 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 1 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t cp(const quadvector_t& a, const trivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between quadvector and quadvector  
// a0 e₀₁₂₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const quadvector_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between quadvector and horizon  
// a0 e₀₁₂₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const quadvector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between quadvector and origin  
// a0 e₀₁₂₃
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t cp(const quadvector_t& a, const origin_t& b) {
    vector_t res;
    const float a0 = a.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between quadvector and point  
// a0 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t cp(const quadvector_t& a, const point_t& b) {
    vector_t res;
    const float a0 = a.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between quadvector and direction  
// a0 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const quadvector_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between quadvector and ebivector  
// a0 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const quadvector_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between quadvector and ibivector  
// a0 e₀₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const quadvector_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between quadvector and evector  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const quadvector_t& a, const evector_t& b) {
    direction_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0 * b0;
    res.d[1] = -a0 * b1;
    res.d[2] = -a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between quadvector and dpoint  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const quadvector_t& a, const dpoint_t& b) {
    direction_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0 * b0;
    res.d[1] = -a0 * b1;
    res.d[2] = -a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between quadvector and rotation  
// a0 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const quadvector_t& a, const rotation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between quadvector and translation  
// a0 e₀₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const quadvector_t& a, const translation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between quadvector and even  
// a0 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const quadvector_t& a, const even_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between quadvector and odd  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 4 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t cp(const quadvector_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b7 = b.d[7];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b7;
    res.d[4] = -a0 * b0;
    res.d[5] = -a0 * b1;
    res.d[6] = -a0 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between horizon and scalar  
// 1 e₀
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const horizon_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between horizon and vector  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const horizon_t& a, const vector_t& b) {
    ibivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between horizon and bivector  
// 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const horizon_t& a, const bivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between horizon and trivector  
// 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t cp(const horizon_t& a, const trivector_t& b) {
    quadvector_t res;
    const float b3 = b.d[3];
    res.d[0] = b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between horizon and quadvector  
// 1 e₀
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const horizon_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between horizon and horizon  
// 1 e₀
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const horizon_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between horizon and origin  
// 1 e₀
// 1 e₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t cp(const horizon_t& a, const origin_t& b) {
    quadvector_t res;
    res.d[0] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between horizon and point  
// 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t cp(const horizon_t& a, const point_t& b) {
    quadvector_t res;
    res.d[0] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between horizon and direction  
// 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const horizon_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between horizon and ebivector  
// 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const horizon_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between horizon and ibivector  
// 1 e₀
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const horizon_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between horizon and evector  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const horizon_t& a, const evector_t& b) {
    ibivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between horizon and dpoint  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const horizon_t& a, const dpoint_t& b) {
    ibivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between horizon and rotation  
// 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const horizon_t& a, const rotation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between horizon and translation  
// 1 e₀
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const horizon_t& a, const translation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between horizon and even  
// 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const horizon_t& a, const even_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between horizon and odd  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t cp(const horizon_t& a, const odd_t& b) {
    even_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b7 = b.d[7];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = b0;
    res.d[5] = b1;
    res.d[6] = b2;
    res.d[7] = b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between origin and scalar  
// 1 e₁₂₃
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const origin_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between origin and vector  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t cp(const origin_t& a, const vector_t& b) {
    quadvector_t res;
    const float b3 = b.d[3];
    res.d[0] = -b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between origin and bivector  
// 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const origin_t& a, const bivector_t& b) {
    direction_t res;
    const float b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = b3;
    res.d[1] = b4;
    res.d[2] = b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between origin and trivector  
// 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const origin_t& a, const trivector_t& b) {
    ibivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between origin and quadvector  
// 1 e₁₂₃
// b0 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t cp(const origin_t& a, const quadvector_t& b) {
    vector_t res;
    const float b0 = b.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between origin and horizon  
// 1 e₁₂₃
// 1 e₀
// -> r0 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t cp(const origin_t& a, const horizon_t& b) {
    quadvector_t res;
    res.d[0] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between origin and origin  
// 1 e₁₂₃
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const origin_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between origin and point  
// 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const origin_t& a, const point_t& b) {
    ibivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between origin and direction  
// 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const origin_t& a, const direction_t& b) {
    ibivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between origin and ebivector  
// 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const origin_t& a, const ebivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between origin and ibivector  
// 1 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const origin_t& a, const ibivector_t& b) {
    direction_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between origin and evector  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const origin_t& a, const evector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between origin and dpoint  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t cp(const origin_t& a, const dpoint_t& b) {
    quadvector_t res;
    res.d[0] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between origin and rotation  
// 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const origin_t& a, const rotation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between origin and translation  
// 1 e₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const origin_t& a, const translation_t& b) {
    direction_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between origin and even  
// 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t cp(const origin_t& a, const even_t& b) {
    odd_t res;
    const float b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b7;
    res.d[4] = b4;
    res.d[5] = b5;
    res.d[6] = b6;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between origin and odd  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t cp(const origin_t& a, const odd_t& b) {
    even_t res;
    const float b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = -b4;
    res.d[5] = -b5;
    res.d[6] = -b6;
    res.d[7] = -b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between point and scalar  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const point_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between point and vector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₀₁₂₃
// 3 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t cp(const point_t& a, const vector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -a0 * b0 - a1 * b1 - a2 * b2 - b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between point and bivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 6 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const point_t& a, const bivector_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a2 * b1 + b3 - a1 * b2;
    res.d[1] = a0 * b2 + b4 - a2 * b0;
    res.d[2] = a1 * b0 + b5 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between point and trivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const point_t& a, const trivector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b3 - b0;
    res.d[1] = a1 * b3 - b1;
    res.d[2] = a2 * b3 - b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between point and quadvector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t cp(const point_t& a, const quadvector_t& b) {
    vector_t res;
    const float b0 = b.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between point and horizon  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// 1 e₀
// -> r0 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t cp(const point_t& a, const horizon_t& b) {
    quadvector_t res;
    res.d[0] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between point and origin  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// 1 e₁₂₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const point_t& a, const origin_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between point and point  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const point_t& a, const point_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 - b0;
    res.d[1] = a1 - b1;
    res.d[2] = a2 - b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between point and direction  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const point_t& a, const direction_t& b) {
    ibivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between point and ebivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const point_t& a, const ebivector_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between point and ibivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const point_t& a, const ibivector_t& b) {
    direction_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between point and evector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₀₁₂₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t cp(const point_t& a, const evector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between point and dpoint  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₀₁₂₃
// 3 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t cp(const point_t& a, const dpoint_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -1 - a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between point and rotation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const point_t& a, const rotation_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 - a2 * b1;
    res.d[2] = a1 * b1 - a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between point and translation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const point_t& a, const translation_t& b) {
    direction_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between point and even  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t cp(const point_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = b7;
    res.d[4] = a2 * b2 + b4 - a1 * b3;
    res.d[5] = a0 * b3 + b5 - a2 * b1;
    res.d[6] = a1 * b1 + b6 - a0 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between point and odd  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 6 muls / 7 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t cp(const point_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a0 * b7 - b4;
    res.d[5] = a1 * b7 - b5;
    res.d[6] = a2 * b7 - b6;
    res.d[7] = -a0 * b0 - a1 * b1 - a2 * b2 - b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between direction and scalar  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const direction_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between direction and vector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₀₁₂₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t cp(const direction_t& a, const vector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between direction and bivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const direction_t& a, const bivector_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between direction and trivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const direction_t& a, const trivector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b3 = b.d[3];
    res.d[0] = a0 * b3;
    res.d[1] = a1 * b3;
    res.d[2] = a2 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between direction and quadvector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const direction_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between direction and horizon  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const direction_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between direction and origin  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// 1 e₁₂₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const direction_t& a, const origin_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between direction and point  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const direction_t& a, const point_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = a0;
    res.d[1] = a1;
    res.d[2] = a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between direction and direction  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const direction_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between direction and ebivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const direction_t& a, const ebivector_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between direction and ibivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const direction_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between direction and evector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₀₁₂₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t cp(const direction_t& a, const evector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between direction and dpoint  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₀₁₂₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t cp(const direction_t& a, const dpoint_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between direction and rotation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const direction_t& a, const rotation_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 - a2 * b1;
    res.d[2] = a1 * b1 - a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between direction and translation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const direction_t& a, const translation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between direction and even  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const direction_t& a, const even_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 - a2 * b1;
    res.d[2] = a1 * b1 - a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between direction and odd  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t cp(const direction_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b7 = b.d[7];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a0 * b7;
    res.d[5] = a1 * b7;
    res.d[6] = a2 * b7;
    res.d[7] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between ebivector and scalar  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const ebivector_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between ebivector and vector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t cp(const ebivector_t& a, const vector_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between ebivector and bivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 12 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t cp(const ebivector_t& a, const bivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = a2 * b4 - a1 * b5;
    res.d[4] = a0 * b5 - a2 * b3;
    res.d[5] = a1 * b3 - a0 * b4;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between ebivector and trivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const ebivector_t& a, const trivector_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between ebivector and quadvector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const ebivector_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between ebivector and horizon  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const ebivector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between ebivector and origin  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const ebivector_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between ebivector and point  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const ebivector_t& a, const point_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between ebivector and direction  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const ebivector_t& a, const direction_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between ebivector and ebivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t cp(const ebivector_t& a, const ebivector_t& b) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between ebivector and ibivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const ebivector_t& a, const ibivector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between ebivector and evector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t cp(const ebivector_t& a, const evector_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between ebivector and dpoint  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t cp(const ebivector_t& a, const dpoint_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between ebivector and rotation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t cp(const ebivector_t& a, const rotation_t& b) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 - a2 * b1;
    res.d[2] = a1 * b1 - a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between ebivector and translation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const ebivector_t& a, const translation_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between ebivector and even  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 12 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t cp(const ebivector_t& a, const even_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6];
    res.d[0] = a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 - a2 * b1;
    res.d[2] = a1 * b1 - a0 * b2;
    res.d[3] = a2 * b5 - a1 * b6;
    res.d[4] = a0 * b6 - a2 * b4;
    res.d[5] = a1 * b4 - a0 * b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between ebivector and odd  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t cp(const ebivector_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = 0.0;
    res.d[4] = a2 * b5 - a1 * b6;
    res.d[5] = a0 * b6 - a2 * b4;
    res.d[6] = a1 * b4 - a0 * b5;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between ibivector and scalar  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const ibivector_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between ibivector and vector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t cp(const ibivector_t& a, const vector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between ibivector and bivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const ibivector_t& a, const bivector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between ibivector and trivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const ibivector_t& a, const trivector_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b3 = b.d[3];
    res.d[0] = -a0 * b3;
    res.d[1] = -a1 * b3;
    res.d[2] = -a2 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between ibivector and quadvector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const ibivector_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between ibivector and horizon  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const ibivector_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between ibivector and origin  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const ibivector_t& a, const origin_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between ibivector and point  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const ibivector_t& a, const point_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between ibivector and direction  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const ibivector_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between ibivector and ebivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const ibivector_t& a, const ebivector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between ibivector and ibivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const ibivector_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between ibivector and evector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t cp(const ibivector_t& a, const evector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between ibivector and dpoint  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t cp(const ibivector_t& a, const dpoint_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between ibivector and rotation  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const ibivector_t& a, const rotation_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 - a2 * b1;
    res.d[2] = a1 * b1 - a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between ibivector and translation  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const ibivector_t& a, const translation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between ibivector and even  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const ibivector_t& a, const even_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 - a2 * b1;
    res.d[2] = a1 * b1 - a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between ibivector and odd  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t cp(const ibivector_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b7 = b.d[7];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[4] = -a0 * b7;
    res.d[5] = -a1 * b7;
    res.d[6] = -a2 * b7;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between evector and scalar  
// a0 e₁ + a1 e₂ + a2 e₃
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const evector_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between evector and vector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t cp(const evector_t& a, const vector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    res.d[3] = -a0 * b3;
    res.d[4] = -a1 * b3;
    res.d[5] = -a2 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between evector and bivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t cp(const evector_t& a, const bivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = -a0 * b3 - a1 * b4 - a2 * b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between evector and trivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₁₂₃
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t cp(const evector_t& a, const trivector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between evector and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const evector_t& a, const quadvector_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between evector and horizon  
// a0 e₁ + a1 e₂ + a2 e₃
// 1 e₀
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const evector_t& a, const horizon_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between evector and origin  
// a0 e₁ + a1 e₂ + a2 e₃
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const evector_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between evector and point  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₁₂₃
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t cp(const evector_t& a, const point_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between evector and direction  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₁₂₃
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t cp(const evector_t& a, const direction_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between evector and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t cp(const evector_t& a, const ebivector_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between evector and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t cp(const evector_t& a, const ibivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between evector and evector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t cp(const evector_t& a, const evector_t& b) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between evector and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 6 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t cp(const evector_t& a, const dpoint_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    res.d[3] = -a0;
    res.d[4] = -a1;
    res.d[5] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between evector and rotation  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t cp(const evector_t& a, const rotation_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 - a2 * b1;
    res.d[2] = a1 * b1 - a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between evector and translation  
// a0 e₁ + a1 e₂ + a2 e₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t cp(const evector_t& a, const translation_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between evector and even  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t cp(const evector_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 - a2 * b1;
    res.d[2] = a1 * b1 - a0 * b2;
    res.d[3] = -a0 * b4 - a1 * b5 - a2 * b6;
    res.d[4] = a0 * b7;
    res.d[5] = a1 * b7;
    res.d[6] = a2 * b7;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between evector and odd  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t cp(const evector_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6];
    res.d[0] = 0.0;
    res.d[1] = a1 * b2 - a2 * b1;
    res.d[2] = a2 * b0 - a0 * b2;
    res.d[3] = a0 * b1 - a1 * b0;
    res.d[4] = -a0 * b3;
    res.d[5] = -a1 * b3;
    res.d[6] = -a2 * b3;
    res.d[7] = a0 * b4 + a1 * b5 + a2 * b6;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between dpoint and scalar  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const dpoint_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between dpoint and vector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t cp(const dpoint_t& a, const vector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    res.d[3] = b0 - a0 * b3;
    res.d[4] = b1 - a1 * b3;
    res.d[5] = b2 - a2 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between dpoint and bivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t cp(const dpoint_t& a, const bivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = -a0 * b3 - a1 * b4 - a2 * b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between dpoint and trivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₁₂₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t cp(const dpoint_t& a, const trivector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2 + b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between dpoint and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const dpoint_t& a, const quadvector_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = a0 * b0;
    res.d[1] = a1 * b0;
    res.d[2] = a2 * b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between dpoint and horizon  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// 1 e₀
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const dpoint_t& a, const horizon_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between dpoint and origin  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// 1 e₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t cp(const dpoint_t& a, const origin_t& b) {
    quadvector_t res;
    res.d[0] = 1.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between dpoint and point  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₁₂₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t cp(const dpoint_t& a, const point_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 1 + a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between dpoint and direction  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₁₂₃
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t cp(const dpoint_t& a, const direction_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between dpoint and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t cp(const dpoint_t& a, const ebivector_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between dpoint and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t cp(const dpoint_t& a, const ibivector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between dpoint and evector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t cp(const dpoint_t& a, const evector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    res.d[3] = b0;
    res.d[4] = b1;
    res.d[5] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between dpoint and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 6 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t cp(const dpoint_t& a, const dpoint_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a1 * b2 - a2 * b1;
    res.d[1] = a2 * b0 - a0 * b2;
    res.d[2] = a0 * b1 - a1 * b0;
    res.d[3] = b0 - a0;
    res.d[4] = b1 - a1;
    res.d[5] = b2 - a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between dpoint and rotation  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t cp(const dpoint_t& a, const rotation_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 - a2 * b1;
    res.d[2] = a1 * b1 - a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between dpoint and translation  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t cp(const dpoint_t& a, const translation_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between dpoint and even  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t cp(const dpoint_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 - a2 * b1;
    res.d[2] = a1 * b1 - a0 * b2;
    res.d[3] = -a0 * b4 - a1 * b5 - a2 * b6;
    res.d[4] = a0 * b7;
    res.d[5] = a1 * b7;
    res.d[6] = a2 * b7;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between dpoint and odd  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t cp(const dpoint_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = 0.0;
    res.d[1] = a1 * b2 - a2 * b1;
    res.d[2] = a2 * b0 - a0 * b2;
    res.d[3] = a0 * b1 - a1 * b0;
    res.d[4] = b0 - a0 * b3;
    res.d[5] = b1 - a1 * b3;
    res.d[6] = b2 - a2 * b3;
    res.d[7] = a0 * b4 + a1 * b5 + a2 * b6 + b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between rotation and scalar  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const rotation_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between rotation and vector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t cp(const rotation_t& a, const vector_t& b) {
    evector_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b1 - a2 * b2;
    res.d[1] = a1 * b2 - a3 * b0;
    res.d[2] = a2 * b0 - a1 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between rotation and bivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 12 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t cp(const rotation_t& a, const bivector_t& b) {
    bivector_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a3 * b1 - a2 * b2;
    res.d[1] = a1 * b2 - a3 * b0;
    res.d[2] = a2 * b0 - a1 * b1;
    res.d[3] = a3 * b4 - a2 * b5;
    res.d[4] = a1 * b5 - a3 * b3;
    res.d[5] = a2 * b3 - a1 * b4;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between rotation and trivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const rotation_t& a, const trivector_t& b) {
    direction_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b1 - a2 * b2;
    res.d[1] = a1 * b2 - a3 * b0;
    res.d[2] = a2 * b0 - a1 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between rotation and quadvector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const rotation_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between rotation and horizon  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const rotation_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between rotation and origin  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// 1 e₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const rotation_t& a, const origin_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between rotation and point  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const rotation_t& a, const point_t& b) {
    direction_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b1 - a2 * b2;
    res.d[1] = a1 * b2 - a3 * b0;
    res.d[2] = a2 * b0 - a1 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between rotation and direction  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const rotation_t& a, const direction_t& b) {
    direction_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b1 - a2 * b2;
    res.d[1] = a1 * b2 - a3 * b0;
    res.d[2] = a2 * b0 - a1 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between rotation and ebivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t cp(const rotation_t& a, const ebivector_t& b) {
    ebivector_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b1 - a2 * b2;
    res.d[1] = a1 * b2 - a3 * b0;
    res.d[2] = a2 * b0 - a1 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between rotation and ibivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const rotation_t& a, const ibivector_t& b) {
    ibivector_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b1 - a2 * b2;
    res.d[1] = a1 * b2 - a3 * b0;
    res.d[2] = a2 * b0 - a1 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between rotation and evector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t cp(const rotation_t& a, const evector_t& b) {
    evector_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b1 - a2 * b2;
    res.d[1] = a1 * b2 - a3 * b0;
    res.d[2] = a2 * b0 - a1 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between rotation and dpoint  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t cp(const rotation_t& a, const dpoint_t& b) {
    evector_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b1 - a2 * b2;
    res.d[1] = a1 * b2 - a3 * b0;
    res.d[2] = a2 * b0 - a1 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between rotation and rotation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t cp(const rotation_t& a, const rotation_t& b) {
    ebivector_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a3 * b2 - a2 * b3;
    res.d[1] = a1 * b3 - a3 * b1;
    res.d[2] = a2 * b1 - a1 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between rotation and translation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const rotation_t& a, const translation_t& b) {
    ibivector_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b1 - a2 * b2;
    res.d[1] = a1 * b2 - a3 * b0;
    res.d[2] = a2 * b0 - a1 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between rotation and even  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 12 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t cp(const rotation_t& a, const even_t& b) {
    bivector_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6];
    res.d[0] = a3 * b2 - a2 * b3;
    res.d[1] = a1 * b3 - a3 * b1;
    res.d[2] = a2 * b1 - a1 * b2;
    res.d[3] = a3 * b5 - a2 * b6;
    res.d[4] = a1 * b6 - a3 * b4;
    res.d[5] = a2 * b4 - a1 * b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between rotation and odd  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t cp(const rotation_t& a, const odd_t& b) {
    odd_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6];
    res.d[0] = a3 * b1 - a2 * b2;
    res.d[1] = a1 * b2 - a3 * b0;
    res.d[2] = a2 * b0 - a1 * b1;
    res.d[3] = 0.0;
    res.d[4] = a3 * b5 - a2 * b6;
    res.d[5] = a1 * b6 - a3 * b4;
    res.d[6] = a2 * b4 - a1 * b5;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between translation and scalar  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const translation_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between translation and vector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t cp(const translation_t& a, const vector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between translation and bivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const translation_t& a, const bivector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between translation and trivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const translation_t& a, const trivector_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b3 = b.d[3];
    res.d[0] = -a0 * b3;
    res.d[1] = -a1 * b3;
    res.d[2] = -a2 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between translation and quadvector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const translation_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between translation and horizon  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const translation_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between translation and origin  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const translation_t& a, const origin_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between translation and point  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const translation_t& a, const point_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between translation and direction  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const translation_t& a, const direction_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between translation and ebivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const translation_t& a, const ebivector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between translation and ibivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const translation_t& a, const ibivector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between translation and evector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t cp(const translation_t& a, const evector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between translation and dpoint  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 3 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t cp(const translation_t& a, const dpoint_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between translation and rotation  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const translation_t& a, const rotation_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 - a2 * b1;
    res.d[2] = a1 * b1 - a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between translation and translation  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const translation_t& a, const translation_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between translation and even  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const translation_t& a, const even_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 - a2 * b1;
    res.d[2] = a1 * b1 - a0 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between translation and odd  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t cp(const translation_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b7 = b.d[7];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a0 * b0 + a1 * b1 + a2 * b2;
    res.d[4] = -a0 * b7;
    res.d[5] = -a1 * b7;
    res.d[6] = -a2 * b7;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between even and scalar  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const even_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between even and vector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t cp(const even_t& a, const vector_t& b) {
    odd_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b1 - a2 * b2;
    res.d[1] = a1 * b2 - a3 * b0;
    res.d[2] = a2 * b0 - a1 * b1;
    res.d[3] = a4 * b0 + a5 * b1 + a6 * b2;
    res.d[4] = -a7 * b0;
    res.d[5] = -a7 * b1;
    res.d[6] = -a7 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between even and bivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 18 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t cp(const even_t& a, const bivector_t& b) {
    bivector_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a3 * b1 - a2 * b2;
    res.d[1] = a1 * b2 - a3 * b0;
    res.d[2] = a2 * b0 - a1 * b1;
    res.d[3] = a3 * b4 + a6 * b1 - a2 * b5 - a5 * b2;
    res.d[4] = a1 * b5 + a4 * b2 - a3 * b3 - a6 * b0;
    res.d[5] = a2 * b3 + a5 * b0 - a1 * b4 - a4 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between even and trivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 10 muls / 7 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t cp(const even_t& a, const trivector_t& b) {
    odd_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a7 * b3;
    res.d[4] = a3 * b1 - a2 * b2 - a4 * b3;
    res.d[5] = a1 * b2 - a3 * b0 - a5 * b3;
    res.d[6] = a2 * b0 - a1 * b1 - a6 * b3;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between even and quadvector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const even_t& a, const quadvector_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between even and horizon  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const even_t& a, const horizon_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between even and origin  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t cp(const even_t& a, const origin_t& b) {
    odd_t res;
    const float a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a7;
    res.d[4] = -a4;
    res.d[5] = -a5;
    res.d[6] = -a6;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between even and point  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 7 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t cp(const even_t& a, const point_t& b) {
    odd_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a7;
    res.d[4] = a3 * b1 - a2 * b2 - a4;
    res.d[5] = a1 * b2 - a3 * b0 - a5;
    res.d[6] = a2 * b0 - a1 * b1 - a6;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between even and direction  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t cp(const even_t& a, const direction_t& b) {
    direction_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b1 - a2 * b2;
    res.d[1] = a1 * b2 - a3 * b0;
    res.d[2] = a2 * b0 - a1 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between even and ebivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 12 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t cp(const even_t& a, const ebivector_t& b) {
    bivector_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b1 - a2 * b2;
    res.d[1] = a1 * b2 - a3 * b0;
    res.d[2] = a2 * b0 - a1 * b1;
    res.d[3] = a6 * b1 - a5 * b2;
    res.d[4] = a4 * b2 - a6 * b0;
    res.d[5] = a5 * b0 - a4 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between even and ibivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const even_t& a, const ibivector_t& b) {
    ibivector_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b1 - a2 * b2;
    res.d[1] = a1 * b2 - a3 * b0;
    res.d[2] = a2 * b0 - a1 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between even and evector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t cp(const even_t& a, const evector_t& b) {
    odd_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b1 - a2 * b2;
    res.d[1] = a1 * b2 - a3 * b0;
    res.d[2] = a2 * b0 - a1 * b1;
    res.d[3] = a4 * b0 + a5 * b1 + a6 * b2;
    res.d[4] = -a7 * b0;
    res.d[5] = -a7 * b1;
    res.d[6] = -a7 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between even and dpoint  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t cp(const even_t& a, const dpoint_t& b) {
    odd_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b1 - a2 * b2;
    res.d[1] = a1 * b2 - a3 * b0;
    res.d[2] = a2 * b0 - a1 * b1;
    res.d[3] = a4 * b0 + a5 * b1 + a6 * b2;
    res.d[4] = -a7 * b0;
    res.d[5] = -a7 * b1;
    res.d[6] = -a7 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between even and rotation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 12 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t cp(const even_t& a, const rotation_t& b) {
    bivector_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a3 * b2 - a2 * b3;
    res.d[1] = a1 * b3 - a3 * b1;
    res.d[2] = a2 * b1 - a1 * b2;
    res.d[3] = a6 * b2 - a5 * b3;
    res.d[4] = a4 * b3 - a6 * b1;
    res.d[5] = a5 * b1 - a4 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between even and translation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t cp(const even_t& a, const translation_t& b) {
    ibivector_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a3 * b1 - a2 * b2;
    res.d[1] = a1 * b2 - a3 * b0;
    res.d[2] = a2 * b0 - a1 * b1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between even and even  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 18 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t cp(const even_t& a, const even_t& b) {
    bivector_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6];
    res.d[0] = a3 * b2 - a2 * b3;
    res.d[1] = a1 * b3 - a3 * b1;
    res.d[2] = a2 * b1 - a1 * b2;
    res.d[3] = a3 * b5 + a6 * b2 - a2 * b6 - a5 * b3;
    res.d[4] = a1 * b6 + a4 * b3 - a3 * b4 - a6 * b1;
    res.d[5] = a2 * b4 + a5 * b1 - a1 * b5 - a4 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between even and odd  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 22 muls / 15 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t cp(const even_t& a, const odd_t& b) {
    odd_t res;
    const float a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a3 * b1 - a2 * b2;
    res.d[1] = a1 * b2 - a3 * b0;
    res.d[2] = a2 * b0 - a1 * b1;
    res.d[3] = a4 * b0 + a5 * b1 + a6 * b2 - a7 * b7;
    res.d[4] = a3 * b5 - a2 * b6 - a4 * b7 - a7 * b0;
    res.d[5] = a1 * b6 - a3 * b4 - a5 * b7 - a7 * b1;
    res.d[6] = a2 * b4 - a1 * b5 - a6 * b7 - a7 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between odd and scalar  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t cp(const odd_t& a, const scalar_t& b) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// cp between odd and vector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 16 muls / 10 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t cp(const odd_t& a, const vector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = a1 * b2 - a2 * b1;
    res.d[2] = a2 * b0 - a0 * b2;
    res.d[3] = a0 * b1 - a1 * b0;
    res.d[4] = a3 * b0 - a0 * b3;
    res.d[5] = a3 * b1 - a1 * b3;
    res.d[6] = a3 * b2 - a2 * b3;
    res.d[7] = -a4 * b0 - a5 * b1 - a6 * b2 - a7 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between odd and bivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 18 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t cp(const odd_t& a, const bivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = -a0 * b3 - a1 * b4 - a2 * b5;
    res.d[4] = a6 * b1 + a7 * b3 - a5 * b2;
    res.d[5] = a4 * b2 + a7 * b4 - a6 * b0;
    res.d[6] = a5 * b0 + a7 * b5 - a4 * b1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between odd and trivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 10 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t cp(const odd_t& a, const trivector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a4 * b3 - a7 * b0;
    res.d[5] = a5 * b3 - a7 * b1;
    res.d[6] = a6 * b3 - a7 * b2;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between odd and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 4 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t cp(const odd_t& a, const quadvector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a7 = a.d[7], b0 = b.d[0];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = a7 * b0;
    res.d[4] = a0 * b0;
    res.d[5] = a1 * b0;
    res.d[6] = a2 * b0;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between odd and horizon  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// 1 e₀
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t cp(const odd_t& a, const horizon_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a7 = a.d[7];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = -a0;
    res.d[5] = -a1;
    res.d[6] = -a2;
    res.d[7] = -a7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between odd and origin  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// 1 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t cp(const odd_t& a, const origin_t& b) {
    even_t res;
    const float a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a4;
    res.d[5] = a5;
    res.d[6] = a6;
    res.d[7] = a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between odd and point  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 6 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t cp(const odd_t& a, const point_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = a4 - a7 * b0;
    res.d[5] = a5 - a7 * b1;
    res.d[6] = a6 - a7 * b2;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2 + a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between odd and direction  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 6 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t cp(const odd_t& a, const direction_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = -a7 * b0;
    res.d[5] = -a7 * b1;
    res.d[6] = -a7 * b2;
    res.d[7] = a0 * b0 + a1 * b1 + a2 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between odd and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t cp(const odd_t& a, const ebivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = a2 * b1 - a1 * b2;
    res.d[1] = a0 * b2 - a2 * b0;
    res.d[2] = a1 * b0 - a0 * b1;
    res.d[3] = 0.0;
    res.d[4] = a6 * b1 - a5 * b2;
    res.d[5] = a4 * b2 - a6 * b0;
    res.d[6] = a5 * b0 - a4 * b1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between odd and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t cp(const odd_t& a, const ibivector_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    res.d[4] = a7 * b0;
    res.d[5] = a7 * b1;
    res.d[6] = a7 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between odd and evector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t cp(const odd_t& a, const evector_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = a1 * b2 - a2 * b1;
    res.d[2] = a2 * b0 - a0 * b2;
    res.d[3] = a0 * b1 - a1 * b0;
    res.d[4] = a3 * b0;
    res.d[5] = a3 * b1;
    res.d[6] = a3 * b2;
    res.d[7] = -a4 * b0 - a5 * b1 - a6 * b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between odd and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 10 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t cp(const odd_t& a, const dpoint_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = a1 * b2 - a2 * b1;
    res.d[2] = a2 * b0 - a0 * b2;
    res.d[3] = a0 * b1 - a1 * b0;
    res.d[4] = a3 * b0 - a0;
    res.d[5] = a3 * b1 - a1;
    res.d[6] = a3 * b2 - a2;
    res.d[7] = -a4 * b0 - a5 * b1 - a6 * b2 - a7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between odd and rotation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 12 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t cp(const odd_t& a, const rotation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 - a2 * b1;
    res.d[2] = a1 * b1 - a0 * b2;
    res.d[3] = 0.0;
    res.d[4] = a6 * b2 - a5 * b3;
    res.d[5] = a4 * b3 - a6 * b1;
    res.d[6] = a5 * b1 - a4 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between odd and translation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t cp(const odd_t& a, const translation_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -a0 * b0 - a1 * b1 - a2 * b2;
    res.d[4] = a7 * b0;
    res.d[5] = a7 * b1;
    res.d[6] = a7 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between odd and even  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 22 muls / 15 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t cp(const odd_t& a, const even_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = a2 * b2 - a1 * b3;
    res.d[1] = a0 * b3 - a2 * b1;
    res.d[2] = a1 * b1 - a0 * b2;
    res.d[3] = a7 * b7 - a0 * b4 - a1 * b5 - a2 * b6;
    res.d[4] = a0 * b7 + a6 * b2 + a7 * b4 - a5 * b3;
    res.d[5] = a1 * b7 + a4 * b3 + a7 * b5 - a6 * b1;
    res.d[6] = a2 * b7 + a5 * b1 + a7 * b6 - a4 * b2;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// cp between odd and odd  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 26 muls / 19 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t cp(const odd_t& a, const odd_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = 0.0;
    res.d[1] = a1 * b2 - a2 * b1;
    res.d[2] = a2 * b0 - a0 * b2;
    res.d[3] = a0 * b1 - a1 * b0;
    res.d[4] = a3 * b0 + a4 * b7 - a0 * b3 - a7 * b4;
    res.d[5] = a3 * b1 + a5 * b7 - a1 * b3 - a7 * b5;
    res.d[6] = a3 * b2 + a6 * b7 - a2 * b3 - a7 * b6;
    res.d[7] = a0 * b4 + a1 * b5 + a2 * b6 + a3 * b7 - a4 * b0 - a5 * b1 - a6 * b2 - a7 * b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between scalar and vector  
// a
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator>>(const scalar_t& a, const vector_t& b) {
    vector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between scalar and bivector  
// a
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator>>(const scalar_t& a, const bivector_t& b) {
    bivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    res.d[4] = b4;
    res.d[5] = b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between scalar and trivector  
// a
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator>>(const scalar_t& a, const trivector_t& b) {
    trivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between scalar and quadvector  
// a
// b0 e₀₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator>>(const scalar_t& a, const quadvector_t& b) {
    quadvector_t res;
    const float b0 = b.d[0];
    res.d[0] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between scalar and horizon  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline horizon_t operator>>(const scalar_t& a, const horizon_t& b) {

    return horizon_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// sw between scalar and origin  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline origin_t operator>>(const scalar_t& a, const origin_t& b) {

    return origin_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// sw between scalar and point  
// a
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t operator>>(const scalar_t& a, const point_t& b) {
    point_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between scalar and direction  
// a
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator>>(const scalar_t& a, const direction_t& b) {
    direction_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between scalar and ebivector  
// a
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator>>(const scalar_t& a, const ebivector_t& b) {
    ebivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between scalar and ibivector  
// a
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator>>(const scalar_t& a, const ibivector_t& b) {
    ibivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between scalar and evector  
// a
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator>>(const scalar_t& a, const evector_t& b) {
    evector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between scalar and dpoint  
// a
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + 1 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline dpoint_t operator>>(const scalar_t& a, const dpoint_t& b) {
    dpoint_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between scalar and rotation  
// a
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator>>(const scalar_t& a, const rotation_t& b) {
    rotation_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between scalar and translation  
// a
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline translation_t operator>>(const scalar_t& a, const translation_t& b) {
    translation_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between scalar and even  
// a
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator>>(const scalar_t& a, const even_t& b) {
    even_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    res.d[4] = b4;
    res.d[5] = b5;
    res.d[6] = b6;
    res.d[7] = b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between scalar and odd  
// a
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator>>(const scalar_t& a, const odd_t& b) {
    odd_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    res.d[4] = b4;
    res.d[5] = b5;
    res.d[6] = b6;
    res.d[7] = b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between vector and scalar  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator>>(const vector_t& a, const scalar_t& b) {

    return b;

}

////////////////////////////////////////////////////////////////////////////////  
// sw between vector and vector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 11 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator>>(const vector_t& a, const vector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 + 2.0 * (a0 * t1);
    res.d[1] = b1 + 2.0 * (a1 * t1);
    res.d[2] = b2 + 2.0 * (a2 * t1);
    res.d[3] = b3 + 2.0 * (a3 * t1);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between vector and bivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 39 muls / 24 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator>>(const vector_t& a, const bivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5],
        a2a2 = a2 * a2, a1b2 = a1 * b2, a2b1 = a2 * b1, a2b0 = a2 * b0, a1b4 = a1 * b4,
        a2b5 = a2 * b5, a3b0 = a3 * b0,
        s0 = a1b2 - a2b1,
        t0 = a1b4 + a2b5;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2) - b0 * (a1 * a1 + a2a2));
    res.d[1] = b1 + 2.0 * (a2 * s0 + a0 * (a1 * b0 - a0 * b1));
    res.d[2] = b2 + 2.0 * (a0 * (a2b0 - a0 * b2) - a1 * s0);
    res.d[3] = b3 + 2.0 * (a3 * s0 - a0 * (a0 * b3 + t0));
    res.d[4] = b4 + 2.0 * (a2b0 * a3 - a1 * t0 - a0 * (a1 * b3 + a3 * b2));
    res.d[5] = b5 + 2.0 * (a0 * (a3 * b1 - a2 * b3) - a2a2 * b5 - a1 * (a2 * b4 + a3b0));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between vector and trivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 25 muls / 16 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator>>(const vector_t& a, const trivector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a1a1 = a1 * a1, a2a2 = a2 * a2, a2b2 = a2 * b2, a3b3 = a3 * b3, a2b1 = a2 * b1,
        t0 = a1a1 + a2a2, t1 = a2b2 + a3b3;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + t1) - b0 * t0);
    res.d[1] = b1 + 2.0 * (a1 * t1 + a0 * (a1 * b0 - a0 * b1) - a2a2 * b1);
    res.d[2] = b2 + 2.0 * (a2 * a3b3 + a1 * (a2b1 - a1 * b2) + a0 * (a2 * b0 - a0 * b2));
    res.d[3] = b3 + 2.0 * (b3 * (a0 * a0 + t0));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between vector and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₁₂₃
// -> r0 e₀₁₂₃
// 5 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator>>(const vector_t& a, const quadvector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = b0 + 2.0 * (b0 * (a0 * a0 + a1 * a1 + a2 * a2));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between vector and horizon  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline horizon_t operator>>(const vector_t& a, const horizon_t& b) {

    return horizon_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// sw between vector and origin  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 10 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator>>(const vector_t& a, const origin_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = 2 * a0 * a3;
    res.d[1] = 2 * a1 * a3;
    res.d[2] = 2 * a2 * a3;
    res.d[3] = 1 + 2.0 * (a0 * a0 + a1 * a1 + a2 * a2);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between vector and point  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 23 muls / 16 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator>>(const vector_t& a, const point_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1a1 = a1 * a1, a2a2 = a2 * a2, a2b2 = a2 * b2, a2b1 = a2 * b1,
        t0 = a1a1 + a2a2, t1 = a2b2 + a3;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + t1) - b0 * t0);
    res.d[1] = b1 + 2.0 * (a1 * t1 + a0 * (a1 * b0 - a0 * b1) - a2a2 * b1);
    res.d[2] = b2 + 2.0 * (a2 * a3 + a1 * (a2b1 - a1 * b2) + a0 * (a2 * b0 - a0 * b2));
    res.d[3] = 1 + 2.0 * (a0 * a0 + t0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between vector and direction  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 19 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator>>(const vector_t& a, const direction_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a2b1 = a2 * b1,
        t0 = a1b2 - a2b1;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2) - b0 * (a1 * a1 + a2 * a2));
    res.d[1] = b1 + 2.0 * (a2 * t0 + a0 * (a1 * b0 - a0 * b1));
    res.d[2] = b2 + 2.0 * (a0 * (a2 * b0 - a0 * b2) - a1 * t0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between vector and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 25 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator>>(const vector_t& a, const ebivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a2b1 = a2 * b1, a0b1 = a0 * b1, a1b0 = a1 * b0, a0b2 = a0 * b2,
        a2b0 = a2 * b0,
        t0 = a1b2 - a2b1, t1 = a0b1 - a1b0, t2 = a0b2 - a2b0;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2) - b0 * (a1 * a1 + a2 * a2));
    res.d[1] = b1 + 2.0 * (a2 * t0 - a0 * t1);
    res.d[2] = b2 - 2 * (a1 * t0 + a0 * t2);
    res.d[3] = 2.0 * (a3 * t0);
    res.d[4] = 2.0 * (-a3 * t2);
    res.d[5] = 2.0 * (a3 * t1);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between vector and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator>>(const vector_t& a, const ibivector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 + 2.0 * (a0 * t1);
    res.d[1] = b1 + 2.0 * (a1 * t1);
    res.d[2] = b2 + 2.0 * (a2 * t1);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between vector and evector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 11 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator>>(const vector_t& a, const evector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 + 2.0 * (a0 * t1);
    res.d[1] = b1 + 2.0 * (a1 * t1);
    res.d[2] = b2 + 2.0 * (a2 * t1);
    res.d[3] = 2.0 * (a3 * t1);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between vector and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 11 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator>>(const vector_t& a, const dpoint_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 + 2.0 * (a0 * t1);
    res.d[1] = b1 + 2.0 * (a1 * t1);
    res.d[2] = b2 + 2.0 * (a2 * t1);
    res.d[3] = 1 + 2.0 * (a3 * t1);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between vector and rotation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 25 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator>>(const vector_t& a, const rotation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a1b3 = a1 * b3, a2b2 = a2 * b2, a0b2 = a0 * b2, a1b1 = a1 * b1, a0b3 = a0 * b3,
        a2b1 = a2 * b1,
        t0 = a1b3 - a2b2, t1 = a0b2 - a1b1, t2 = a0b3 - a2b1;
    res.d[0] = b0;
    res.d[1] = b1 + 2.0 * (a0 * (a1 * b2 + a2 * b3) - b1 * (a1 * a1 + a2 * a2));
    res.d[2] = b2 + 2.0 * (a2 * t0 - a0 * t1);
    res.d[3] = b3 - 2 * (a1 * t0 + a0 * t2);
    res.d[4] = 2.0 * (a3 * t0);
    res.d[5] = 2.0 * (-a3 * t2);
    res.d[6] = 2.0 * (a3 * t1);
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between vector and translation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline translation_t operator>>(const vector_t& a, const translation_t& b) {
    translation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 + 2.0 * (a0 * t1);
    res.d[1] = b1 + 2.0 * (a1 * t1);
    res.d[2] = b2 + 2.0 * (a2 * t1);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between vector and even  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 42 muls / 26 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator>>(const vector_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a1a1 = a1 * a1, a2a2 = a2 * a2, a1b3 = a1 * b3, a2b2 = a2 * b2, a2b1 = a2 * b1,
        a1b5 = a1 * b5, a2b6 = a2 * b6, a3b1 = a3 * b1,
        s0 = a1b3 - a2b2,
        t0 = a1a1 + a2a2, t1 = a1b5 + a2b6;
    res.d[0] = b0;
    res.d[1] = b1 + 2.0 * (a0 * (a1 * b2 + a2 * b3) - b1 * t0);
    res.d[2] = b2 + 2.0 * (a2 * s0 + a0 * (a1 * b1 - a0 * b2));
    res.d[3] = b3 + 2.0 * (a0 * (a2b1 - a0 * b3) - a1 * s0);
    res.d[4] = b4 + 2.0 * (a3 * s0 - a0 * (a0 * b4 + t1));
    res.d[5] = b5 + 2.0 * (a2b1 * a3 - a1 * t1 - a0 * (a1 * b4 + a3 * b3));
    res.d[6] = b6 + 2.0 * (a0 * (a3 * b2 - a2 * b4) - a2a2 * b6 - a1 * (a2 * b5 + a3b1));
    res.d[7] = b7 + 2.0 * (b7 * (a0 * a0 + t0));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between vector and odd  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 36 muls / 22 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator>>(const vector_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2, a1a1 = a1 * a1, a2a2 = a2 * a2,
        a2b6 = a2 * b6, a3b7 = a3 * b7, a2b5 = a2 * b5,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2, t2 = a1a1 + a2a2, t3 = a2b6 + a3b7;
    res.d[0] = b0 + 2.0 * (a0 * t1);
    res.d[1] = b1 + 2.0 * (a1 * t1);
    res.d[2] = b2 + 2.0 * (a2 * t1);
    res.d[3] = b3 + 2.0 * (a3 * t1);
    res.d[4] = b4 + 2.0 * (a0 * (a1 * b5 + t3) - b4 * t2);
    res.d[5] = b5 + 2.0 * (a1 * t3 + a0 * (a1 * b4 - a0 * b5) - a2a2 * b5);
    res.d[6] = b6 + 2.0 * (a2 * a3b7 + a1 * (a2b5 - a1 * b6) + a0 * (a2 * b4 - a0 * b6));
    res.d[7] = b7 + 2.0 * (b7 * (a0 * a0 + t2));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between bivector and scalar  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 5 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator>>(const bivector_t& a, const scalar_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5];
    res.d[0] = b;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = 2.0 * (b * (a0 * a3 + a1 * a4 + a2 * a5));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between bivector and vector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 29 muls / 17 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator>>(const bivector_t& a, const vector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a1b2 = a1 * b2, a2b1 = a2 * b1,
        t0 = a1b2 - a2b1;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2) - b0 * (a1 * a1 + a2 * a2));
    res.d[1] = b1 + 2.0 * (a2 * t0 + a0 * (a1 * b0 - a0 * b1));
    res.d[2] = b2 + 2.0 * (a0 * (a2 * b0 - a0 * b2) - a1 * t0);
    res.d[3] = b3 + 2.0 * (a2 * (a3 * b1 - a4 * b0) + a1 * (a5 * b0 - a3 * b2) + a0 * (a4 * b2 - a5 * b1));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between bivector and bivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 48 muls / 37 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator>>(const bivector_t& a, const bivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5],
        a1b2 = a1 * b2, a2b1 = a2 * b1, a2b3 = a2 * b3, a3b2 = a3 * b2, a5b0 = a5 * b0,
        a1b3 = a1 * b3, a3b1 = a3 * b1, a4b0 = a4 * b0, a2b5 = a2 * b5, a3b0 = a3 * b0,
        a4b1 = a4 * b1, a5b2 = a5 * b2, a2b4 = a2 * b4, a4b2 = a4 * b2, a5b1 = a5 * b1,
        t0 = a3b0 + a4b1, t1 = t0 + a5b2, t2 = a1b2 - a2b1, t3 = a2b3 - a3b2, t4 = t3 + a5b0, t5 = a1b3 - a3b1;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2) - b0 * (a1 * a1 + a2 * a2));
    res.d[1] = b1 + 2.0 * (a2 * t2 + a0 * (a1 * b0 - a0 * b1));
    res.d[2] = b2 + 2.0 * (a0 * (a2 * b0 - a0 * b2) - a1 * t2);
    res.d[3] = b3 + 2.0 * (a0 * (a1 * b4 + a2b5 + t1) - a2 * t4 - a1 * (t5 + a4b0));
    res.d[4] = b4 + 2.0 * (a2 * (a4b2 - a2b4 - a5b1) + a1 * (a2b5 + t1) + a0 * (t5 + a4b0 - a0 * b4));
    res.d[5] = b5 + 2.0 * (a2 * t1 + a1 * (a2b4 + a5b1 - a1 * b5 - a4b2) + a0 * (t4 - a0 * b5));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between bivector and trivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 21 muls / 14 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator>>(const bivector_t& a, const trivector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a2b0 = a2 * b0, a4b3 = a4 * b3, a1b0 = a1 * b0, a5b3 = a5 * b3, a1b2 = a1 * b2,
        a2b1 = a2 * b1, a3b3 = a3 * b3,
        t0 = a2b0 + a4b3, t1 = a1b0 - a5b3, t2 = a1b2 - a2b1, t3 = t2 + a3b3;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2) - a2 * t0 - a1 * t1);
    res.d[1] = b1 + 2.0 * (a2 * t3 + a0 * (t1 - a0 * b1));
    res.d[2] = b2 + 2.0 * (a0 * (t0 - a0 * b2) - a1 * t3);
    res.d[3] = b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between bivector and quadvector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator>>(const bivector_t& a, const quadvector_t& b) {
    quadvector_t res;
    const float b0 = b.d[0];
    res.d[0] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between bivector and horizon  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline horizon_t operator>>(const bivector_t& a, const horizon_t& b) {

    return horizon_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// sw between bivector and origin  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 9 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t operator>>(const bivector_t& a, const origin_t& b) {
    point_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5];
    res.d[0] = 2.0 * (a1 * a5 - a2 * a4);
    res.d[1] = 2.0 * (a2 * a3 - a0 * a5);
    res.d[2] = 2.0 * (a0 * a4 - a1 * a3);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between bivector and point  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 18 muls / 14 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t operator>>(const bivector_t& a, const point_t& b) {
    point_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a2b0 = a2 * b0, a1b0 = a1 * b0, a1b2 = a1 * b2, a2b1 = a2 * b1,
        t0 = a2b0 + a4, t1 = a1b0 - a5, t2 = a1b2 - a2b1, t3 = t2 + a3;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2) - a2 * t0 - a1 * t1);
    res.d[1] = b1 + 2.0 * (a2 * t3 + a0 * (t1 - a0 * b1));
    res.d[2] = b2 + 2.0 * (a0 * (t0 - a0 * b2) - a1 * t3);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between bivector and direction  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 19 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator>>(const bivector_t& a, const direction_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a2b1 = a2 * b1,
        t0 = a1b2 - a2b1;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2) - b0 * (a1 * a1 + a2 * a2));
    res.d[1] = b1 + 2.0 * (a2 * t0 + a0 * (a1 * b0 - a0 * b1));
    res.d[2] = b2 + 2.0 * (a0 * (a2 * b0 - a0 * b2) - a1 * t0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between bivector and ebivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 40 muls / 22 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator>>(const bivector_t& a, const ebivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a2b1 = a2 * b1, a3b2 = a3 * b2, a5b0 = a5 * b0, a3b1 = a3 * b1,
        a4b0 = a4 * b0, a3b0 = a3 * b0, a4b1 = a4 * b1, a5b2 = a5 * b2, a4b2 = a4 * b2,
        a5b1 = a5 * b1,
        t0 = a3b0 + a4b1, t1 = t0 + a5b2, t2 = a1b2 - a2b1, t3 = a3b2 - a5b0, t4 = a3b1 - a4b0, t5 = a4b2 - a5b1;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2) - b0 * (a1 * a1 + a2 * a2));
    res.d[1] = b1 + 2.0 * (a2 * t2 + a0 * (a1 * b0 - a0 * b1));
    res.d[2] = b2 + 2.0 * (a0 * (a2 * b0 - a0 * b2) - a1 * t2);
    res.d[3] = 2.0 * (a2 * t3 + a1 * t4 + a0 * t1);
    res.d[4] = 2.0 * (a2 * t5 + a1 * t1 - a0 * t4);
    res.d[5] = 2.0 * (a2 * t1 - a1 * t5 - a0 * t3);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between bivector and ibivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 19 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator>>(const bivector_t& a, const ibivector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a2b1 = a2 * b1,
        t0 = a1b2 - a2b1;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2) - b0 * (a1 * a1 + a2 * a2));
    res.d[1] = b1 + 2.0 * (a2 * t0 + a0 * (a1 * b0 - a0 * b1));
    res.d[2] = b2 + 2.0 * (a0 * (a2 * b0 - a0 * b2) - a1 * t0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between bivector and evector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 29 muls / 16 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator>>(const bivector_t& a, const evector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a2b1 = a2 * b1,
        t0 = a1b2 - a2b1;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2) - b0 * (a1 * a1 + a2 * a2));
    res.d[1] = b1 + 2.0 * (a2 * t0 + a0 * (a1 * b0 - a0 * b1));
    res.d[2] = b2 + 2.0 * (a0 * (a2 * b0 - a0 * b2) - a1 * t0);
    res.d[3] = 2.0 * (a2 * (a3 * b1 - a4 * b0) + a1 * (a5 * b0 - a3 * b2) + a0 * (a4 * b2 - a5 * b1));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between bivector and dpoint  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 29 muls / 17 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator>>(const bivector_t& a, const dpoint_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a2b1 = a2 * b1,
        t0 = a1b2 - a2b1;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2) - b0 * (a1 * a1 + a2 * a2));
    res.d[1] = b1 + 2.0 * (a2 * t0 + a0 * (a1 * b0 - a0 * b1));
    res.d[2] = b2 + 2.0 * (a0 * (a2 * b0 - a0 * b2) - a1 * t0);
    res.d[3] = 1 + 2.0 * (a2 * (a3 * b1 - a4 * b0) + a1 * (a5 * b0 - a3 * b2) + a0 * (a4 * b2 - a5 * b1));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between bivector and rotation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 45 muls / 24 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator>>(const bivector_t& a, const rotation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a1b3 = a1 * b3, a2b2 = a2 * b2, a3b3 = a3 * b3, a5b1 = a5 * b1, a3b2 = a3 * b2,
        a4b1 = a4 * b1, a3b1 = a3 * b1, a4b2 = a4 * b2, a5b3 = a5 * b3, a4b3 = a4 * b3,
        a5b2 = a5 * b2,
        t0 = a3b1 + a4b2, t1 = t0 + a5b3, t2 = a1b3 - a2b2, t3 = a3b3 - a5b1, t4 = a3b2 - a4b1, t5 = a4b3 - a5b2;
    res.d[0] = b0;
    res.d[1] = b1 + 2.0 * (a0 * (a1 * b2 + a2 * b3) - b1 * (a1 * a1 + a2 * a2));
    res.d[2] = b2 + 2.0 * (a2 * t2 + a0 * (a1 * b1 - a0 * b2));
    res.d[3] = b3 + 2.0 * (a0 * (a2 * b1 - a0 * b3) - a1 * t2);
    res.d[4] = 2.0 * (a2 * t3 + a1 * t4 + a0 * t1);
    res.d[5] = 2.0 * (a2 * t5 + a1 * t1 - a0 * t4);
    res.d[6] = 2.0 * (a2 * t1 - a1 * t5 - a0 * t3);
    res.d[7] = 2.0 * (b0 * (a0 * a3 + a1 * a4 + a2 * a5));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between bivector and translation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 23 muls / 13 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator>>(const bivector_t& a, const translation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a2b1 = a2 * b1,
        t0 = a1b2 - a2b1;
    res.d[0] = 1.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2) - b0 * (a1 * a1 + a2 * a2));
    res.d[5] = b1 + 2.0 * (a2 * t0 + a0 * (a1 * b0 - a0 * b1));
    res.d[6] = b2 + 2.0 * (a0 * (a2 * b0 - a0 * b2) - a1 * t0);
    res.d[7] = 2.0 * (a0 * a3 + a1 * a4 + a2 * a5);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between bivector and even  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 53 muls / 40 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator>>(const bivector_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a1b3 = a1 * b3, a2b2 = a2 * b2, a2b4 = a2 * b4, a3b3 = a3 * b3, a5b1 = a5 * b1,
        a1b4 = a1 * b4, a3b2 = a3 * b2, a4b1 = a4 * b1, a2b6 = a2 * b6, a3b1 = a3 * b1,
        a4b2 = a4 * b2, a5b3 = a5 * b3, a2b5 = a2 * b5, a4b3 = a4 * b3, a5b2 = a5 * b2,
        t0 = a3b1 + a4b2, t1 = t0 + a5b3, t2 = a1b3 - a2b2, t3 = a2b4 - a3b3, t4 = t3 + a5b1, t5 = a1b4 - a3b2;
    res.d[0] = b0;
    res.d[1] = b1 + 2.0 * (a0 * (a1 * b2 + a2 * b3) - b1 * (a1 * a1 + a2 * a2));
    res.d[2] = b2 + 2.0 * (a2 * t2 + a0 * (a1 * b1 - a0 * b2));
    res.d[3] = b3 + 2.0 * (a0 * (a2 * b1 - a0 * b3) - a1 * t2);
    res.d[4] = b4 + 2.0 * (a0 * (a1 * b5 + a2b6 + t1) - a2 * t4 - a1 * (t5 + a4b1));
    res.d[5] = b5 + 2.0 * (a2 * (a4b3 - a2b5 - a5b2) + a1 * (a2b6 + t1) + a0 * (t5 + a4b1 - a0 * b5));
    res.d[6] = b6 + 2.0 * (a2 * t1 + a1 * (a2b5 + a5b2 - a1 * b6 - a4b3) + a0 * (t4 - a0 * b6));
    res.d[7] = b7 + 2.0 * (b0 * (a0 * a3 + a1 * a4 + a2 * a5));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between bivector and odd  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 50 muls / 31 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator>>(const bivector_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a1b2 = a1 * b2, a2b1 = a2 * b1, a2b4 = a2 * b4, a4b7 = a4 * b7, a1b4 = a1 * b4,
        a5b7 = a5 * b7, a1b6 = a1 * b6, a2b5 = a2 * b5, a3b7 = a3 * b7,
        t0 = a1b2 - a2b1, t1 = a2b4 + a4b7, t2 = a1b4 - a5b7, t3 = a1b6 - a2b5, t4 = t3 + a3b7;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2) - b0 * (a1 * a1 + a2 * a2));
    res.d[1] = b1 + 2.0 * (a2 * t0 + a0 * (a1 * b0 - a0 * b1));
    res.d[2] = b2 + 2.0 * (a0 * (a2 * b0 - a0 * b2) - a1 * t0);
    res.d[3] = b3 + 2.0 * (a2 * (a3 * b1 - a4 * b0) + a1 * (a5 * b0 - a3 * b2) + a0 * (a4 * b2 - a5 * b1));
    res.d[4] = b4 + 2.0 * (a0 * (a1 * b5 + a2 * b6) - a2 * t1 - a1 * t2);
    res.d[5] = b5 + 2.0 * (a2 * t4 + a0 * (t2 - a0 * b5));
    res.d[6] = b6 + 2.0 * (a0 * (t1 - a0 * b6) - a1 * t4);
    res.d[7] = b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between trivector and scalar  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator>>(const trivector_t& a, const scalar_t& b) {

    return b;

}

////////////////////////////////////////////////////////////////////////////////  
// sw between trivector and vector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 10 muls / 7 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator>>(const trivector_t& a, const vector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a3a3 = a3 * a3,
        t0 = 2 * a3a3 - 1;
    res.d[0] = -b0 * t0;
    res.d[1] = -b1 * t0;
    res.d[2] = -b2 * t0;
    res.d[3] = b3 + 2.0 * (a3 * (a0 * b0 + a1 * b1 + a2 * b2));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between trivector and bivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 15 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator>>(const trivector_t& a, const bivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3 + 2.0 * (a3 * (a1 * b2 - a2 * b1 - a3 * b3));
    res.d[4] = b4 + 2.0 * (a3 * (a2 * b0 - a0 * b2 - a3 * b4));
    res.d[5] = b5 + 2.0 * (a3 * (a0 * b1 - a1 * b0 - a3 * b5));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between trivector and trivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 10 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator>>(const trivector_t& a, const trivector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a3b3 = a3 * b3;
    res.d[0] = b0 - 2 * a0 * a3b3;
    res.d[1] = b1 - 2 * a1 * a3b3;
    res.d[2] = b2 - 2 * a2 * a3b3;
    res.d[3] = b3 * (1 - 2 * a3 * a3);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between trivector and quadvector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₁₂₃
// -> r0 e₀₁₂₃
// 3 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator>>(const trivector_t& a, const quadvector_t& b) {
    quadvector_t res;
    const float a3 = a.d[3], b0 = b.d[0];
    res.d[0] = b0 * (1 - 2 * a3 * a3);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between trivector and horizon  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline horizon_t operator>>(const trivector_t& a, const horizon_t& b) {

    return horizon_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// sw between trivector and origin  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 8 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator>>(const trivector_t& a, const origin_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = -2 * a0 * a3;
    res.d[1] = -2 * a1 * a3;
    res.d[2] = -2 * a2 * a3;
    res.d[3] = 1 - 2 * a3 * a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between trivector and point  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 8 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator>>(const trivector_t& a, const point_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0 - 2 * a0 * a3;
    res.d[1] = b1 - 2 * a1 * a3;
    res.d[2] = b2 - 2 * a2 * a3;
    res.d[3] = 1 - 2 * a3 * a3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between trivector and direction  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator>>(const trivector_t& a, const direction_t& b) {
    direction_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between trivector and ebivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 12 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator>>(const trivector_t& a, const ebivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = 2.0 * (a3 * (a1 * b2 - a2 * b1));
    res.d[4] = 2.0 * (a3 * (a2 * b0 - a0 * b2));
    res.d[5] = 2.0 * (a3 * (a0 * b1 - a1 * b0));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between trivector and ibivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 5 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator>>(const trivector_t& a, const ibivector_t& b) {
    ibivector_t res;
    const float a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a3a3 = a3 * a3,
        t0 = 2 * a3a3 - 1;
    res.d[0] = -b0 * t0;
    res.d[1] = -b1 * t0;
    res.d[2] = -b2 * t0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between trivector and evector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 10 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator>>(const trivector_t& a, const evector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a3a3 = a3 * a3,
        t0 = 2 * a3a3 - 1;
    res.d[0] = -b0 * t0;
    res.d[1] = -b1 * t0;
    res.d[2] = -b2 * t0;
    res.d[3] = 2.0 * (a3 * (a0 * b0 + a1 * b1 + a2 * b2));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between trivector and dpoint  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 10 muls / 7 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator>>(const trivector_t& a, const dpoint_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a3a3 = a3 * a3,
        t0 = 2 * a3a3 - 1;
    res.d[0] = -b0 * t0;
    res.d[1] = -b1 * t0;
    res.d[2] = -b2 * t0;
    res.d[3] = 1 + 2.0 * (a3 * (a0 * b0 + a1 * b1 + a2 * b2));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between trivector and rotation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 12 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator>>(const trivector_t& a, const rotation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    res.d[4] = 2.0 * (a3 * (a1 * b3 - a2 * b2));
    res.d[5] = 2.0 * (a3 * (a2 * b1 - a0 * b3));
    res.d[6] = 2.0 * (a3 * (a0 * b2 - a1 * b1));
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between trivector and translation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 5 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline translation_t operator>>(const trivector_t& a, const translation_t& b) {
    translation_t res;
    const float a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a3a3 = a3 * a3,
        t0 = 2 * a3a3 - 1;
    res.d[0] = -b0 * t0;
    res.d[1] = -b1 * t0;
    res.d[2] = -b2 * t0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between trivector and even  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 18 muls / 10 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator>>(const trivector_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    res.d[4] = b4 + 2.0 * (a3 * (a1 * b3 - a2 * b2 - a3 * b4));
    res.d[5] = b5 + 2.0 * (a3 * (a2 * b1 - a0 * b3 - a3 * b5));
    res.d[6] = b6 + 2.0 * (a3 * (a0 * b2 - a1 * b1 - a3 * b6));
    res.d[7] = b7 * (1 - 2 * a3 * a3);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between trivector and odd  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 18 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator>>(const trivector_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a3a3 = a3 * a3, a3b7 = a3 * b7,
        t0 = 2 * a3a3 - 1;
    res.d[0] = -b0 * t0;
    res.d[1] = -b1 * t0;
    res.d[2] = -b2 * t0;
    res.d[3] = b3 + 2.0 * (a3 * (a0 * b0 + a1 * b1 + a2 * b2));
    res.d[4] = b4 - 2 * a0 * a3b7;
    res.d[5] = b5 - 2 * a1 * a3b7;
    res.d[6] = b6 - 2 * a2 * a3b7;
    res.d[7] = -b7 * t0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between quadvector and scalar  
// a0 e₀₁₂₃
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator>>(const quadvector_t& a, const scalar_t& b) {

    return b;

}

////////////////////////////////////////////////////////////////////////////////  
// sw between quadvector and vector  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator>>(const quadvector_t& a, const vector_t& b) {
    vector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between quadvector and bivector  
// a0 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator>>(const quadvector_t& a, const bivector_t& b) {
    bivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    res.d[4] = b4;
    res.d[5] = b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between quadvector and trivector  
// a0 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator>>(const quadvector_t& a, const trivector_t& b) {
    trivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between quadvector and quadvector  
// a0 e₀₁₂₃
// b0 e₀₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator>>(const quadvector_t& a, const quadvector_t& b) {
    quadvector_t res;
    const float b0 = b.d[0];
    res.d[0] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between quadvector and horizon  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline horizon_t operator>>(const quadvector_t& a, const horizon_t& b) {

    return horizon_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// sw between quadvector and origin  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline origin_t operator>>(const quadvector_t& a, const origin_t& b) {

    return origin_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// sw between quadvector and point  
// a0 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t operator>>(const quadvector_t& a, const point_t& b) {
    point_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between quadvector and direction  
// a0 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator>>(const quadvector_t& a, const direction_t& b) {
    direction_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between quadvector and ebivector  
// a0 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator>>(const quadvector_t& a, const ebivector_t& b) {
    ebivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between quadvector and ibivector  
// a0 e₀₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator>>(const quadvector_t& a, const ibivector_t& b) {
    ibivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between quadvector and evector  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator>>(const quadvector_t& a, const evector_t& b) {
    evector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between quadvector and dpoint  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + 1 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline dpoint_t operator>>(const quadvector_t& a, const dpoint_t& b) {
    dpoint_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between quadvector and rotation  
// a0 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator>>(const quadvector_t& a, const rotation_t& b) {
    rotation_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between quadvector and translation  
// a0 e₀₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline translation_t operator>>(const quadvector_t& a, const translation_t& b) {
    translation_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between quadvector and even  
// a0 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator>>(const quadvector_t& a, const even_t& b) {
    even_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    res.d[4] = b4;
    res.d[5] = b5;
    res.d[6] = b6;
    res.d[7] = b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between quadvector and odd  
// a0 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator>>(const quadvector_t& a, const odd_t& b) {
    odd_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    res.d[4] = b4;
    res.d[5] = b5;
    res.d[6] = b6;
    res.d[7] = b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between horizon and scalar  
// 1 e₀
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator>>(const horizon_t& a, const scalar_t& b) {

    return b;

}

////////////////////////////////////////////////////////////////////////////////  
// sw between horizon and vector  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator>>(const horizon_t& a, const vector_t& b) {
    vector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between horizon and bivector  
// 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator>>(const horizon_t& a, const bivector_t& b) {
    bivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    res.d[4] = b4;
    res.d[5] = b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between horizon and trivector  
// 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator>>(const horizon_t& a, const trivector_t& b) {
    trivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between horizon and quadvector  
// 1 e₀
// b0 e₀₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator>>(const horizon_t& a, const quadvector_t& b) {
    quadvector_t res;
    const float b0 = b.d[0];
    res.d[0] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between horizon and horizon  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline horizon_t operator>>(const horizon_t& a, const horizon_t& b) {

    return horizon_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// sw between horizon and origin  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline origin_t operator>>(const horizon_t& a, const origin_t& b) {

    return origin_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// sw between horizon and point  
// 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t operator>>(const horizon_t& a, const point_t& b) {
    point_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between horizon and direction  
// 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator>>(const horizon_t& a, const direction_t& b) {
    direction_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between horizon and ebivector  
// 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator>>(const horizon_t& a, const ebivector_t& b) {
    ebivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between horizon and ibivector  
// 1 e₀
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator>>(const horizon_t& a, const ibivector_t& b) {
    ibivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between horizon and evector  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator>>(const horizon_t& a, const evector_t& b) {
    evector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between horizon and dpoint  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + 1 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline dpoint_t operator>>(const horizon_t& a, const dpoint_t& b) {
    dpoint_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between horizon and rotation  
// 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator>>(const horizon_t& a, const rotation_t& b) {
    rotation_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between horizon and translation  
// 1 e₀
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline translation_t operator>>(const horizon_t& a, const translation_t& b) {
    translation_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between horizon and even  
// 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator>>(const horizon_t& a, const even_t& b) {
    even_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    res.d[4] = b4;
    res.d[5] = b5;
    res.d[6] = b6;
    res.d[7] = b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between horizon and odd  
// 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator>>(const horizon_t& a, const odd_t& b) {
    odd_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    res.d[4] = b4;
    res.d[5] = b5;
    res.d[6] = b6;
    res.d[7] = b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between origin and scalar  
// 1 e₁₂₃
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator>>(const origin_t& a, const scalar_t& b) {

    return b;

}

////////////////////////////////////////////////////////////////////////////////  
// sw between origin and vector  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator>>(const origin_t& a, const vector_t& b) {
    vector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    res.d[3] = b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between origin and bivector  
// 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator>>(const origin_t& a, const bivector_t& b) {
    bivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = -b3;
    res.d[4] = -b4;
    res.d[5] = -b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between origin and trivector  
// 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator>>(const origin_t& a, const trivector_t& b) {
    trivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = -b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between origin and quadvector  
// 1 e₁₂₃
// b0 e₀₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator>>(const origin_t& a, const quadvector_t& b) {
    quadvector_t res;
    const float b0 = b.d[0];
    res.d[0] = -b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between origin and horizon  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline horizon_t operator>>(const origin_t& a, const horizon_t& b) {

    return horizon_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// sw between origin and origin  
// 1 e₁₂₃
// 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator>>(const origin_t& a, const origin_t& b) {
    trivector_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between origin and point  
// 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator>>(const origin_t& a, const point_t& b) {
    trivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between origin and direction  
// 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator>>(const origin_t& a, const direction_t& b) {
    direction_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between origin and ebivector  
// 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator>>(const origin_t& a, const ebivector_t& b) {
    ebivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between origin and ibivector  
// 1 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator>>(const origin_t& a, const ibivector_t& b) {
    ibivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between origin and evector  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator>>(const origin_t& a, const evector_t& b) {
    evector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between origin and dpoint  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + 1 e₀
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline dpoint_t operator>>(const origin_t& a, const dpoint_t& b) {
    dpoint_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between origin and rotation  
// 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator>>(const origin_t& a, const rotation_t& b) {
    rotation_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between origin and translation  
// 1 e₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline translation_t operator>>(const origin_t& a, const translation_t& b) {
    translation_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between origin and even  
// 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator>>(const origin_t& a, const even_t& b) {
    even_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    res.d[4] = -b4;
    res.d[5] = -b5;
    res.d[6] = -b6;
    res.d[7] = -b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between origin and odd  
// 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator>>(const origin_t& a, const odd_t& b) {
    odd_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    res.d[3] = b3;
    res.d[4] = b4;
    res.d[5] = b5;
    res.d[6] = b6;
    res.d[7] = -b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between point and scalar  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator>>(const point_t& a, const scalar_t& b) {

    return b;

}

////////////////////////////////////////////////////////////////////////////////  
// sw between point and vector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 4 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator>>(const point_t& a, const vector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    res.d[3] = b3 + 2.0 * (a0 * b0 + a1 * b1 + a2 * b2);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between point and bivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator>>(const point_t& a, const bivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = 2.0 * (a1 * b2 - a2 * b1) - b3;
    res.d[4] = 2.0 * (a2 * b0 - a0 * b2) - b4;
    res.d[5] = 2.0 * (a0 * b1 - a1 * b0) - b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between point and trivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 6 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator>>(const point_t& a, const trivector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0 - 2 * a0 * b3;
    res.d[1] = b1 - 2 * a1 * b3;
    res.d[2] = b2 - 2 * a2 * b3;
    res.d[3] = -b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between point and quadvector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator>>(const point_t& a, const quadvector_t& b) {
    quadvector_t res;
    const float b0 = b.d[0];
    res.d[0] = -b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between point and horizon  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline horizon_t operator>>(const point_t& a, const horizon_t& b) {

    return horizon_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// sw between point and origin  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 3 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator>>(const point_t& a, const origin_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -2 * a0;
    res.d[1] = -2 * a1;
    res.d[2] = -2 * a2;
    res.d[3] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between point and point  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 3 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator>>(const point_t& a, const point_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0 - 2 * a0;
    res.d[1] = b1 - 2 * a1;
    res.d[2] = b2 - 2 * a2;
    res.d[3] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between point and direction  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator>>(const point_t& a, const direction_t& b) {
    direction_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between point and ebivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 9 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator>>(const point_t& a, const ebivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = 2.0 * (a1 * b2 - a2 * b1);
    res.d[4] = 2.0 * (a2 * b0 - a0 * b2);
    res.d[5] = 2.0 * (a0 * b1 - a1 * b0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between point and ibivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator>>(const point_t& a, const ibivector_t& b) {
    ibivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between point and evector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 4 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator>>(const point_t& a, const evector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    res.d[3] = 2.0 * (a0 * b0 + a1 * b1 + a2 * b2);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between point and dpoint  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 4 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator>>(const point_t& a, const dpoint_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    res.d[3] = 1 + 2.0 * (a0 * b0 + a1 * b1 + a2 * b2);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between point and rotation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator>>(const point_t& a, const rotation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    res.d[4] = 2.0 * (a1 * b3 - a2 * b2);
    res.d[5] = 2.0 * (a2 * b1 - a0 * b3);
    res.d[6] = 2.0 * (a0 * b2 - a1 * b1);
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between point and translation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline translation_t operator>>(const point_t& a, const translation_t& b) {
    translation_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between point and even  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 7 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator>>(const point_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    res.d[4] = 2.0 * (a1 * b3 - a2 * b2) - b4;
    res.d[5] = 2.0 * (a2 * b1 - a0 * b3) - b5;
    res.d[6] = 2.0 * (a0 * b2 - a1 * b1) - b6;
    res.d[7] = -b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between point and odd  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 10 muls / 10 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator>>(const point_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = -b0;
    res.d[1] = -b1;
    res.d[2] = -b2;
    res.d[3] = b3 + 2.0 * (a0 * b0 + a1 * b1 + a2 * b2);
    res.d[4] = b4 - 2 * a0 * b7;
    res.d[5] = b5 - 2 * a1 * b7;
    res.d[6] = b6 - 2 * a2 * b7;
    res.d[7] = -b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between direction and scalar  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator>>(const direction_t& a, const scalar_t& b) {

    return b;

}

////////////////////////////////////////////////////////////////////////////////  
// sw between direction and vector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator>>(const direction_t& a, const vector_t& b) {
    vector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between direction and bivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator>>(const direction_t& a, const bivector_t& b) {
    bivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    res.d[4] = b4;
    res.d[5] = b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between direction and trivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator>>(const direction_t& a, const trivector_t& b) {
    trivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between direction and quadvector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator>>(const direction_t& a, const quadvector_t& b) {
    quadvector_t res;
    const float b0 = b.d[0];
    res.d[0] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between direction and horizon  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline horizon_t operator>>(const direction_t& a, const horizon_t& b) {

    return horizon_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// sw between direction and origin  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline origin_t operator>>(const direction_t& a, const origin_t& b) {

    return origin_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// sw between direction and point  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t operator>>(const direction_t& a, const point_t& b) {
    point_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between direction and direction  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator>>(const direction_t& a, const direction_t& b) {
    direction_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between direction and ebivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator>>(const direction_t& a, const ebivector_t& b) {
    ebivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between direction and ibivector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator>>(const direction_t& a, const ibivector_t& b) {
    ibivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between direction and evector  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator>>(const direction_t& a, const evector_t& b) {
    evector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between direction and dpoint  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + 1 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline dpoint_t operator>>(const direction_t& a, const dpoint_t& b) {
    dpoint_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between direction and rotation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator>>(const direction_t& a, const rotation_t& b) {
    rotation_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between direction and translation  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline translation_t operator>>(const direction_t& a, const translation_t& b) {
    translation_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between direction and even  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator>>(const direction_t& a, const even_t& b) {
    even_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    res.d[4] = b4;
    res.d[5] = b5;
    res.d[6] = b6;
    res.d[7] = b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between direction and odd  
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator>>(const direction_t& a, const odd_t& b) {
    odd_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    res.d[4] = b4;
    res.d[5] = b5;
    res.d[6] = b6;
    res.d[7] = b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between ebivector and scalar  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator>>(const ebivector_t& a, const scalar_t& b) {

    return b;

}

////////////////////////////////////////////////////////////////////////////////  
// sw between ebivector and vector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 19 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator>>(const ebivector_t& a, const vector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a1b2 = a1 * b2, a2b1 = a2 * b1,
        t0 = a1b2 - a2b1;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2) - b0 * (a1 * a1 + a2 * a2));
    res.d[1] = b1 + 2.0 * (a2 * t0 + a0 * (a1 * b0 - a0 * b1));
    res.d[2] = b2 + 2.0 * (a0 * (a2 * b0 - a0 * b2) - a1 * t0);
    res.d[3] = b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between ebivector and bivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 36 muls / 21 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator>>(const ebivector_t& a, const bivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5],
        a1a1 = a1 * a1, a2a2 = a2 * a2, a1b2 = a1 * b2, a2b1 = a2 * b1, a1b5 = a1 * b5,
        a2b4 = a2 * b4,
        s0 = a1a1 + a2a2,
        t0 = a1b2 - a2b1, t1 = a1b5 - a2b4;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2) - b0 * s0);
    res.d[1] = b1 + 2.0 * (a2 * t0 + a0 * (a1 * b0 - a0 * b1));
    res.d[2] = b2 + 2.0 * (a0 * (a2 * b0 - a0 * b2) - a1 * t0);
    res.d[3] = b3 + 2.0 * (a0 * (a1 * b4 + a2 * b5) - b3 * s0);
    res.d[4] = b4 + 2.0 * (a2 * t1 + a0 * (a1 * b3 - a0 * b4));
    res.d[5] = b5 + 2.0 * (a0 * (a2 * b3 - a0 * b5) - a1 * t1);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between ebivector and trivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 19 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator>>(const ebivector_t& a, const trivector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a1b2 = a1 * b2, a2b1 = a2 * b1,
        t0 = a1b2 - a2b1;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2) - b0 * (a1 * a1 + a2 * a2));
    res.d[1] = b1 + 2.0 * (a2 * t0 + a0 * (a1 * b0 - a0 * b1));
    res.d[2] = b2 + 2.0 * (a0 * (a2 * b0 - a0 * b2) - a1 * t0);
    res.d[3] = b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between ebivector and quadvector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator>>(const ebivector_t& a, const quadvector_t& b) {
    quadvector_t res;
    const float b0 = b.d[0];
    res.d[0] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between ebivector and horizon  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline horizon_t operator>>(const ebivector_t& a, const horizon_t& b) {

    return horizon_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// sw between ebivector and origin  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline origin_t operator>>(const ebivector_t& a, const origin_t& b) {

    return origin_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// sw between ebivector and point  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 19 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t operator>>(const ebivector_t& a, const point_t& b) {
    point_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a2b1 = a2 * b1,
        t0 = a1b2 - a2b1;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2) - b0 * (a1 * a1 + a2 * a2));
    res.d[1] = b1 + 2.0 * (a2 * t0 + a0 * (a1 * b0 - a0 * b1));
    res.d[2] = b2 + 2.0 * (a0 * (a2 * b0 - a0 * b2) - a1 * t0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between ebivector and direction  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 19 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator>>(const ebivector_t& a, const direction_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a2b1 = a2 * b1,
        t0 = a1b2 - a2b1;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2) - b0 * (a1 * a1 + a2 * a2));
    res.d[1] = b1 + 2.0 * (a2 * t0 + a0 * (a1 * b0 - a0 * b1));
    res.d[2] = b2 + 2.0 * (a0 * (a2 * b0 - a0 * b2) - a1 * t0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between ebivector and ebivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 19 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator>>(const ebivector_t& a, const ebivector_t& b) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a2b1 = a2 * b1,
        t0 = a1b2 - a2b1;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2) - b0 * (a1 * a1 + a2 * a2));
    res.d[1] = b1 + 2.0 * (a2 * t0 + a0 * (a1 * b0 - a0 * b1));
    res.d[2] = b2 + 2.0 * (a0 * (a2 * b0 - a0 * b2) - a1 * t0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between ebivector and ibivector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 19 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator>>(const ebivector_t& a, const ibivector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a2b1 = a2 * b1,
        t0 = a1b2 - a2b1;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2) - b0 * (a1 * a1 + a2 * a2));
    res.d[1] = b1 + 2.0 * (a2 * t0 + a0 * (a1 * b0 - a0 * b1));
    res.d[2] = b2 + 2.0 * (a0 * (a2 * b0 - a0 * b2) - a1 * t0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between ebivector and evector  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 19 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator>>(const ebivector_t& a, const evector_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a2b1 = a2 * b1,
        t0 = a1b2 - a2b1;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2) - b0 * (a1 * a1 + a2 * a2));
    res.d[1] = b1 + 2.0 * (a2 * t0 + a0 * (a1 * b0 - a0 * b1));
    res.d[2] = b2 + 2.0 * (a0 * (a2 * b0 - a0 * b2) - a1 * t0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between ebivector and dpoint  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + 1 e₀
// 19 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline dpoint_t operator>>(const ebivector_t& a, const dpoint_t& b) {
    dpoint_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a2b1 = a2 * b1,
        t0 = a1b2 - a2b1;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2) - b0 * (a1 * a1 + a2 * a2));
    res.d[1] = b1 + 2.0 * (a2 * t0 + a0 * (a1 * b0 - a0 * b1));
    res.d[2] = b2 + 2.0 * (a0 * (a2 * b0 - a0 * b2) - a1 * t0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between ebivector and rotation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 19 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator>>(const ebivector_t& a, const rotation_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a1b3 = a1 * b3, a2b2 = a2 * b2,
        t0 = a1b3 - a2b2;
    res.d[0] = b0;
    res.d[1] = b1 + 2.0 * (a0 * (a1 * b2 + a2 * b3) - b1 * (a1 * a1 + a2 * a2));
    res.d[2] = b2 + 2.0 * (a2 * t0 + a0 * (a1 * b1 - a0 * b2));
    res.d[3] = b3 + 2.0 * (a0 * (a2 * b1 - a0 * b3) - a1 * t0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between ebivector and translation  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 19 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline translation_t operator>>(const ebivector_t& a, const translation_t& b) {
    translation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a2b1 = a2 * b1,
        t0 = a1b2 - a2b1;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2) - b0 * (a1 * a1 + a2 * a2));
    res.d[1] = b1 + 2.0 * (a2 * t0 + a0 * (a1 * b0 - a0 * b1));
    res.d[2] = b2 + 2.0 * (a0 * (a2 * b0 - a0 * b2) - a1 * t0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between ebivector and even  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 36 muls / 21 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator>>(const ebivector_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a1a1 = a1 * a1, a2a2 = a2 * a2, a1b3 = a1 * b3, a2b2 = a2 * b2, a1b6 = a1 * b6,
        a2b5 = a2 * b5,
        s0 = a1a1 + a2a2,
        t0 = a1b3 - a2b2, t1 = a1b6 - a2b5;
    res.d[0] = b0;
    res.d[1] = b1 + 2.0 * (a0 * (a1 * b2 + a2 * b3) - b1 * s0);
    res.d[2] = b2 + 2.0 * (a2 * t0 + a0 * (a1 * b1 - a0 * b2));
    res.d[3] = b3 + 2.0 * (a0 * (a2 * b1 - a0 * b3) - a1 * t0);
    res.d[4] = b4 + 2.0 * (a0 * (a1 * b5 + a2 * b6) - b4 * s0);
    res.d[5] = b5 + 2.0 * (a2 * t1 + a0 * (a1 * b4 - a0 * b5));
    res.d[6] = b6 + 2.0 * (a0 * (a2 * b4 - a0 * b6) - a1 * t1);
    res.d[7] = b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between ebivector and odd  
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 36 muls / 21 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator>>(const ebivector_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a1a1 = a1 * a1, a2a2 = a2 * a2, a1b2 = a1 * b2, a2b1 = a2 * b1, a1b6 = a1 * b6,
        a2b5 = a2 * b5,
        s0 = a1a1 + a2a2,
        t0 = a1b2 - a2b1, t1 = a1b6 - a2b5;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2) - b0 * s0);
    res.d[1] = b1 + 2.0 * (a2 * t0 + a0 * (a1 * b0 - a0 * b1));
    res.d[2] = b2 + 2.0 * (a0 * (a2 * b0 - a0 * b2) - a1 * t0);
    res.d[3] = b3;
    res.d[4] = b4 + 2.0 * (a0 * (a1 * b5 + a2 * b6) - b4 * s0);
    res.d[5] = b5 + 2.0 * (a2 * t1 + a0 * (a1 * b4 - a0 * b5));
    res.d[6] = b6 + 2.0 * (a0 * (a2 * b4 - a0 * b6) - a1 * t1);
    res.d[7] = b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between ibivector and scalar  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator>>(const ibivector_t& a, const scalar_t& b) {

    return b;

}

////////////////////////////////////////////////////////////////////////////////  
// sw between ibivector and vector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator>>(const ibivector_t& a, const vector_t& b) {
    vector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between ibivector and bivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator>>(const ibivector_t& a, const bivector_t& b) {
    bivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    res.d[4] = b4;
    res.d[5] = b5;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between ibivector and trivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator>>(const ibivector_t& a, const trivector_t& b) {
    trivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between ibivector and quadvector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator>>(const ibivector_t& a, const quadvector_t& b) {
    quadvector_t res;
    const float b0 = b.d[0];
    res.d[0] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between ibivector and horizon  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline horizon_t operator>>(const ibivector_t& a, const horizon_t& b) {

    return horizon_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// sw between ibivector and origin  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline origin_t operator>>(const ibivector_t& a, const origin_t& b) {

    return origin_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// sw between ibivector and point  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t operator>>(const ibivector_t& a, const point_t& b) {
    point_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between ibivector and direction  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator>>(const ibivector_t& a, const direction_t& b) {
    direction_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between ibivector and ebivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator>>(const ibivector_t& a, const ebivector_t& b) {
    ebivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between ibivector and ibivector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator>>(const ibivector_t& a, const ibivector_t& b) {
    ibivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between ibivector and evector  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator>>(const ibivector_t& a, const evector_t& b) {
    evector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between ibivector and dpoint  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + 1 e₀
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline dpoint_t operator>>(const ibivector_t& a, const dpoint_t& b) {
    dpoint_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between ibivector and rotation  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator>>(const ibivector_t& a, const rotation_t& b) {
    rotation_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between ibivector and translation  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline translation_t operator>>(const ibivector_t& a, const translation_t& b) {
    translation_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between ibivector and even  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator>>(const ibivector_t& a, const even_t& b) {
    even_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    res.d[4] = b4;
    res.d[5] = b5;
    res.d[6] = b6;
    res.d[7] = b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between ibivector and odd  
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator>>(const ibivector_t& a, const odd_t& b) {
    odd_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    res.d[4] = b4;
    res.d[5] = b5;
    res.d[6] = b6;
    res.d[7] = b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between evector and scalar  
// a0 e₁ + a1 e₂ + a2 e₃
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator>>(const evector_t& a, const scalar_t& b) {

    return b;

}

////////////////////////////////////////////////////////////////////////////////  
// sw between evector and vector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator>>(const evector_t& a, const vector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 + 2.0 * (a0 * t1);
    res.d[1] = b1 + 2.0 * (a1 * t1);
    res.d[2] = b2 + 2.0 * (a2 * t1);
    res.d[3] = b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between evector and bivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 28 muls / 16 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator>>(const evector_t& a, const bivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5],
        a1b2 = a1 * b2, a2b1 = a2 * b1, a0b3 = a0 * b3, a1b4 = a1 * b4, a2b5 = a2 * b5,
        t0 = a0b3 + a1b4, t1 = t0 + a2b5, t2 = a1b2 - a2b1;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2) - b0 * (a1 * a1 + a2 * a2));
    res.d[1] = b1 + 2.0 * (a2 * t2 + a0 * (a1 * b0 - a0 * b1));
    res.d[2] = b2 + 2.0 * (a0 * (a2 * b0 - a0 * b2) - a1 * t2);
    res.d[3] = b3 + 2.0 * (a0 * t1);
    res.d[4] = b4 + 2.0 * (a1 * t1);
    res.d[5] = b5 + 2.0 * (a2 * t1);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between evector and trivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 22 muls / 13 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator>>(const evector_t& a, const trivector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a1a1 = a1 * a1, a2a2 = a2 * a2, a1b2 = a1 * b2, a2b1 = a2 * b1,
        t0 = a1a1 + a2a2, t1 = a1b2 - a2b1;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2) - b0 * t0);
    res.d[1] = b1 + 2.0 * (a2 * t1 + a0 * (a1 * b0 - a0 * b1));
    res.d[2] = b2 + 2.0 * (a0 * (a2 * b0 - a0 * b2) - a1 * t1);
    res.d[3] = b3 + 2.0 * (b3 * (a0 * a0 + t0));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between evector and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₁₂₃
// -> r0 e₀₁₂₃
// 5 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator>>(const evector_t& a, const quadvector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = b0 + 2.0 * (b0 * (a0 * a0 + a1 * a1 + a2 * a2));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between evector and horizon  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline horizon_t operator>>(const evector_t& a, const horizon_t& b) {

    return horizon_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// sw between evector and origin  
// a0 e₁ + a1 e₂ + a2 e₃
// 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 4 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator>>(const evector_t& a, const origin_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 1 + 2.0 * (a0 * a0 + a1 * a1 + a2 * a2);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between evector and point  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 21 muls / 13 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator>>(const evector_t& a, const point_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1a1 = a1 * a1, a2a2 = a2 * a2, a1b2 = a1 * b2, a2b1 = a2 * b1,
        t0 = a1a1 + a2a2, t1 = a1b2 - a2b1;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2) - b0 * t0);
    res.d[1] = b1 + 2.0 * (a2 * t1 + a0 * (a1 * b0 - a0 * b1));
    res.d[2] = b2 + 2.0 * (a0 * (a2 * b0 - a0 * b2) - a1 * t1);
    res.d[3] = 1 + 2.0 * (a0 * a0 + t0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between evector and direction  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 19 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator>>(const evector_t& a, const direction_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a2b1 = a2 * b1,
        t0 = a1b2 - a2b1;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2) - b0 * (a1 * a1 + a2 * a2));
    res.d[1] = b1 + 2.0 * (a2 * t0 + a0 * (a1 * b0 - a0 * b1));
    res.d[2] = b2 + 2.0 * (a0 * (a2 * b0 - a0 * b2) - a1 * t0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between evector and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 19 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator>>(const evector_t& a, const ebivector_t& b) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a2b1 = a2 * b1,
        t0 = a1b2 - a2b1;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2) - b0 * (a1 * a1 + a2 * a2));
    res.d[1] = b1 + 2.0 * (a2 * t0 + a0 * (a1 * b0 - a0 * b1));
    res.d[2] = b2 + 2.0 * (a0 * (a2 * b0 - a0 * b2) - a1 * t0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between evector and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator>>(const evector_t& a, const ibivector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 + 2.0 * (a0 * t1);
    res.d[1] = b1 + 2.0 * (a1 * t1);
    res.d[2] = b2 + 2.0 * (a2 * t1);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between evector and evector  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator>>(const evector_t& a, const evector_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 + 2.0 * (a0 * t1);
    res.d[1] = b1 + 2.0 * (a1 * t1);
    res.d[2] = b2 + 2.0 * (a2 * t1);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between evector and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + 1 e₀
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline dpoint_t operator>>(const evector_t& a, const dpoint_t& b) {
    dpoint_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 + 2.0 * (a0 * t1);
    res.d[1] = b1 + 2.0 * (a1 * t1);
    res.d[2] = b2 + 2.0 * (a2 * t1);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between evector and rotation  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 19 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator>>(const evector_t& a, const rotation_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a1b3 = a1 * b3, a2b2 = a2 * b2,
        t0 = a1b3 - a2b2;
    res.d[0] = b0;
    res.d[1] = b1 + 2.0 * (a0 * (a1 * b2 + a2 * b3) - b1 * (a1 * a1 + a2 * a2));
    res.d[2] = b2 + 2.0 * (a2 * t0 + a0 * (a1 * b1 - a0 * b2));
    res.d[3] = b3 + 2.0 * (a0 * (a2 * b1 - a0 * b3) - a1 * t0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between evector and translation  
// a0 e₁ + a1 e₂ + a2 e₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline translation_t operator>>(const evector_t& a, const translation_t& b) {
    translation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 + 2.0 * (a0 * t1);
    res.d[1] = b1 + 2.0 * (a1 * t1);
    res.d[2] = b2 + 2.0 * (a2 * t1);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between evector and even  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 31 muls / 18 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator>>(const evector_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a1a1 = a1 * a1, a2a2 = a2 * a2, a1b3 = a1 * b3, a2b2 = a2 * b2, a0b4 = a0 * b4,
        a1b5 = a1 * b5, a2b6 = a2 * b6,
        t0 = a0b4 + a1b5, t1 = t0 + a2b6, t2 = a1a1 + a2a2, t3 = a1b3 - a2b2;
    res.d[0] = b0;
    res.d[1] = b1 + 2.0 * (a0 * (a1 * b2 + a2 * b3) - b1 * t2);
    res.d[2] = b2 + 2.0 * (a2 * t3 + a0 * (a1 * b1 - a0 * b2));
    res.d[3] = b3 + 2.0 * (a0 * (a2 * b1 - a0 * b3) - a1 * t3);
    res.d[4] = b4 + 2.0 * (a0 * t1);
    res.d[5] = b5 + 2.0 * (a1 * t1);
    res.d[6] = b6 + 2.0 * (a2 * t1);
    res.d[7] = b7 + 2.0 * (b7 * (a0 * a0 + t2));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between evector and odd  
// a0 e₁ + a1 e₂ + a2 e₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 31 muls / 18 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator>>(const evector_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2, a1a1 = a1 * a1, a2a2 = a2 * a2,
        a1b6 = a1 * b6, a2b5 = a2 * b5,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2, t2 = a1a1 + a2a2, t3 = a1b6 - a2b5;
    res.d[0] = b0 + 2.0 * (a0 * t1);
    res.d[1] = b1 + 2.0 * (a1 * t1);
    res.d[2] = b2 + 2.0 * (a2 * t1);
    res.d[3] = b3;
    res.d[4] = b4 + 2.0 * (a0 * (a1 * b5 + a2 * b6) - b4 * t2);
    res.d[5] = b5 + 2.0 * (a2 * t3 + a0 * (a1 * b4 - a0 * b5));
    res.d[6] = b6 + 2.0 * (a0 * (a2 * b4 - a0 * b6) - a1 * t3);
    res.d[7] = b7 + 2.0 * (b7 * (a0 * a0 + t2));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between dpoint and scalar  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator>>(const dpoint_t& a, const scalar_t& b) {

    return b;

}

////////////////////////////////////////////////////////////////////////////////  
// sw between dpoint and vector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 10 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator>>(const dpoint_t& a, const vector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 + 2.0 * (a0 * t1);
    res.d[1] = b1 + 2.0 * (a1 * t1);
    res.d[2] = b2 + 2.0 * (a2 * t1);
    res.d[3] = b3 + 2 * t1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between dpoint and bivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 34 muls / 25 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator>>(const dpoint_t& a, const bivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5],
        a2a2 = a2 * a2, a1b2 = a1 * b2, a2b1 = a2 * b1, a2b0 = a2 * b0, a1b4 = a1 * b4,
        a2b5 = a2 * b5,
        t0 = a1b2 - a2b1, t1 = a1b4 + a2b5;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2) - b0 * (a1 * a1 + a2a2));
    res.d[1] = b1 + 2.0 * (a2 * t0 + a0 * (a1 * b0 - a0 * b1));
    res.d[2] = b2 + 2.0 * (a0 * (a2b0 - a0 * b2) - a1 * t0);
    res.d[3] = b3 + 2.0 * (a1b2 - a2b1 - a0 * (a0 * b3 + t1));
    res.d[4] = b4 + 2.0 * (a2b0 - a1 * t1 - a0 * (a1 * b3 + b2));
    res.d[5] = b5 + 2.0 * (a0 * (b1 - a2 * b3) - a2a2 * b5 - a1 * (a2 * b4 + b0));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between dpoint and trivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 24 muls / 16 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator>>(const dpoint_t& a, const trivector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a1a1 = a1 * a1, a2a2 = a2 * a2, a2b2 = a2 * b2, a2b1 = a2 * b1,
        t0 = a1a1 + a2a2, t1 = a2b2 + b3;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + t1) - b0 * t0);
    res.d[1] = b1 + 2.0 * (a1 * t1 + a0 * (a1 * b0 - a0 * b1) - a2a2 * b1);
    res.d[2] = b2 + 2.0 * (a2 * b3 + a1 * (a2b1 - a1 * b2) + a0 * (a2 * b0 - a0 * b2));
    res.d[3] = b3 + 2.0 * (b3 * (a0 * a0 + t0));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between dpoint and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₁₂₃
// -> r0 e₀₁₂₃
// 5 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator>>(const dpoint_t& a, const quadvector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0];
    res.d[0] = b0 + 2.0 * (b0 * (a0 * a0 + a1 * a1 + a2 * a2));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between dpoint and horizon  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline horizon_t operator>>(const dpoint_t& a, const horizon_t& b) {

    return horizon_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// sw between dpoint and origin  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 7 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator>>(const dpoint_t& a, const origin_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = 2 * a0;
    res.d[1] = 2 * a1;
    res.d[2] = 2 * a2;
    res.d[3] = 1 + 2.0 * (a0 * a0 + a1 * a1 + a2 * a2);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between dpoint and point  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 21 muls / 16 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator>>(const dpoint_t& a, const point_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1a1 = a1 * a1, a2a2 = a2 * a2, a1b2 = a1 * b2, a2b1 = a2 * b1,
        t0 = a1a1 + a2a2, t1 = a1b2 - a2b1;
    res.d[0] = b0 + 2.0 * (a0 * (1 + a1 * b1 + a2 * b2) - b0 * t0);
    res.d[1] = b1 + 2.0 * (a1 + a2 * t1 + a0 * (a1 * b0 - a0 * b1));
    res.d[2] = b2 + 2.0 * (a2 + a0 * (a2 * b0 - a0 * b2) - a1 * t1);
    res.d[3] = 1 + 2.0 * (a0 * a0 + t0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between dpoint and direction  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 19 muls / 11 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator>>(const dpoint_t& a, const direction_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a2b1 = a2 * b1,
        t0 = a1b2 - a2b1;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2) - b0 * (a1 * a1 + a2 * a2));
    res.d[1] = b1 + 2.0 * (a2 * t0 + a0 * (a1 * b0 - a0 * b1));
    res.d[2] = b2 + 2.0 * (a0 * (a2 * b0 - a0 * b2) - a1 * t0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between dpoint and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 22 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator>>(const dpoint_t& a, const ebivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a2b1 = a2 * b1, a0b1 = a0 * b1, a1b0 = a1 * b0, a0b2 = a0 * b2,
        a2b0 = a2 * b0,
        t0 = a1b2 - a2b1, t1 = a0b1 - a1b0, t2 = a0b2 - a2b0;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2) - b0 * (a1 * a1 + a2 * a2));
    res.d[1] = b1 + 2.0 * (a2 * t0 - a0 * t1);
    res.d[2] = b2 - 2 * (a1 * t0 + a0 * t2);
    res.d[3] = 2 * t0;
    res.d[4] = -2 * t2;
    res.d[5] = 2 * t1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between dpoint and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator>>(const dpoint_t& a, const ibivector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 + 2.0 * (a0 * t1);
    res.d[1] = b1 + 2.0 * (a1 * t1);
    res.d[2] = b2 + 2.0 * (a2 * t1);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between dpoint and evector  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 10 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator>>(const dpoint_t& a, const evector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 + 2.0 * (a0 * t1);
    res.d[1] = b1 + 2.0 * (a1 * t1);
    res.d[2] = b2 + 2.0 * (a2 * t1);
    res.d[3] = 2 * t1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between dpoint and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 10 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator>>(const dpoint_t& a, const dpoint_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 + 2.0 * (a0 * t1);
    res.d[1] = b1 + 2.0 * (a1 * t1);
    res.d[2] = b2 + 2.0 * (a2 * t1);
    res.d[3] = 1 + 2 * t1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between dpoint and rotation  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 22 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator>>(const dpoint_t& a, const rotation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a1b3 = a1 * b3, a2b2 = a2 * b2, a0b2 = a0 * b2, a1b1 = a1 * b1, a0b3 = a0 * b3,
        a2b1 = a2 * b1,
        t0 = a1b3 - a2b2, t1 = a0b2 - a1b1, t2 = a0b3 - a2b1;
    res.d[0] = b0;
    res.d[1] = b1 + 2.0 * (a0 * (a1 * b2 + a2 * b3) - b1 * (a1 * a1 + a2 * a2));
    res.d[2] = b2 + 2.0 * (a2 * t0 - a0 * t1);
    res.d[3] = b3 - 2 * (a1 * t0 + a0 * t2);
    res.d[4] = 2 * t0;
    res.d[5] = -2 * t2;
    res.d[6] = 2 * t1;
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between dpoint and translation  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 9 muls / 5 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline translation_t operator>>(const dpoint_t& a, const translation_t& b) {
    translation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2;
    res.d[0] = b0 + 2.0 * (a0 * t1);
    res.d[1] = b1 + 2.0 * (a1 * t1);
    res.d[2] = b2 + 2.0 * (a2 * t1);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between dpoint and even  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 37 muls / 27 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator>>(const dpoint_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a1a1 = a1 * a1, a2a2 = a2 * a2, a1b3 = a1 * b3, a2b2 = a2 * b2, a2b1 = a2 * b1,
        a1b5 = a1 * b5, a2b6 = a2 * b6,
        t0 = a1a1 + a2a2, t1 = a1b3 - a2b2, t2 = a1b5 + a2b6;
    res.d[0] = b0;
    res.d[1] = b1 + 2.0 * (a0 * (a1 * b2 + a2 * b3) - b1 * t0);
    res.d[2] = b2 + 2.0 * (a2 * t1 + a0 * (a1 * b1 - a0 * b2));
    res.d[3] = b3 + 2.0 * (a0 * (a2b1 - a0 * b3) - a1 * t1);
    res.d[4] = b4 + 2.0 * (a1b3 - a2b2 - a0 * (a0 * b4 + t2));
    res.d[5] = b5 + 2.0 * (a2b1 - a1 * t2 - a0 * (a1 * b4 + b3));
    res.d[6] = b6 + 2.0 * (a0 * (b2 - a2 * b4) - a2a2 * b6 - a1 * (a2 * b5 + b1));
    res.d[7] = b7 + 2.0 * (b7 * (a0 * a0 + t0));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between dpoint and odd  
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 34 muls / 22 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator>>(const dpoint_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a0b0 = a0 * b0, a1b1 = a1 * b1, a2b2 = a2 * b2, a1a1 = a1 * a1, a2a2 = a2 * a2,
        a2b6 = a2 * b6, a2b5 = a2 * b5,
        t0 = a0b0 + a1b1, t1 = t0 + a2b2, t2 = a1a1 + a2a2, t3 = a2b6 + b7;
    res.d[0] = b0 + 2.0 * (a0 * t1);
    res.d[1] = b1 + 2.0 * (a1 * t1);
    res.d[2] = b2 + 2.0 * (a2 * t1);
    res.d[3] = b3 + 2 * t1;
    res.d[4] = b4 + 2.0 * (a0 * (a1 * b5 + t3) - b4 * t2);
    res.d[5] = b5 + 2.0 * (a1 * t3 + a0 * (a1 * b4 - a0 * b5) - a2a2 * b5);
    res.d[6] = b6 + 2.0 * (a2 * b7 + a1 * (a2b5 - a1 * b6) + a0 * (a2 * b4 - a0 * b6));
    res.d[7] = b7 + 2.0 * (b7 * (a0 * a0 + t2));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between rotation and scalar  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator>>(const rotation_t& a, const scalar_t& b) {

    return b;

}

////////////////////////////////////////////////////////////////////////////////  
// sw between rotation and vector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 18 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator>>(const rotation_t& a, const vector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a1b2 = a1 * b2, a3b0 = a3 * b0, a1b1 = a1 * b1, a2b0 = a2 * b0, a2b2 = a2 * b2,
        a3b1 = a3 * b1,
        s0 = a1b2 - a3b0, s1 = a3b1 - a2b2, s2 = a2b0 - a1b1;
    res.d[0] = b0 + 2.0 * (a3 * s0 + a0 * s1 - a2 * s2);
    res.d[1] = b1 + 2.0 * (a1 * s2 + a0 * s0 - a3 * s1);
    res.d[2] = b2 + 2.0 * (a2 * s1 + a0 * s2 - a1 * s0);
    res.d[3] = b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between rotation and bivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 36 muls / 24 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator>>(const rotation_t& a, const bivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5],
        a1b2 = a1 * b2, a3b0 = a3 * b0, a1b1 = a1 * b1, a2b0 = a2 * b0, a2b2 = a2 * b2,
        a3b1 = a3 * b1, a1b5 = a1 * b5, a3b3 = a3 * b3, a1b4 = a1 * b4, a2b3 = a2 * b3,
        a2b5 = a2 * b5, a3b4 = a3 * b4,
        s0 = a1b2 - a3b0, s1 = a3b1 - a2b2, s2 = a2b0 - a1b1, s3 = a1b5 - a3b3, s4 = a3b4 - a2b5, s5 = a2b3 - a1b4;
    res.d[0] = b0 + 2.0 * (a3 * s0 + a0 * s1 - a2 * s2);
    res.d[1] = b1 + 2.0 * (a1 * s2 + a0 * s0 - a3 * s1);
    res.d[2] = b2 + 2.0 * (a2 * s1 + a0 * s2 - a1 * s0);
    res.d[3] = b3 + 2.0 * (a3 * s3 + a0 * s4 - a2 * s5);
    res.d[4] = b4 + 2.0 * (a1 * s5 + a0 * s3 - a3 * s4);
    res.d[5] = b5 + 2.0 * (a2 * s4 + a0 * s5 - a1 * s3);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between rotation and trivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 18 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator>>(const rotation_t& a, const trivector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a1b2 = a1 * b2, a3b0 = a3 * b0, a1b1 = a1 * b1, a2b0 = a2 * b0, a2b2 = a2 * b2,
        a3b1 = a3 * b1,
        s0 = a1b2 - a3b0, s1 = a3b1 - a2b2, s2 = a2b0 - a1b1;
    res.d[0] = b0 + 2.0 * (a3 * s0 + a0 * s1 - a2 * s2);
    res.d[1] = b1 + 2.0 * (a1 * s2 + a0 * s0 - a3 * s1);
    res.d[2] = b2 + 2.0 * (a2 * s1 + a0 * s2 - a1 * s0);
    res.d[3] = b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between rotation and quadvector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator>>(const rotation_t& a, const quadvector_t& b) {
    quadvector_t res;
    const float b0 = b.d[0];
    res.d[0] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between rotation and horizon  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline horizon_t operator>>(const rotation_t& a, const horizon_t& b) {

    return horizon_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// sw between rotation and origin  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline origin_t operator>>(const rotation_t& a, const origin_t& b) {

    return origin_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// sw between rotation and point  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 18 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t operator>>(const rotation_t& a, const point_t& b) {
    point_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a3b0 = a3 * b0, a1b1 = a1 * b1, a2b0 = a2 * b0, a2b2 = a2 * b2,
        a3b1 = a3 * b1,
        s0 = a1b2 - a3b0, s1 = a3b1 - a2b2, s2 = a2b0 - a1b1;
    res.d[0] = b0 + 2.0 * (a3 * s0 + a0 * s1 - a2 * s2);
    res.d[1] = b1 + 2.0 * (a1 * s2 + a0 * s0 - a3 * s1);
    res.d[2] = b2 + 2.0 * (a2 * s1 + a0 * s2 - a1 * s0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between rotation and direction  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 18 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator>>(const rotation_t& a, const direction_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a3b0 = a3 * b0, a1b1 = a1 * b1, a2b0 = a2 * b0, a2b2 = a2 * b2,
        a3b1 = a3 * b1,
        s0 = a1b2 - a3b0, s1 = a3b1 - a2b2, s2 = a2b0 - a1b1;
    res.d[0] = b0 + 2.0 * (a3 * s0 + a0 * s1 - a2 * s2);
    res.d[1] = b1 + 2.0 * (a1 * s2 + a0 * s0 - a3 * s1);
    res.d[2] = b2 + 2.0 * (a2 * s1 + a0 * s2 - a1 * s0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between rotation and ebivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 18 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t operator>>(const rotation_t& a, const ebivector_t& b) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a3b0 = a3 * b0, a1b1 = a1 * b1, a2b0 = a2 * b0, a2b2 = a2 * b2,
        a3b1 = a3 * b1,
        s0 = a1b2 - a3b0, s1 = a3b1 - a2b2, s2 = a2b0 - a1b1;
    res.d[0] = b0 + 2.0 * (a3 * s0 + a0 * s1 - a2 * s2);
    res.d[1] = b1 + 2.0 * (a1 * s2 + a0 * s0 - a3 * s1);
    res.d[2] = b2 + 2.0 * (a2 * s1 + a0 * s2 - a1 * s0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between rotation and ibivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 18 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator>>(const rotation_t& a, const ibivector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a3b0 = a3 * b0, a1b1 = a1 * b1, a2b0 = a2 * b0, a2b2 = a2 * b2,
        a3b1 = a3 * b1,
        s0 = a1b2 - a3b0, s1 = a3b1 - a2b2, s2 = a2b0 - a1b1;
    res.d[0] = b0 + 2.0 * (a3 * s0 + a0 * s1 - a2 * s2);
    res.d[1] = b1 + 2.0 * (a1 * s2 + a0 * s0 - a3 * s1);
    res.d[2] = b2 + 2.0 * (a2 * s1 + a0 * s2 - a1 * s0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between rotation and evector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 18 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t operator>>(const rotation_t& a, const evector_t& b) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a3b0 = a3 * b0, a1b1 = a1 * b1, a2b0 = a2 * b0, a2b2 = a2 * b2,
        a3b1 = a3 * b1,
        s0 = a1b2 - a3b0, s1 = a3b1 - a2b2, s2 = a2b0 - a1b1;
    res.d[0] = b0 + 2.0 * (a3 * s0 + a0 * s1 - a2 * s2);
    res.d[1] = b1 + 2.0 * (a1 * s2 + a0 * s0 - a3 * s1);
    res.d[2] = b2 + 2.0 * (a2 * s1 + a0 * s2 - a1 * s0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between rotation and dpoint  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + 1 e₀
// 18 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline dpoint_t operator>>(const rotation_t& a, const dpoint_t& b) {
    dpoint_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a3b0 = a3 * b0, a1b1 = a1 * b1, a2b0 = a2 * b0, a2b2 = a2 * b2,
        a3b1 = a3 * b1,
        s0 = a1b2 - a3b0, s1 = a3b1 - a2b2, s2 = a2b0 - a1b1;
    res.d[0] = b0 + 2.0 * (a3 * s0 + a0 * s1 - a2 * s2);
    res.d[1] = b1 + 2.0 * (a1 * s2 + a0 * s0 - a3 * s1);
    res.d[2] = b2 + 2.0 * (a2 * s1 + a0 * s2 - a1 * s0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between rotation and rotation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 18 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t operator>>(const rotation_t& a, const rotation_t& b) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a1b3 = a1 * b3, a3b1 = a3 * b1, a1b2 = a1 * b2, a2b1 = a2 * b1, a2b3 = a2 * b3,
        a3b2 = a3 * b2,
        s0 = a1b3 - a3b1, s1 = a3b2 - a2b3, s2 = a2b1 - a1b2;
    res.d[0] = b0;
    res.d[1] = b1 + 2.0 * (a3 * s0 + a0 * s1 - a2 * s2);
    res.d[2] = b2 + 2.0 * (a1 * s2 + a0 * s0 - a3 * s1);
    res.d[3] = b3 + 2.0 * (a2 * s1 + a0 * s2 - a1 * s0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between rotation and translation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 18 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline translation_t operator>>(const rotation_t& a, const translation_t& b) {
    translation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a3b0 = a3 * b0, a1b1 = a1 * b1, a2b0 = a2 * b0, a2b2 = a2 * b2,
        a3b1 = a3 * b1,
        s0 = a1b2 - a3b0, s1 = a3b1 - a2b2, s2 = a2b0 - a1b1;
    res.d[0] = b0 + 2.0 * (a3 * s0 + a0 * s1 - a2 * s2);
    res.d[1] = b1 + 2.0 * (a1 * s2 + a0 * s0 - a3 * s1);
    res.d[2] = b2 + 2.0 * (a2 * s1 + a0 * s2 - a1 * s0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between rotation and even  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 36 muls / 24 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator>>(const rotation_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a1b3 = a1 * b3, a3b1 = a3 * b1, a1b2 = a1 * b2, a2b1 = a2 * b1, a2b3 = a2 * b3,
        a3b2 = a3 * b2, a1b6 = a1 * b6, a3b4 = a3 * b4, a1b5 = a1 * b5, a2b4 = a2 * b4,
        a2b6 = a2 * b6, a3b5 = a3 * b5,
        s0 = a1b3 - a3b1, s1 = a3b2 - a2b3, s2 = a2b1 - a1b2, s3 = a1b6 - a3b4, s4 = a3b5 - a2b6, s5 = a2b4 - a1b5;
    res.d[0] = b0;
    res.d[1] = b1 + 2.0 * (a3 * s0 + a0 * s1 - a2 * s2);
    res.d[2] = b2 + 2.0 * (a1 * s2 + a0 * s0 - a3 * s1);
    res.d[3] = b3 + 2.0 * (a2 * s1 + a0 * s2 - a1 * s0);
    res.d[4] = b4 + 2.0 * (a3 * s3 + a0 * s4 - a2 * s5);
    res.d[5] = b5 + 2.0 * (a1 * s5 + a0 * s3 - a3 * s4);
    res.d[6] = b6 + 2.0 * (a2 * s4 + a0 * s5 - a1 * s3);
    res.d[7] = b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between rotation and odd  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 36 muls / 24 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator>>(const rotation_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a1b2 = a1 * b2, a3b0 = a3 * b0, a1b1 = a1 * b1, a2b0 = a2 * b0, a2b2 = a2 * b2,
        a3b1 = a3 * b1, a1b6 = a1 * b6, a3b4 = a3 * b4, a1b5 = a1 * b5, a2b4 = a2 * b4,
        a2b6 = a2 * b6, a3b5 = a3 * b5,
        s0 = a1b2 - a3b0, s1 = a3b1 - a2b2, s2 = a2b0 - a1b1, s3 = a1b6 - a3b4, s4 = a3b5 - a2b6, s5 = a2b4 - a1b5;
    res.d[0] = b0 + 2.0 * (a3 * s0 + a0 * s1 - a2 * s2);
    res.d[1] = b1 + 2.0 * (a1 * s2 + a0 * s0 - a3 * s1);
    res.d[2] = b2 + 2.0 * (a2 * s1 + a0 * s2 - a1 * s0);
    res.d[3] = b3;
    res.d[4] = b4 + 2.0 * (a3 * s3 + a0 * s4 - a2 * s5);
    res.d[5] = b5 + 2.0 * (a1 * s5 + a0 * s3 - a3 * s4);
    res.d[6] = b6 + 2.0 * (a2 * s4 + a0 * s5 - a1 * s3);
    res.d[7] = b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between translation and scalar  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t operator>>(const translation_t& a, const scalar_t& b) {

    return b;

}

////////////////////////////////////////////////////////////////////////////////  
// sw between translation and vector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 4 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator>>(const translation_t& a, const vector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3 + 2.0 * (a0 * b0 + a1 * b1 + a2 * b2);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between translation and bivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator>>(const translation_t& a, const bivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3 + 2.0 * (a2 * b1 - a1 * b2);
    res.d[4] = b4 + 2.0 * (a0 * b2 - a2 * b0);
    res.d[5] = b5 + 2.0 * (a1 * b0 - a0 * b1);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between translation and trivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator>>(const translation_t& a, const trivector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0 - 2 * a0 * b3;
    res.d[1] = b1 - 2 * a1 * b3;
    res.d[2] = b2 - 2 * a2 * b3;
    res.d[3] = b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between translation and quadvector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator>>(const translation_t& a, const quadvector_t& b) {
    quadvector_t res;
    const float b0 = b.d[0];
    res.d[0] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between translation and horizon  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline horizon_t operator>>(const translation_t& a, const horizon_t& b) {

    return horizon_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// sw between translation and origin  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t operator>>(const translation_t& a, const origin_t& b) {
    point_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -2 * a0;
    res.d[1] = -2 * a1;
    res.d[2] = -2 * a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between translation and point  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 3 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t operator>>(const translation_t& a, const point_t& b) {
    point_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0 - 2 * a0;
    res.d[1] = b1 - 2 * a1;
    res.d[2] = b2 - 2 * a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between translation and direction  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator>>(const translation_t& a, const direction_t& b) {
    direction_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between translation and ebivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 9 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator>>(const translation_t& a, const ebivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = 2.0 * (a2 * b1 - a1 * b2);
    res.d[4] = 2.0 * (a0 * b2 - a2 * b0);
    res.d[5] = 2.0 * (a1 * b0 - a0 * b1);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between translation and ibivector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator>>(const translation_t& a, const ibivector_t& b) {
    ibivector_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between translation and evector  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 4 muls / 2 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator>>(const translation_t& a, const evector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = 2.0 * (a0 * b0 + a1 * b1 + a2 * b2);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between translation and dpoint  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 4 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator>>(const translation_t& a, const dpoint_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = 1 + 2.0 * (a0 * b0 + a1 * b1 + a2 * b2);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between translation and rotation  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator>>(const translation_t& a, const rotation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    res.d[4] = 2.0 * (a2 * b2 - a1 * b3);
    res.d[5] = 2.0 * (a0 * b3 - a2 * b1);
    res.d[6] = 2.0 * (a1 * b1 - a0 * b2);
    res.d[7] = 0.0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between translation and translation  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline translation_t operator>>(const translation_t& a, const translation_t& b) {
    translation_t res;
    const float b0 = b.d[0], b1 = b.d[1], b2 = b.d[2];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between translation and even  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator>>(const translation_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3;
    res.d[4] = b4 + 2.0 * (a2 * b2 - a1 * b3);
    res.d[5] = b5 + 2.0 * (a0 * b3 - a2 * b1);
    res.d[6] = b6 + 2.0 * (a1 * b1 - a0 * b2);
    res.d[7] = b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between translation and odd  
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 10 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator>>(const translation_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7];
    res.d[0] = b0;
    res.d[1] = b1;
    res.d[2] = b2;
    res.d[3] = b3 + 2.0 * (a0 * b0 + a1 * b1 + a2 * b2);
    res.d[4] = b4 - 2 * a0 * b7;
    res.d[5] = b5 - 2 * a1 * b7;
    res.d[6] = b6 - 2 * a2 * b7;
    res.d[7] = b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between even and scalar  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator>>(const even_t& a, const scalar_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7];
    res.d[0] = b;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = 2.0 * (b * (a0 * a7 - a1 * a4 - a2 * a5 - a3 * a6));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between even and vector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 35 muls / 24 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator>>(const even_t& a, const vector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a1b2 = a1 * b2, a3b0 = a3 * b0, a1b1 = a1 * b1, a2b0 = a2 * b0, a2b2 = a2 * b2,
        a3b1 = a3 * b1,
        s0 = a1b2 - a3b0, s1 = a3b1 - a2b2, s2 = a2b0 - a1b1;
    res.d[0] = b0 + 2.0 * (a3 * s0 + a0 * s1 - a2 * s2);
    res.d[1] = b1 + 2.0 * (a1 * s2 + a0 * s0 - a3 * s1);
    res.d[2] = b2 + 2.0 * (a2 * s1 + a0 * s2 - a1 * s0);
    res.d[3] = b3 + 2.0 * (a3 * (a4 * b1 + a7 * b2 - a5 * b0) + a2 * (a6 * b0 + a7 * b1 - a4 * b2) + a1 * (a5 * b2 + a7 * b0 - a6 * b1) + a0 * (a4 * b0 + a5 * b1 + a6 * b2));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between even and bivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 53 muls / 47 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator>>(const even_t& a, const bivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5],
        a1b2 = a1 * b2, a3b0 = a3 * b0, a1b1 = a1 * b1, a2b0 = a2 * b0, a2b2 = a2 * b2,
        a3b1 = a3 * b1, a3b3 = a3 * b3, a4b2 = a4 * b2, a6b0 = a6 * b0, a7b1 = a7 * b1,
        a2b3 = a2 * b3, a4b1 = a4 * b1, a5b0 = a5 * b0, a7b2 = a7 * b2, a3b5 = a3 * b5,
        a4b0 = a4 * b0, a5b1 = a5 * b1, a6b2 = a6 * b2, a2b5 = a2 * b5, a3b4 = a3 * b4,
        a5b2 = a5 * b2, a6b1 = a6 * b1, a7b0 = a7 * b0, a1b4 = a1 * b4, a1b5 = a1 * b5,
        s0 = a1b2 - a3b0, s1 = a3b1 - a2b2, s2 = a2b0 - a1b1, s3 = a3b4 + a6b1 - a2b5 - a5b2 - a7b0, s4 = a2b3 + a5b0 - a1b4 - a4b1 - a7b2,
        t0 = a3b3 - a4b2, t1 = t0 + a6b0, t2 = t1 + a7b1, t3 = a4b0 + a5b1, t4 = t3 + a6b2, t5 = a3b5 + t4;
    res.d[0] = b0 + 2.0 * (a3 * s0 + a0 * s1 - a2 * s2);
    res.d[1] = b1 + 2.0 * (a1 * s2 + a0 * s0 - a3 * s1);
    res.d[2] = b2 + 2.0 * (a2 * s1 + a0 * s2 - a1 * s0);
    res.d[3] = b3 + 2.0 * (a2 * (a4b1 + a7b2 - a2b3 - a5b0) + a1 * (a2 * b4 + t5) + a0 * s3 - a3 * t2);
    res.d[4] = b4 + 2.0 * (a3 * (a5b2 + a7b0 - a3b4 - a6b1) + a2 * t5 + a1 * s4 + a0 * (a1b5 - t2));
    res.d[5] = b5 + 2.0 * (a3 * t4 + a2 * s3 + a1 * (t2 - a1b5) + a0 * s4);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between even and trivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 25 muls / 18 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator>>(const even_t& a, const trivector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a7b3 = a7 * b3, a1b2 = a1 * b2, a3b0 = a3 * b0, a5b3 = a5 * b3, a1b1 = a1 * b1,
        a2b0 = a2 * b0, a6b3 = a6 * b3, a2b2 = a2 * b2, a3b1 = a3 * b1, a4b3 = a4 * b3,
        s0 = a1b2 - a3b0 - a5b3, s1 = a3b1 - a2b2 - a4b3, s2 = a2b0 - a1b1 - a6b3;
    res.d[0] = b0 + 2.0 * (a3 * s0 + a0 * s1 - a1 * a7b3 - a2 * s2);
    res.d[1] = b1 + 2.0 * (a1 * s2 + a0 * s0 - a2 * a7b3 - a3 * s1);
    res.d[2] = b2 + 2.0 * (a2 * s1 + a0 * s2 - a3 * a7b3 - a1 * s0);
    res.d[3] = b3;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between even and quadvector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₁₂₃
// -> r0 e₀₁₂₃
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator>>(const even_t& a, const quadvector_t& b) {
    quadvector_t res;
    const float b0 = b.d[0];
    res.d[0] = b0;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between even and horizon  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline horizon_t operator>>(const even_t& a, const horizon_t& b) {

    return horizon_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// sw between even and origin  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 15 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t operator>>(const even_t& a, const origin_t& b) {
    point_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7];
    res.d[0] = 2.0 * (a2 * a6 - a0 * a4 - a1 * a7 - a3 * a5);
    res.d[1] = 2.0 * (a3 * a4 - a0 * a5 - a1 * a6 - a2 * a7);
    res.d[2] = 2.0 * (a1 * a5 - a0 * a6 - a2 * a4 - a3 * a7);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between even and point  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + 1 e₁₂₃
// 21 muls / 18 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline point_t operator>>(const even_t& a, const point_t& b) {
    point_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a3b0 = a3 * b0, a1b1 = a1 * b1, a2b0 = a2 * b0, a2b2 = a2 * b2,
        a3b1 = a3 * b1,
        s0 = a1b2 - a3b0 - a5, s1 = a3b1 - a2b2 - a4, s2 = a2b0 - a1b1 - a6;
    res.d[0] = b0 + 2.0 * (a3 * s0 + a0 * s1 - a1 * a7 - a2 * s2);
    res.d[1] = b1 + 2.0 * (a1 * s2 + a0 * s0 - a2 * a7 - a3 * s1);
    res.d[2] = b2 + 2.0 * (a2 * s1 + a0 * s2 - a3 * a7 - a1 * s0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between even and direction  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 18 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator>>(const even_t& a, const direction_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a3b0 = a3 * b0, a1b1 = a1 * b1, a2b0 = a2 * b0, a2b2 = a2 * b2,
        a3b1 = a3 * b1,
        s0 = a1b2 - a3b0, s1 = a3b1 - a2b2, s2 = a2b0 - a1b1;
    res.d[0] = b0 + 2.0 * (a3 * s0 + a0 * s1 - a2 * s2);
    res.d[1] = b1 + 2.0 * (a1 * s2 + a0 * s0 - a3 * s1);
    res.d[2] = b2 + 2.0 * (a2 * s1 + a0 * s2 - a1 * s0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between even and ebivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 45 muls / 33 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator>>(const even_t& a, const ebivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a3b0 = a3 * b0, a1b1 = a1 * b1, a2b0 = a2 * b0, a2b2 = a2 * b2,
        a3b1 = a3 * b1, a4b2 = a4 * b2, a6b0 = a6 * b0, a7b1 = a7 * b1, a4b1 = a4 * b1,
        a5b0 = a5 * b0, a7b2 = a7 * b2, a4b0 = a4 * b0, a5b1 = a5 * b1, a6b2 = a6 * b2,
        a5b2 = a5 * b2, a6b1 = a6 * b1, a7b0 = a7 * b0,
        s0 = a1b2 - a3b0, s1 = a3b1 - a2b2, s2 = a2b0 - a1b1,
        t0 = a4b2 - a6b0, t1 = t0 - a7b1, t2 = a4b1 - a5b0, t3 = t2 + a7b2, t4 = a4b0 + a5b1, t5 = t4 + a6b2;
    res.d[0] = b0 + 2.0 * (a3 * s0 + a0 * s1 - a2 * s2);
    res.d[1] = b1 + 2.0 * (a1 * s2 + a0 * s0 - a3 * s1);
    res.d[2] = b2 + 2.0 * (a2 * s1 + a0 * s2 - a1 * s0);
    res.d[3] = 2.0 * (a3 * t1 + a2 * t3 + a1 * t5 + a0 * (a6b1 - a5b2 - a7b0));
    res.d[4] = 2.0 * (a3 * (a5b2 + a7b0 - a6b1) + a2 * t5 + a0 * t1 - a1 * t3);
    res.d[5] = 2.0 * (a3 * t5 + a2 * (a6b1 - a5b2 - a7b0) - a1 * t1 - a0 * t3);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between even and ibivector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 18 muls / 12 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator>>(const even_t& a, const ibivector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a3b0 = a3 * b0, a1b1 = a1 * b1, a2b0 = a2 * b0, a2b2 = a2 * b2,
        a3b1 = a3 * b1,
        s0 = a1b2 - a3b0, s1 = a3b1 - a2b2, s2 = a2b0 - a1b1;
    res.d[0] = b0 + 2.0 * (a3 * s0 + a0 * s1 - a2 * s2);
    res.d[1] = b1 + 2.0 * (a1 * s2 + a0 * s0 - a3 * s1);
    res.d[2] = b2 + 2.0 * (a2 * s1 + a0 * s2 - a1 * s0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between even and evector  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 35 muls / 23 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator>>(const even_t& a, const evector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a3b0 = a3 * b0, a1b1 = a1 * b1, a2b0 = a2 * b0, a2b2 = a2 * b2,
        a3b1 = a3 * b1,
        s0 = a1b2 - a3b0, s1 = a3b1 - a2b2, s2 = a2b0 - a1b1;
    res.d[0] = b0 + 2.0 * (a3 * s0 + a0 * s1 - a2 * s2);
    res.d[1] = b1 + 2.0 * (a1 * s2 + a0 * s0 - a3 * s1);
    res.d[2] = b2 + 2.0 * (a2 * s1 + a0 * s2 - a1 * s0);
    res.d[3] = 2.0 * (a3 * (a4 * b1 + a7 * b2 - a5 * b0) + a2 * (a6 * b0 + a7 * b1 - a4 * b2) + a1 * (a5 * b2 + a7 * b0 - a6 * b1) + a0 * (a4 * b0 + a5 * b1 + a6 * b2));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between even and dpoint  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 35 muls / 24 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator>>(const even_t& a, const dpoint_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a3b0 = a3 * b0, a1b1 = a1 * b1, a2b0 = a2 * b0, a2b2 = a2 * b2,
        a3b1 = a3 * b1,
        s0 = a1b2 - a3b0, s1 = a3b1 - a2b2, s2 = a2b0 - a1b1;
    res.d[0] = b0 + 2.0 * (a3 * s0 + a0 * s1 - a2 * s2);
    res.d[1] = b1 + 2.0 * (a1 * s2 + a0 * s0 - a3 * s1);
    res.d[2] = b2 + 2.0 * (a2 * s1 + a0 * s2 - a1 * s0);
    res.d[3] = 1 + 2.0 * (a3 * (a4 * b1 + a7 * b2 - a5 * b0) + a2 * (a6 * b0 + a7 * b1 - a4 * b2) + a1 * (a5 * b2 + a7 * b0 - a6 * b1) + a0 * (a4 * b0 + a5 * b1 + a6 * b2));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between even and rotation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 51 muls / 36 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator>>(const even_t& a, const rotation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a1b3 = a1 * b3, a3b1 = a3 * b1, a1b2 = a1 * b2, a2b1 = a2 * b1, a2b3 = a2 * b3,
        a3b2 = a3 * b2, a4b3 = a4 * b3, a6b1 = a6 * b1, a7b2 = a7 * b2, a4b2 = a4 * b2,
        a5b1 = a5 * b1, a7b3 = a7 * b3, a4b1 = a4 * b1, a5b2 = a5 * b2, a6b3 = a6 * b3,
        a5b3 = a5 * b3, a6b2 = a6 * b2, a7b1 = a7 * b1,
        s0 = a1b3 - a3b1, s1 = a3b2 - a2b3, s2 = a2b1 - a1b2,
        t0 = a4b3 - a6b1, t1 = t0 - a7b2, t2 = a4b2 - a5b1, t3 = t2 + a7b3, t4 = a4b1 + a5b2, t5 = t4 + a6b3;
    res.d[0] = b0;
    res.d[1] = b1 + 2.0 * (a3 * s0 + a0 * s1 - a2 * s2);
    res.d[2] = b2 + 2.0 * (a1 * s2 + a0 * s0 - a3 * s1);
    res.d[3] = b3 + 2.0 * (a2 * s1 + a0 * s2 - a1 * s0);
    res.d[4] = 2.0 * (a3 * t1 + a2 * t3 + a1 * t5 + a0 * (a6b2 - a5b3 - a7b1));
    res.d[5] = 2.0 * (a3 * (a5b3 + a7b1 - a6b2) + a2 * t5 + a0 * t1 - a1 * t3);
    res.d[6] = 2.0 * (a3 * t5 + a2 * (a6b2 - a5b3 - a7b1) - a1 * t1 - a0 * t3);
    res.d[7] = 2.0 * (b0 * (a0 * a7 - a1 * a4 - a2 * a5 - a3 * a6));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between even and translation  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 23 muls / 15 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator>>(const even_t& a, const translation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b2 = a1 * b2, a3b0 = a3 * b0, a1b1 = a1 * b1, a2b0 = a2 * b0, a2b2 = a2 * b2,
        a3b1 = a3 * b1,
        s0 = a1b2 - a3b0, s1 = a3b1 - a2b2, s2 = a2b0 - a1b1;
    res.d[0] = 1.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = b0 + 2.0 * (a3 * s0 + a0 * s1 - a2 * s2);
    res.d[5] = b1 + 2.0 * (a1 * s2 + a0 * s0 - a3 * s1);
    res.d[6] = b2 + 2.0 * (a2 * s1 + a0 * s2 - a1 * s0);
    res.d[7] = 2.0 * (a0 * a7 - a1 * a4 - a2 * a5 - a3 * a6);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between even and even  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 59 muls / 51 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator>>(const even_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a1b3 = a1 * b3, a3b1 = a3 * b1, a1b2 = a1 * b2, a2b1 = a2 * b1, a2b3 = a2 * b3,
        a3b2 = a3 * b2, a3b4 = a3 * b4, a4b3 = a4 * b3, a6b1 = a6 * b1, a7b2 = a7 * b2,
        a2b4 = a2 * b4, a4b2 = a4 * b2, a5b1 = a5 * b1, a7b3 = a7 * b3, a3b6 = a3 * b6,
        a4b1 = a4 * b1, a5b2 = a5 * b2, a6b3 = a6 * b3, a2b6 = a2 * b6, a3b5 = a3 * b5,
        a5b3 = a5 * b3, a6b2 = a6 * b2, a7b1 = a7 * b1, a1b5 = a1 * b5, a1b6 = a1 * b6,
        s0 = a1b3 - a3b1, s1 = a3b2 - a2b3, s2 = a2b1 - a1b2, s3 = a3b5 + a6b2 - a2b6 - a5b3 - a7b1, s4 = a2b4 + a5b1 - a1b5 - a4b2 - a7b3,
        t0 = a3b4 - a4b3, t1 = t0 + a6b1, t2 = t1 + a7b2, t3 = a4b1 + a5b2, t4 = t3 + a6b3, t5 = a3b6 + t4;
    res.d[0] = b0;
    res.d[1] = b1 + 2.0 * (a3 * s0 + a0 * s1 - a2 * s2);
    res.d[2] = b2 + 2.0 * (a1 * s2 + a0 * s0 - a3 * s1);
    res.d[3] = b3 + 2.0 * (a2 * s1 + a0 * s2 - a1 * s0);
    res.d[4] = b4 + 2.0 * (a2 * (a4b2 + a7b3 - a2b4 - a5b1) + a1 * (a2 * b5 + t5) + a0 * s3 - a3 * t2);
    res.d[5] = b5 + 2.0 * (a3 * (a5b3 + a7b1 - a3b5 - a6b2) + a2 * t5 + a1 * s4 + a0 * (a1b6 - t2));
    res.d[6] = b6 + 2.0 * (a3 * t4 + a2 * s3 + a1 * (t2 - a1b6) + a0 * s4);
    res.d[7] = b7 + 2.0 * (b0 * (a0 * a7 - a1 * a4 - a2 * a5 - a3 * a6));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between even and odd  
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 60 muls / 42 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator>>(const even_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a1b2 = a1 * b2, a3b0 = a3 * b0, a1b1 = a1 * b1, a2b0 = a2 * b0, a2b2 = a2 * b2,
        a3b1 = a3 * b1, a7b7 = a7 * b7, a1b6 = a1 * b6, a3b4 = a3 * b4, a5b7 = a5 * b7,
        a1b5 = a1 * b5, a2b4 = a2 * b4, a6b7 = a6 * b7, a2b6 = a2 * b6, a3b5 = a3 * b5,
        a4b7 = a4 * b7,
        s0 = a1b2 - a3b0, s1 = a3b1 - a2b2, s2 = a2b0 - a1b1, s3 = a1b6 - a3b4 - a5b7, s4 = a3b5 - a2b6 - a4b7, s5 = a2b4 - a1b5 - a6b7;
    res.d[0] = b0 + 2.0 * (a3 * s0 + a0 * s1 - a2 * s2);
    res.d[1] = b1 + 2.0 * (a1 * s2 + a0 * s0 - a3 * s1);
    res.d[2] = b2 + 2.0 * (a2 * s1 + a0 * s2 - a1 * s0);
    res.d[3] = b3 + 2.0 * (a3 * (a4 * b1 + a7 * b2 - a5 * b0) + a2 * (a6 * b0 + a7 * b1 - a4 * b2) + a1 * (a5 * b2 + a7 * b0 - a6 * b1) + a0 * (a4 * b0 + a5 * b1 + a6 * b2));
    res.d[4] = b4 + 2.0 * (a3 * s3 + a0 * s4 - a1 * a7b7 - a2 * s5);
    res.d[5] = b5 + 2.0 * (a1 * s5 + a0 * s3 - a2 * a7b7 - a3 * s4);
    res.d[6] = b6 + 2.0 * (a2 * s4 + a0 * s5 - a3 * a7b7 - a1 * s3);
    res.d[7] = b7;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between odd and scalar  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 6 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator>>(const odd_t& a, const scalar_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7];
    res.d[0] = b;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = 0.0;
    res.d[5] = 0.0;
    res.d[6] = 0.0;
    res.d[7] = 2.0 * (b * (a0 * a4 + a1 * a5 + a2 * a6 + a3 * a7));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between odd and vector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 38 muls / 27 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator>>(const odd_t& a, const vector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a1b1 = a1 * b1, a2b2 = a2 * b2, a2b0 = a2 * b0, a7b1 = a7 * b1, a1b0 = a1 * b0,
        a7b2 = a7 * b2,
        s0 = a2b0 + a7b1, s1 = a1b1 + a2b2,
        t0 = a1b0 - a7b2;
    res.d[0] = b0 + 2.0 * (a7 * (a2 * b1 - a1 * b2 - a7 * b0) - a0 * (a0 * b0 + a1b1 + a2b2));
    res.d[1] = b1 - 2 * (a7 * s0 + a1 * s1 + a0 * t0);
    res.d[2] = b2 + 2.0 * (a7 * t0 - a2 * s1 - a0 * s0);
    res.d[3] = b3 + 2.0 * (a7 * (a4 * b0 + a5 * b1 + a6 * b2) + a2 * (a5 * b0 - a3 * b2 - a4 * b1) + a1 * (a4 * b2 - a3 * b1 - a6 * b0) + a0 * (a6 * b1 - a3 * b0 - a5 * b2));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between odd and bivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂ + b3 e₀₁ + b4 e₀₂ + b5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 57 muls / 54 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator>>(const odd_t& a, const bivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5],
        a2b0 = a2 * b0, a7b1 = a7 * b1, a1b0 = a1 * b0, a7b2 = a7 * b2, a1b2 = a1 * b2,
        a2b1 = a2 * b1, a7b0 = a7 * b0, a3b0 = a3 * b0, a5b2 = a5 * b2, a6b1 = a6 * b1,
        a7b3 = a7 * b3, a3b1 = a3 * b1, a4b2 = a4 * b2, a6b0 = a6 * b0, a7b4 = a7 * b4,
        a3b2 = a3 * b2, a4b1 = a4 * b1, a5b0 = a5 * b0, a7b5 = a7 * b5, a1b4 = a1 * b4,
        a2b5 = a2 * b5, a4b0 = a4 * b0, a5b1 = a5 * b1, a6b2 = a6 * b2,
        s0 = a3b0 + a5b2 - a6b1 - a7b3, s1 = a3b2 + a4b1 - a5b0 - a7b5,
        t0 = a3b1 - a4b2, t1 = t0 + a6b0, t2 = t1 - a7b4, t3 = a2b5 - a4b0, t4 = t3 - a5b1, t5 = t4 - a6b2;
    res.d[0] = b0 + 2.0 * (a1 * (a7b2 - a1b0) + a0 * (a1 * b1 + a2 * b2) - a2 * (a2b0 + a7b1));
    res.d[1] = b1 + 2.0 * (a2 * (a1b2 + a7b0 - a2b1) + a0 * (a1b0 - a0 * b1 - a7b2));
    res.d[2] = b2 + 2.0 * (a1 * (a2b1 - a1b2 - a7b0) + a0 * (a2b0 + a7b1 - a0 * b2));
    res.d[3] = b3 + 2.0 * (a7 * s0 + a1 * s1 - a2 * t2 - a0 * (a0 * b3 + a1b4 + t5));
    res.d[4] = b4 + 2.0 * (a7 * t2 + a2 * s0 + a0 * (a5b0 + a7b5 - a1 * b3 - a3b2 - a4b1) - a1 * (a1b4 + t5));
    res.d[5] = b5 + 2.0 * (a7 * s1 + a1 * (a6b1 + a7b3 - a2 * b4 - a3b0 - a5b2) + a0 * (t2 - a2 * b3) - a2 * t5);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between odd and trivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + b3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 38 muls / 28 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator>>(const odd_t& a, const trivector_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a4b3 = a4 * b3, a2b0 = a2 * b0, a5b3 = a5 * b3, a7b1 = a7 * b1, a1b0 = a1 * b0,
        a6b3 = a6 * b3, a7b2 = a7 * b2, a1b2 = a1 * b2, a2b1 = a2 * b1, a7b0 = a7 * b0,
        t0 = a2b0 - a5b3, t1 = t0 + a7b1, t2 = a1b0 + a6b3, t3 = t2 - a7b2, t4 = a1b2 - a2b1, t5 = t4 - a4b3;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2 + a3 * b3) - a4b3 * a7 - a2 * t1 - a1 * t3);
    res.d[1] = b1 + 2.0 * (b3 * (a1 * a3 - a5 * a7) + a2 * (t5 + a7b0) + a0 * (t3 - a0 * b1));
    res.d[2] = b2 + 2.0 * (b3 * (a2 * a3 - a6 * a7) + a0 * (t1 - a0 * b2) - a1 * (t5 + a7b0));
    res.d[3] = b3 + 2.0 * (b3 * (a0 * a0 + a1 * a1 + a2 * a2 + a7 * a7));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between odd and quadvector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₁₂₃
// -> r0 e₀₁₂₃
// 6 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline quadvector_t operator>>(const odd_t& a, const quadvector_t& b) {
    quadvector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a7 = a.d[7], b0 = b.d[0];
    res.d[0] = b0 + 2.0 * (b0 * (a0 * a0 + a1 * a1 + a2 * a2 + a7 * a7));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between odd and horizon  

////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline horizon_t operator>>(const odd_t& a, const horizon_t& b) {

    return horizon_t{};

}

////////////////////////////////////////////////////////////////////////////////  
// sw between odd and origin  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 20 muls / 13 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator>>(const odd_t& a, const origin_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7];
    res.d[0] = 2.0 * (a0 * a3 + a2 * a5 - a1 * a6 - a4 * a7);
    res.d[1] = 2.0 * (a0 * a6 + a1 * a3 - a2 * a4 - a5 * a7);
    res.d[2] = 2.0 * (a1 * a4 + a2 * a3 - a0 * a5 - a6 * a7);
    res.d[3] = 1 + 2.0 * (a0 * a0 + a1 * a1 + a2 * a2 + a7 * a7);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between odd and point  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 31 muls / 28 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t operator>>(const odd_t& a, const point_t& b) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a2b0 = a2 * b0, a7b1 = a7 * b1, a1b0 = a1 * b0, a7b2 = a7 * b2, a1b2 = a1 * b2,
        a2b1 = a2 * b1, a7b0 = a7 * b0,
        t0 = a2b0 - a5, t1 = t0 + a7b1, t2 = a1b0 + a6, t3 = t2 - a7b2, t4 = a1b2 - a2b1, t5 = t4 - a4;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2 + a3) - a4 * a7 - a2 * t1 - a1 * t3);
    res.d[1] = b1 + 2.0 * (a1 * a3 + a2 * (t5 + a7b0) + a0 * (t3 - a0 * b1) - a5 * a7);
    res.d[2] = b2 + 2.0 * (a2 * a3 + a0 * (t1 - a0 * b2) - a6 * a7 - a1 * (t5 + a7b0));
    res.d[3] = 1 + 2.0 * (a0 * a0 + a1 * a1 + a2 * a2 + a7 * a7);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between odd and direction  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₃₂ + b1 e₀₁₃ + b2 e₀₂₁
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁
// 21 muls / 14 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline direction_t operator>>(const odd_t& a, const direction_t& b) {
    direction_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a2b0 = a2 * b0, a7b1 = a7 * b1, a1b0 = a1 * b0, a7b2 = a7 * b2, a1b2 = a1 * b2,
        a2b1 = a2 * b1, a7b0 = a7 * b0,
        t0 = a2b0 + a7b1, t1 = a1b0 - a7b2, t2 = a1b2 - a2b1, t3 = t2 + a7b0;
    res.d[0] = b0 + 2.0 * (a0 * (a1 * b1 + a2 * b2) - a2 * t0 - a1 * t1);
    res.d[1] = b1 + 2.0 * (a2 * t3 + a0 * (t1 - a0 * b1));
    res.d[2] = b2 + 2.0 * (a0 * (t0 - a0 * b2) - a1 * t3);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between odd and ebivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₂₃ + b1 e₃₁ + b2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 48 muls / 39 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t operator>>(const odd_t& a, const ebivector_t& b) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a2b0 = a2 * b0, a7b1 = a7 * b1, a1b0 = a1 * b0, a7b2 = a7 * b2, a1b2 = a1 * b2,
        a2b1 = a2 * b1, a7b0 = a7 * b0, a3b0 = a3 * b0, a5b2 = a5 * b2, a6b1 = a6 * b1,
        a3b1 = a3 * b1, a4b2 = a4 * b2, a6b0 = a6 * b0, a3b2 = a3 * b2, a4b1 = a4 * b1,
        a5b0 = a5 * b0, a4b0 = a4 * b0, a5b1 = a5 * b1, a6b2 = a6 * b2,
        t0 = a3b0 + a5b2, t1 = t0 - a6b1, t2 = a3b1 - a4b2, t3 = t2 + a6b0, t4 = a3b2 + a4b1, t5 = t4 - a5b0;
    res.d[0] = b0 + 2.0 * (a1 * (a7b2 - a1b0) + a0 * (a1 * b1 + a2 * b2) - a2 * (a2b0 + a7b1));
    res.d[1] = b1 + 2.0 * (a2 * (a1b2 + a7b0 - a2b1) + a0 * (a1b0 - a0 * b1 - a7b2));
    res.d[2] = b2 + 2.0 * (a1 * (a2b1 - a1b2 - a7b0) + a0 * (a2b0 + a7b1 - a0 * b2));
    res.d[3] = 2.0 * (a7 * t1 + a1 * t5 + a0 * (a4b0 + a5b1 + a6b2) - a2 * t3);
    res.d[4] = 2.0 * (a7 * t3 + a2 * t1 + a1 * (a4b0 + a5b1 + a6b2) - a0 * t5);
    res.d[5] = 2.0 * (a7 * t5 + a2 * (a4b0 + a5b1 + a6b2) + a0 * t3 - a1 * t1);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between odd and ibivector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 21 muls / 15 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ibivector_t operator>>(const odd_t& a, const ibivector_t& b) {
    ibivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b1 = a1 * b1, a2b2 = a2 * b2, a2b0 = a2 * b0, a7b1 = a7 * b1, a1b0 = a1 * b0,
        a7b2 = a7 * b2,
        s0 = a2b0 + a7b1, s1 = a1b1 + a2b2,
        t0 = a1b0 - a7b2;
    res.d[0] = b0 + 2.0 * (a7 * (a2 * b1 - a1 * b2 - a7 * b0) - a0 * (a0 * b0 + a1b1 + a2b2));
    res.d[1] = b1 - 2 * (a7 * s0 + a1 * s1 + a0 * t0);
    res.d[2] = b2 + 2.0 * (a7 * t0 - a2 * s1 - a0 * s0);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between odd and evector  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 38 muls / 26 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator>>(const odd_t& a, const evector_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b1 = a1 * b1, a2b2 = a2 * b2, a2b0 = a2 * b0, a7b1 = a7 * b1, a1b0 = a1 * b0,
        a7b2 = a7 * b2,
        s0 = a2b0 + a7b1, s1 = a1b1 + a2b2,
        t0 = a1b0 - a7b2;
    res.d[0] = b0 + 2.0 * (a7 * (a2 * b1 - a1 * b2 - a7 * b0) - a0 * (a0 * b0 + a1b1 + a2b2));
    res.d[1] = b1 - 2 * (a7 * s0 + a1 * s1 + a0 * t0);
    res.d[2] = b2 + 2.0 * (a7 * t0 - a2 * s1 - a0 * s0);
    res.d[3] = 2.0 * (a7 * (a4 * b0 + a5 * b1 + a6 * b2) + a2 * (a5 * b0 - a3 * b2 - a4 * b1) + a1 * (a4 * b2 - a3 * b1 - a6 * b0) + a0 * (a6 * b1 - a3 * b0 - a5 * b2));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between odd and dpoint  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 38 muls / 27 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t operator>>(const odd_t& a, const dpoint_t& b) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b1 = a1 * b1, a2b2 = a2 * b2, a2b0 = a2 * b0, a7b1 = a7 * b1, a1b0 = a1 * b0,
        a7b2 = a7 * b2,
        s0 = a2b0 + a7b1, s1 = a1b1 + a2b2,
        t0 = a1b0 - a7b2;
    res.d[0] = b0 + 2.0 * (a7 * (a2 * b1 - a1 * b2 - a7 * b0) - a0 * (a0 * b0 + a1b1 + a2b2));
    res.d[1] = b1 - 2 * (a7 * s0 + a1 * s1 + a0 * t0);
    res.d[2] = b2 + 2.0 * (a7 * t0 - a2 * s1 - a0 * s0);
    res.d[3] = 1 + 2.0 * (a7 * (a4 * b0 + a5 * b1 + a6 * b2) + a2 * (a5 * b0 - a3 * b2 - a4 * b1) + a1 * (a4 * b2 - a3 * b1 - a6 * b0) + a0 * (a6 * b1 - a3 * b0 - a5 * b2));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between odd and rotation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 54 muls / 42 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator>>(const odd_t& a, const rotation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3],
        a2b1 = a2 * b1, a7b2 = a7 * b2, a1b1 = a1 * b1, a7b3 = a7 * b3, a1b3 = a1 * b3,
        a2b2 = a2 * b2, a7b1 = a7 * b1, a3b1 = a3 * b1, a5b3 = a5 * b3, a6b2 = a6 * b2,
        a3b2 = a3 * b2, a4b3 = a4 * b3, a6b1 = a6 * b1, a3b3 = a3 * b3, a4b2 = a4 * b2,
        a5b1 = a5 * b1, a4b1 = a4 * b1, a5b2 = a5 * b2, a6b3 = a6 * b3,
        t0 = a3b1 + a5b3, t1 = t0 - a6b2, t2 = a3b2 - a4b3, t3 = t2 + a6b1, t4 = a3b3 + a4b2, t5 = t4 - a5b1;
    res.d[0] = b0;
    res.d[1] = b1 + 2.0 * (a1 * (a7b3 - a1b1) + a0 * (a1 * b2 + a2 * b3) - a2 * (a2b1 + a7b2));
    res.d[2] = b2 + 2.0 * (a2 * (a1b3 + a7b1 - a2b2) + a0 * (a1b1 - a0 * b2 - a7b3));
    res.d[3] = b3 + 2.0 * (a1 * (a2b2 - a1b3 - a7b1) + a0 * (a2b1 + a7b2 - a0 * b3));
    res.d[4] = 2.0 * (a7 * t1 + a1 * t5 + a0 * (a4b1 + a5b2 + a6b3) - a2 * t3);
    res.d[5] = 2.0 * (a7 * t3 + a2 * t1 + a1 * (a4b1 + a5b2 + a6b3) - a0 * t5);
    res.d[6] = 2.0 * (a7 * t5 + a2 * (a4b1 + a5b2 + a6b3) + a0 * t3 - a1 * t1);
    res.d[7] = 2.0 * (b0 * (a0 * a4 + a1 * a5 + a2 * a6 + a3 * a7));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between odd and translation  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// 1 + b0 e₀₁ + b1 e₀₂ + b2 e₀₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 26 muls / 18 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator>>(const odd_t& a, const translation_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2],
        a1b1 = a1 * b1, a2b2 = a2 * b2, a2b0 = a2 * b0, a7b1 = a7 * b1, a1b0 = a1 * b0,
        a7b2 = a7 * b2,
        s0 = a2b0 + a7b1, s1 = a1b1 + a2b2,
        t0 = a1b0 - a7b2;
    res.d[0] = 1.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = 0.0;
    res.d[4] = b0 + 2.0 * (a7 * (a2 * b1 - a1 * b2 - a7 * b0) - a0 * (a0 * b0 + a1b1 + a2b2));
    res.d[5] = b1 - 2 * (a7 * s0 + a1 * s1 + a0 * t0);
    res.d[6] = b2 + 2.0 * (a7 * t0 - a2 * s1 - a0 * s0);
    res.d[7] = 2.0 * (a0 * a4 + a1 * a5 + a2 * a6 + a3 * a7);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between odd and even  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 + b1 e₂₃ + b2 e₃₁ + b3 e₁₂ + b4 e₀₁ + b5 e₀₂ + b6 e₀₃ + b7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 70 muls / 62 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t operator>>(const odd_t& a, const even_t& b) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a2b1 = a2 * b1, a7b2 = a7 * b2, a1b1 = a1 * b1, a7b3 = a7 * b3, a1b3 = a1 * b3,
        a2b2 = a2 * b2, a7b1 = a7 * b1, a3b1 = a3 * b1, a5b3 = a5 * b3, a6b2 = a6 * b2,
        a7b4 = a7 * b4, a3b2 = a3 * b2, a4b3 = a4 * b3, a6b1 = a6 * b1, a7b5 = a7 * b5,
        a3b3 = a3 * b3, a4b2 = a4 * b2, a5b1 = a5 * b1, a7b6 = a7 * b6, a1b5 = a1 * b5,
        a2b6 = a2 * b6, a4b1 = a4 * b1, a5b2 = a5 * b2, a6b3 = a6 * b3,
        s0 = a3b1 + a5b3 - a6b2 - a7b4, s1 = a3b3 + a4b2 - a5b1 - a7b6,
        t0 = a3b2 - a4b3, t1 = t0 + a6b1, t2 = t1 - a7b5, t3 = a2b6 - a4b1, t4 = t3 - a5b2, t5 = t4 - a6b3;
    res.d[0] = b0;
    res.d[1] = b1 + 2.0 * (a1 * (a7b3 - a1b1) + a0 * (a1 * b2 + a2 * b3) - a2 * (a2b1 + a7b2));
    res.d[2] = b2 + 2.0 * (a2 * (a1b3 + a7b1 - a2b2) + a0 * (a1b1 - a0 * b2 - a7b3));
    res.d[3] = b3 + 2.0 * (a1 * (a2b2 - a1b3 - a7b1) + a0 * (a2b1 + a7b2 - a0 * b3));
    res.d[4] = b4 + 2.0 * (a7 * s0 + a1 * s1 - a2 * t2 - a0 * (a0 * b4 + a1b5 + t5));
    res.d[5] = b5 + 2.0 * (a7 * t2 + a2 * s0 + a0 * (a5b1 + a7b6 - a1 * b4 - a3b3 - a4b2) - a1 * (a1b5 + t5));
    res.d[6] = b6 + 2.0 * (a7 * s1 + a1 * (a6b2 + a7b4 - a2 * b5 - a3b1 - a5b3) + a0 * (t2 - a2 * b4) - a2 * t5);
    res.d[7] = b7 + 2.0 * (a7 * (a3 * b0 + a7 * b7) + a2 * (a2 * b7 + a6 * b0) + a1 * (a1 * b7 + a5 * b0) + a0 * (a0 * b7 + a4 * b0));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// sw between odd and odd  
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// b0 e₁ + b1 e₂ + b2 e₃ + b3 e₀ + b4 e₀₃₂ + b5 e₀₁₃ + b6 e₀₂₁ + b7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 76 muls / 56 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t operator>>(const odd_t& a, const odd_t& b) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7], b0 = b.d[0], b1 = b.d[1], b2 = b.d[2], b3 = b.d[3], b4 = b.d[4], b5 = b.d[5], b6 = b.d[6], b7 = b.d[7],
        a1b1 = a1 * b1, a2b2 = a2 * b2, a2b0 = a2 * b0, a7b1 = a7 * b1, a1b0 = a1 * b0,
        a7b2 = a7 * b2, a4b7 = a4 * b7, a2b4 = a2 * b4, a5b7 = a5 * b7, a7b5 = a7 * b5,
        a1b4 = a1 * b4, a6b7 = a6 * b7, a7b6 = a7 * b6, a1b6 = a1 * b6, a2b5 = a2 * b5,
        a7b4 = a7 * b4,
        s0 = a2b0 + a7b1, s1 = a1b1 + a2b2,
        t0 = a1b0 - a7b2, t1 = a2b4 - a5b7, t2 = t1 + a7b5, t3 = a1b4 + a6b7, t4 = t3 - a7b6, t5 = a1b6 - a2b5;
    res.d[0] = b0 + 2.0 * (a7 * (a2 * b1 - a1 * b2 - a7 * b0) - a0 * (a0 * b0 + a1b1 + a2b2));
    res.d[1] = b1 - 2 * (a7 * s0 + a1 * s1 + a0 * t0);
    res.d[2] = b2 + 2.0 * (a7 * t0 - a2 * s1 - a0 * s0);
    res.d[3] = b3 + 2.0 * (a7 * (a4 * b0 + a5 * b1 + a6 * b2) + a2 * (a5 * b0 - a3 * b2 - a4 * b1) + a1 * (a4 * b2 - a3 * b1 - a6 * b0) + a0 * (a6 * b1 - a3 * b0 - a5 * b2));
    res.d[4] = b4 + 2.0 * (a0 * (a1 * b5 + a2 * b6 + a3 * b7) - a4b7 * a7 - a2 * t2 - a1 * t4);
    res.d[5] = b5 + 2.0 * (b7 * (a1 * a3 - a5 * a7) + a2 * (t5 + a7b4 - a4b7) + a0 * (t4 - a0 * b5));
    res.d[6] = b6 + 2.0 * (b7 * (a2 * a3 - a6 * a7) + a1 * (a4b7 - t5 - a7b4) + a0 * (t2 - a0 * b6));
    res.d[7] = b7 + 2.0 * (b7 * (a0 * a0 + a1 * a1 + a2 * a2 + a7 * a7));
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// inverse of scalar
// a
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t inverse(const scalar_t& a) {

    return (1) / (a);

}

////////////////////////////////////////////////////////////////////////////////  
// inverse of vector
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t inverse(const vector_t& a) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = (a0) / (a0 * a0 + a1 * a1 + a2 * a2);
    res.d[1] = (a1) / (a0 * a0 + a1 * a1 + a2 * a2);
    res.d[2] = (a2) / (a0 * a0 + a1 * a1 + a2 * a2);
    res.d[3] = (a3) / (a0 * a0 + a1 * a1 + a2 * a2);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// inverse of bivector
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂ + a3 e₀₁ + a4 e₀₂ + a5 e₀₃
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂ + r3 e₀₁ + r4 e₀₂ + r5 e₀₃
// 180 muls / 51 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline bivector_t inverse(const bivector_t& a) {
    bivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5];
    res.d[0] = (-a0 * a0 * a0 - a0 * a1 * a1 - a0 * a2 * a2) / (a0 * a0 * a0 * a0 + 2 * a0 * a0 * a1 * a1 + 2 * a0 * a0 * a2 * a2 + a1 * a1 * a1 * a1 + 2 * a1 * a1 * a2 * a2 + a2 * a2 * a2 * a2);
    res.d[1] = (-a0 * a0 * a1 - a1 * a1 * a1 - a1 * a2 * a2) / (a0 * a0 * a0 * a0 + 2 * a0 * a0 * a1 * a1 + 2 * a0 * a0 * a2 * a2 + a1 * a1 * a1 * a1 + 2 * a1 * a1 * a2 * a2 + a2 * a2 * a2 * a2);
    res.d[2] = (-a0 * a0 * a2 - a1 * a1 * a2 - a2 * a2 * a2) / (a0 * a0 * a0 * a0 + 2 * a0 * a0 * a1 * a1 + 2 * a0 * a0 * a2 * a2 + a1 * a1 * a1 * a1 + 2 * a1 * a1 * a2 * a2 + a2 * a2 * a2 * a2);
    res.d[3] = (a0 * a0 * a3 + 2 * a0 * a1 * a4 + 2 * a0 * a2 * a5 - a1 * a1 * a3 - a2 * a2 * a3) / (a0 * a0 * a0 * a0 + 2 * a0 * a0 * a1 * a1 + 2 * a0 * a0 * a2 * a2 + a1 * a1 * a1 * a1 + 2 * a1 * a1 * a2 * a2 + a2 * a2 * a2 * a2);
    res.d[4] = (2 * a0 * a1 * a3 + a1 * a1 * a4 + 2 * a1 * a2 * a5 - a0 * a0 * a4 - a2 * a2 * a4) / (a0 * a0 * a0 * a0 + 2 * a0 * a0 * a1 * a1 + 2 * a0 * a0 * a2 * a2 + a1 * a1 * a1 * a1 + 2 * a1 * a1 * a2 * a2 + a2 * a2 * a2 * a2);
    res.d[5] = (2 * a0 * a2 * a3 + 2 * a1 * a2 * a4 + a2 * a2 * a5 - a0 * a0 * a5 - a1 * a1 * a5) / (a0 * a0 * a0 * a0 + 2 * a0 * a0 * a1 * a1 + 2 * a0 * a0 * a2 * a2 + a1 * a1 * a1 * a1 + 2 * a1 * a1 * a2 * a2 + a2 * a2 * a2 * a2);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// inverse of trivector
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + a3 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 3 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t inverse(const trivector_t& a) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = (-a0) / (a3 * a3);
    res.d[1] = (-a1) / (a3 * a3);
    res.d[2] = (-a2) / (a3 * a3);
    res.d[3] = (-1) / (a3);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// inverse of quadvector
// a0 e₀₁₂₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t inverse(const quadvector_t& a) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// inverse of horizon
// 1 e₀
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t inverse(const horizon_t& a) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// inverse of origin
// 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 1 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t inverse(const origin_t& a) {
    trivector_t res;
    res.d[0] = 0.0;
    res.d[1] = 0.0;
    res.d[2] = 0.0;
    res.d[3] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// inverse of point
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁ + 1 e₁₂₃
// -> r0 e₀₃₂ + r1 e₀₁₃ + r2 e₀₂₁ + r3 e₁₂₃
// 0 muls / 4 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline trivector_t inverse(const point_t& a) {
    trivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    res.d[3] = -1;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// inverse of direction
// a0 e₀₃₂ + a1 e₀₁₃ + a2 e₀₂₁
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t inverse(const direction_t& a) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// inverse of ebivector
// a0 e₂₃ + a1 e₃₁ + a2 e₁₂
// -> r0 e₂₃ + r1 e₃₁ + r2 e₁₂
// 9 muls / 9 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline ebivector_t inverse(const ebivector_t& a) {
    ebivector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = (-a0) / (a0 * a0 + a1 * a1 + a2 * a2);
    res.d[1] = (-a1) / (a0 * a0 + a1 * a1 + a2 * a2);
    res.d[2] = (-a2) / (a0 * a0 + a1 * a1 + a2 * a2);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// inverse of ibivector
// a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// -> r
// 0 muls / 0 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline scalar_t inverse(const ibivector_t& a) {

    return 0.0f;

}

////////////////////////////////////////////////////////////////////////////////  
// inverse of evector
// a0 e₁ + a1 e₂ + a2 e₃
// -> r0 e₁ + r1 e₂ + r2 e₃
// 9 muls / 6 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline evector_t inverse(const evector_t& a) {
    evector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = (a0) / (a0 * a0 + a1 * a1 + a2 * a2);
    res.d[1] = (a1) / (a0 * a0 + a1 * a1 + a2 * a2);
    res.d[2] = (a2) / (a0 * a0 + a1 * a1 + a2 * a2);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// inverse of dpoint
// a0 e₁ + a1 e₂ + a2 e₃ + 1 e₀
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀
// 12 muls / 8 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline vector_t inverse(const dpoint_t& a) {
    vector_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = (a0) / (a0 * a0 + a1 * a1 + a2 * a2);
    res.d[1] = (a1) / (a0 * a0 + a1 * a1 + a2 * a2);
    res.d[2] = (a2) / (a0 * a0 + a1 * a1 + a2 * a2);
    res.d[3] = (1) / (a0 * a0 + a1 * a1 + a2 * a2);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// inverse of rotation
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂
// 16 muls / 15 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline rotation_t inverse(const rotation_t& a) {
    rotation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3];
    res.d[0] = (a0) / (a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3);
    res.d[1] = (-a1) / (a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3);
    res.d[2] = (-a2) / (a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3);
    res.d[3] = (-a3) / (a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// inverse of translation
// 1 + a0 e₀₁ + a1 e₀₂ + a2 e₀₃
// -> 1 + r0 e₀₁ + r1 e₀₂ + r2 e₀₃
// 0 muls / 3 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline translation_t inverse(const translation_t& a) {
    translation_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2];
    res.d[0] = -a0;
    res.d[1] = -a1;
    res.d[2] = -a2;
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// inverse of even
// a0 + a1 e₂₃ + a2 e₃₁ + a3 e₁₂ + a4 e₀₁ + a5 e₀₂ + a6 e₀₃ + a7 e₀₁₂₃
// -> r0 + r1 e₂₃ + r2 e₃₁ + r3 e₁₂ + r4 e₀₁ + r5 e₀₂ + r6 e₀₃ + r7 e₀₁₂₃
// 388 muls / 111 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline even_t inverse(const even_t& a) {
    even_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7];
    res.d[0] = (a0 * a0 * a0 + a0 * a1 * a1 + a0 * a2 * a2 + a0 * a3 * a3) / (a0 * a0 * a0 * a0 + 2 * a0 * a0 * a1 * a1 + 2 * a0 * a0 * a2 * a2 + 2 * a0 * a0 * a3 * a3 + a1 * a1 * a1 * a1 + 2 * a1 * a1 * a2 * a2 + 2 * a1 * a1 * a3 * a3 + a2 * a2 * a2 * a2 + 2 * a2 * a2 * a3 * a3 + a3 * a3 * a3 * a3);
    res.d[1] = (-a0 * a0 * a1 - a1 * a1 * a1 - a1 * a2 * a2 - a1 * a3 * a3) / (a0 * a0 * a0 * a0 + 2 * a0 * a0 * a1 * a1 + 2 * a0 * a0 * a2 * a2 + 2 * a0 * a0 * a3 * a3 + a1 * a1 * a1 * a1 + 2 * a1 * a1 * a2 * a2 + 2 * a1 * a1 * a3 * a3 + a2 * a2 * a2 * a2 + 2 * a2 * a2 * a3 * a3 + a3 * a3 * a3 * a3);
    res.d[2] = (-a0 * a0 * a2 - a1 * a1 * a2 - a2 * a2 * a2 - a2 * a3 * a3) / (a0 * a0 * a0 * a0 + 2 * a0 * a0 * a1 * a1 + 2 * a0 * a0 * a2 * a2 + 2 * a0 * a0 * a3 * a3 + a1 * a1 * a1 * a1 + 2 * a1 * a1 * a2 * a2 + 2 * a1 * a1 * a3 * a3 + a2 * a2 * a2 * a2 + 2 * a2 * a2 * a3 * a3 + a3 * a3 * a3 * a3);
    res.d[3] = (-a0 * a0 * a3 - a1 * a1 * a3 - a2 * a2 * a3 - a3 * a3 * a3) / (a0 * a0 * a0 * a0 + 2 * a0 * a0 * a1 * a1 + 2 * a0 * a0 * a2 * a2 + 2 * a0 * a0 * a3 * a3 + a1 * a1 * a1 * a1 + 2 * a1 * a1 * a2 * a2 + 2 * a1 * a1 * a3 * a3 + a2 * a2 * a2 * a2 + 2 * a2 * a2 * a3 * a3 + a3 * a3 * a3 * a3);
    res.d[4] = (a1 * a1 * a4 + 2 * a1 * a2 * a5 + 2 * a1 * a3 * a6 - a0 * a0 * a4 - 2 * a0 * a1 * a7 - a2 * a2 * a4 - a3 * a3 * a4) / (a0 * a0 * a0 * a0 + 2 * a0 * a0 * a1 * a1 + 2 * a0 * a0 * a2 * a2 + 2 * a0 * a0 * a3 * a3 + a1 * a1 * a1 * a1 + 2 * a1 * a1 * a2 * a2 + 2 * a1 * a1 * a3 * a3 + a2 * a2 * a2 * a2 + 2 * a2 * a2 * a3 * a3 + a3 * a3 * a3 * a3);
    res.d[5] = (2 * a1 * a2 * a4 + a2 * a2 * a5 + 2 * a2 * a3 * a6 - a0 * a0 * a5 - 2 * a0 * a2 * a7 - a1 * a1 * a5 - a3 * a3 * a5) / (a0 * a0 * a0 * a0 + 2 * a0 * a0 * a1 * a1 + 2 * a0 * a0 * a2 * a2 + 2 * a0 * a0 * a3 * a3 + a1 * a1 * a1 * a1 + 2 * a1 * a1 * a2 * a2 + 2 * a1 * a1 * a3 * a3 + a2 * a2 * a2 * a2 + 2 * a2 * a2 * a3 * a3 + a3 * a3 * a3 * a3);
    res.d[6] = (2 * a1 * a3 * a4 + 2 * a2 * a3 * a5 + a3 * a3 * a6 - a0 * a0 * a6 - 2 * a0 * a3 * a7 - a1 * a1 * a6 - a2 * a2 * a6) / (a0 * a0 * a0 * a0 + 2 * a0 * a0 * a1 * a1 + 2 * a0 * a0 * a2 * a2 + 2 * a0 * a0 * a3 * a3 + a1 * a1 * a1 * a1 + 2 * a1 * a1 * a2 * a2 + 2 * a1 * a1 * a3 * a3 + a2 * a2 * a2 * a2 + 2 * a2 * a2 * a3 * a3 + a3 * a3 * a3 * a3);
    res.d[7] = (2 * a0 * a1 * a4 + 2 * a0 * a2 * a5 + 2 * a0 * a3 * a6 + a1 * a1 * a7 + a2 * a2 * a7 + a3 * a3 * a7 - a0 * a0 * a7) / (a0 * a0 * a0 * a0 + 2 * a0 * a0 * a1 * a1 + 2 * a0 * a0 * a2 * a2 + 2 * a0 * a0 * a3 * a3 + a1 * a1 * a1 * a1 + 2 * a1 * a1 * a2 * a2 + 2 * a1 * a1 * a3 * a3 + a2 * a2 * a2 * a2 + 2 * a2 * a2 * a3 * a3 + a3 * a3 * a3 * a3);
    return res;
}

////////////////////////////////////////////////////////////////////////////////  
// inverse of odd
// a0 e₁ + a1 e₂ + a2 e₃ + a3 e₀ + a4 e₀₃₂ + a5 e₀₁₃ + a6 e₀₂₁ + a7 e₁₂₃
// -> r0 e₁ + r1 e₂ + r2 e₃ + r3 e₀ + r4 e₀₃₂ + r5 e₀₁₃ + r6 e₀₂₁ + r7 e₁₂₃
// 388 muls / 109 adds
////////////////////////////////////////////////////////////////////////////////  

CONSTEXPR inline odd_t inverse(const odd_t& a) {
    odd_t res;
    const float a0 = a.d[0], a1 = a.d[1], a2 = a.d[2], a3 = a.d[3], a4 = a.d[4], a5 = a.d[5], a6 = a.d[6], a7 = a.d[7];
    res.d[0] = (a0 * a0 * a0 + a0 * a1 * a1 + a0 * a2 * a2 + a0 * a7 * a7) / (a0 * a0 * a0 * a0 + 2 * a0 * a0 * a1 * a1 + 2 * a0 * a0 * a2 * a2 + 2 * a0 * a0 * a7 * a7 + a1 * a1 * a1 * a1 + 2 * a1 * a1 * a2 * a2 + 2 * a1 * a1 * a7 * a7 + a2 * a2 * a2 * a2 + 2 * a2 * a2 * a7 * a7 + a7 * a7 * a7 * a7);
    res.d[1] = (a0 * a0 * a1 + a1 * a1 * a1 + a1 * a2 * a2 + a1 * a7 * a7) / (a0 * a0 * a0 * a0 + 2 * a0 * a0 * a1 * a1 + 2 * a0 * a0 * a2 * a2 + 2 * a0 * a0 * a7 * a7 + a1 * a1 * a1 * a1 + 2 * a1 * a1 * a2 * a2 + 2 * a1 * a1 * a7 * a7 + a2 * a2 * a2 * a2 + 2 * a2 * a2 * a7 * a7 + a7 * a7 * a7 * a7);
    res.d[2] = (a0 * a0 * a2 + a1 * a1 * a2 + a2 * a2 * a2 + a2 * a7 * a7) / (a0 * a0 * a0 * a0 + 2 * a0 * a0 * a1 * a1 + 2 * a0 * a0 * a2 * a2 + 2 * a0 * a0 * a7 * a7 + a1 * a1 * a1 * a1 + 2 * a1 * a1 * a2 * a2 + 2 * a1 * a1 * a7 * a7 + a2 * a2 * a2 * a2 + 2 * a2 * a2 * a7 * a7 + a7 * a7 * a7 * a7);
    res.d[3] = (a0 * a0 * a3 + a1 * a1 * a3 + a2 * a2 * a3 - 2 * a0 * a4 * a7 - 2 * a1 * a5 * a7 - 2 * a2 * a6 * a7 - a3 * a7 * a7) / (a0 * a0 * a0 * a0 + 2 * a0 * a0 * a1 * a1 + 2 * a0 * a0 * a2 * a2 + 2 * a0 * a0 * a7 * a7 + a1 * a1 * a1 * a1 + 2 * a1 * a1 * a2 * a2 + 2 * a1 * a1 * a7 * a7 + a2 * a2 * a2 * a2 + 2 * a2 * a2 * a7 * a7 + a7 * a7 * a7 * a7);
    res.d[4] = (a0 * a0 * a4 + 2 * a0 * a1 * a5 + 2 * a0 * a2 * a6 + 2 * a0 * a3 * a7 - a1 * a1 * a4 - a2 * a2 * a4 - a4 * a7 * a7) / (a0 * a0 * a0 * a0 + 2 * a0 * a0 * a1 * a1 + 2 * a0 * a0 * a2 * a2 + 2 * a0 * a0 * a7 * a7 + a1 * a1 * a1 * a1 + 2 * a1 * a1 * a2 * a2 + 2 * a1 * a1 * a7 * a7 + a2 * a2 * a2 * a2 + 2 * a2 * a2 * a7 * a7 + a7 * a7 * a7 * a7);
    res.d[5] = (2 * a0 * a1 * a4 + a1 * a1 * a5 + 2 * a1 * a2 * a6 + 2 * a1 * a3 * a7 - a0 * a0 * a5 - a2 * a2 * a5 - a5 * a7 * a7) / (a0 * a0 * a0 * a0 + 2 * a0 * a0 * a1 * a1 + 2 * a0 * a0 * a2 * a2 + 2 * a0 * a0 * a7 * a7 + a1 * a1 * a1 * a1 + 2 * a1 * a1 * a2 * a2 + 2 * a1 * a1 * a7 * a7 + a2 * a2 * a2 * a2 + 2 * a2 * a2 * a7 * a7 + a7 * a7 * a7 * a7);
    res.d[6] = (2 * a0 * a2 * a4 + 2 * a1 * a2 * a5 + a2 * a2 * a6 + 2 * a2 * a3 * a7 - a0 * a0 * a6 - a1 * a1 * a6 - a6 * a7 * a7) / (a0 * a0 * a0 * a0 + 2 * a0 * a0 * a1 * a1 + 2 * a0 * a0 * a2 * a2 + 2 * a0 * a0 * a7 * a7 + a1 * a1 * a1 * a1 + 2 * a1 * a1 * a2 * a2 + 2 * a1 * a1 * a7 * a7 + a2 * a2 * a2 * a2 + 2 * a2 * a2 * a7 * a7 + a7 * a7 * a7 * a7);
    res.d[7] = (-a0 * a0 * a7 - a1 * a1 * a7 - a2 * a2 * a7 - a7 * a7 * a7) / (a0 * a0 * a0 * a0 + 2 * a0 * a0 * a1 * a1 + 2 * a0 * a0 * a2 * a2 + 2 * a0 * a0 * a7 * a7 + a1 * a1 * a1 * a1 + 2 * a1 * a1 * a2 * a2 + 2 * a1 * a1 * a7 * a7 + a2 * a2 * a2 * a2 + 2 * a2 * a2 * a7 * a7 + a7 * a7 * a7 * a7);
    return res;
}


